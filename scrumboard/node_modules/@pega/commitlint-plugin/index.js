/* eslint-disable sonarjs/cognitive-complexity */

'use strict';

/**
 * @template [Value=never]
 * @typedef {import('@commitlint/types').Rule<Value>} Rule<Value>
 */

/**
 * @template [Value=never]
 * @typedef {import('@commitlint/types').SyncRule<Value>} SyncRule<Value>
 */

/**
 * @template [Value=never]
 * @typedef {import('@commitlint/types').AsyncRule<Value>} AsyncRule<Value>
 */

const { promises: fs } = require('fs');
const path = require('path');
const { fork } = require('child_process');

/**
 * @param {string} dir
 * @param {string} file
 * @returns {Promise<string>}
 */
const findFileInDirOrAncestor = async (dir, file) => {
  const entries = await fs.readdir(dir);

  if (entries.find(f => f === file)) return path.join(dir, file);

  const newDir = path.join(dir, '..');
  if (newDir === dir) throw new Error(`"${file}" not found.`);

  return findFileInDirOrAncestor(newDir, file);
};

/** @type {string | null} */
let cspellBinPath = null;

// Type rules index signature as Rule<any> to allow it to match Plugin type while still having types for rule parameters.
const /** @type {{ rules: { [ruleName: string]: Rule<any> } }} */ Plugin = {
    rules: {
      '@pega/multi-scope-enum':
        /** @type {SyncRule<{ scopes?: string[]; separator?: string | RegExp; trim?: boolean; }>} */ (
          { scope },
          enable = 'always',
          { scopes = [], separator = /\\|\/|,/, trim = false } = {}
        ) => {
          if (!scope || !scopes.length) return [true, ''];

          if (enable === 'always') {
            return [
              scope.split(separator).every(s => scopes.includes(trim ? s.trim() : s)),
              `Scope must be one or more of the following [${scopes.join(', ')}].`
            ];
          }

          // enable === 'never'
          return [
            !scope.split(separator).some(s => scopes.includes(trim ? s.trim() : s)),
            `Scope must not be one or more of the following [${scopes.join(', ')}].`
          ];
        },

      '@pega/header-reference': /** @type {SyncRule} */ (
        { header, references },
        enable = 'always'
      ) => {
        if (!header) return [true, ''];

        if (enable === 'always') {
          return [
            references.some(({ raw }) => header.includes(raw)),
            'Header must contain a reference id.'
          ];
        }

        // enable === 'never'
        return [
          !references.some(({ raw }) => header.includes(raw)),
          'Header must not contain a reference id.'
        ];
      },

      '@pega/reference-action-enum':
        /** @type {SyncRule<{ actions?: string[]; caseSensitive?: boolean; }>} */ (
          { references },
          enable = 'always',
          {
            actions = [
              'close',
              'closes',
              'closed',
              'fix',
              'fixes',
              'fixed',
              'resolve',
              'resolves',
              'resolved'
            ],
            caseSensitive = false
          } = {}
        ) => {
          if (!references.length) return [true, ''];

          if (!caseSensitive) actions = actions.map(action => action.toLowerCase());

          if (enable === 'always') {
            return [
              references.every(
                ({ action }) =>
                  action && actions.includes(caseSensitive ? action : action.toLowerCase())
              ),
              `Reference action must be one or more of the following [${actions.join(', ')}].`
            ];
          }

          // enable === 'never'
          return [
            !references.some(
              ({ action }) =>
                action && actions.includes(caseSensitive ? action : action.toLowerCase())
            ),
            `Reference action must not be one or more of the following [${actions.join(', ')}].`
          ];
        },

      '@pega/reference-order':
        /** @type {SyncRule<{ prefixes?: string[]; ascending?: boolean; }>} */ (
          { references },
          enable = 'always',
          { prefixes = ['#'], ascending = true } = {}
        ) => {
          if (references.length < 2 || enable !== 'always') return [true, ''];

          /** @type {{ [prefix: string]: string[][]; }} */
          const referenceMap = {};

          let highestPrefixIndex = -1;
          for (const { prefix, issue } of references) {
            if (issue) {
              const idx = prefixes.findIndex(p => p === prefix);

              // Check prefixes are ordered.
              if (highestPrefixIndex > idx) {
                return [
                  false,
                  `References must be in the following order [${prefixes.join(', ')}].`
                ];
              }

              // Group reference id's by prefix.
              if (!referenceMap[prefix]) referenceMap[prefix] = [];
              referenceMap[prefix].push(issue.split(/\D+/));

              highestPrefixIndex = idx;
            }
          }

          // Check id's are ordered.
          for (const refs of Object.values(referenceMap).filter(r => r.length >= 2)) {
            if (!ascending) refs.reverse();

            for (let refIdx = 0; refIdx < refs.length - 1; refIdx += 1) {
              const refA = refs[refIdx];
              const refB = refs[refIdx + 1];

              for (let partIdx = 0; partIdx < Math.max(refA.length, refB.length); partIdx += 1) {
                const refAPart = Number.parseInt(refA[partIdx] ?? '0', 10);
                const refBPart = Number.parseInt(refB[partIdx] ?? '0', 10);

                if (refAPart < refBPart) break;
                else if (refAPart > refBPart) {
                  return [
                    false,
                    `References must be in ${ascending ? 'ascending' : 'descending'} order.`
                  ];
                }
              }
            }
          }

          return [true, ''];
        },

      '@pega/merge-commit': /** @type {SyncRule} */ ({ merge }, enable = 'never') => {
        if (enable !== 'never') return [true, ''];

        return [!merge, 'Merge commits are not allowed.'];
      },

      '@pega/revert-commit': /** @type {SyncRule} */ ({ revert }, enable = 'never') => {
        if (enable !== 'never') return [true, ''];

        return [!revert, 'Revert commits are not allowed.'];
      },

      '@pega/spellcheck': /** @type {AsyncRule} */ async ({ raw }, enable = 'always') => {
        if (enable !== 'always') return [true, ''];

        if (!cspellBinPath) {
          try {
            cspellBinPath = await findFileInDirOrAncestor(
              path.dirname(require.resolve('cspell')),
              'bin.js'
            );
          } catch {
            return [false, 'Unable to load cspell.'];
          }
        }

        const cspell = fork(cspellBinPath, ['--no-summary', '--unique', 'stdin'], {
          stdio: 'pipe'
        });

        cspell.stdin?.write(
          raw
            .split('\n')
            .filter(s => !s.startsWith('#'))
            .join('\n')
        );
        cspell.stdin?.end();

        /** @type {Buffer[]} */
        const out = [];
        let outLen = 0;
        cspell.stdout?.on('data', chunk => {
          out.push(chunk);
          outLen += Buffer.byteLength(chunk);
        });

        return new Promise(resolve => {
          cspell.on('exit', code => {
            if (code === 0) resolve([true, '']);

            const output = Buffer.concat(out, outLen).toString('utf-8');

            const words = [...output.matchAll(/^stdin:\d+:\d+ - Unknown word \((.*)\)$/gm)].map(
              ([, word]) => word
            );

            resolve([false, `Unknown word${words.length === 1 ? '' : 's'} [${words.join(', ')}].`]);
          });
        });
      }
    }
  };

module.exports = Plugin;
