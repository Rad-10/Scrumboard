import { useRef, useEffect } from 'react';
import useEvent from './useEvent';
/**
 * Formats the raw value using given formatter and handles the caret position.
 * @param ref reference to input element.
 * @param rawValue value to be formatted.
 * @param formatter formatter function accepting partial input and returning partially formatted value.
 * @param acceptableCharacters string containing all the characters that may appear in the value to format. RegExp shorthands are also accepted. Only numbers are accepted by default.
 * @returns formatted value that should be passed to the input component.
 */
const useInputFormatter = (ref, rawValue, formatter, acceptableCharacters = '\\p{N}') => {
    // synthetic caret position in unformatted value
    const rawValueCaretPositionRef = useRef();
    useEvent('keydown', e => {
        const inputEl = ref.current;
        if (inputEl) {
            const caretPositionStart = inputEl.selectionStart ?? 0;
            const caretPositionEnd = inputEl.selectionEnd ?? 0;
            const currentValue = inputEl.value;
            if (caretPositionStart !== caretPositionEnd && ['Backspace', 'Delete'].includes(e.key)) {
                // if selection contains only formatting characters, move the caret to the beginning of the selection
                const selectedText = currentValue.slice(caretPositionStart, caretPositionEnd);
                if (!new RegExp(`[${acceptableCharacters}]`, 'gu').test(selectedText)) {
                    inputEl.setSelectionRange(caretPositionStart, caretPositionStart);
                    e.preventDefault();
                }
                return;
            }
            if (e.key === 'Backspace' &&
                new RegExp(`[^${acceptableCharacters}]`, 'gu').test(currentValue.charAt(caretPositionStart - 1))) {
                const lastNonFormatChar = new RegExp(`[${acceptableCharacters}](?=[^${acceptableCharacters}]*$)`, 'gu');
                // match last non-formatting character if it can be found in the preceding slice
                if (lastNonFormatChar.test(currentValue.slice(0, caretPositionStart))) {
                    // move the caret after matched character to get it removed
                    inputEl.setSelectionRange(lastNonFormatChar.lastIndex, lastNonFormatChar.lastIndex);
                }
                else {
                    e.preventDefault();
                }
            }
            if (e.key === 'Delete' &&
                new RegExp(`[^${acceptableCharacters}]`, 'gu').test(currentValue.charAt(caretPositionEnd))) {
                const firstNonFormatChar = new RegExp(`[${acceptableCharacters}]`, 'gu');
                firstNonFormatChar.lastIndex = caretPositionEnd;
                // find first non-formatting character in the value starting from the caret position
                if (firstNonFormatChar.test(currentValue)) {
                    // move the caret before matched character to get it removed
                    inputEl.setSelectionRange(firstNonFormatChar.lastIndex - 1, firstNonFormatChar.lastIndex - 1);
                }
                else {
                    e.preventDefault();
                }
            }
        }
    }, { target: ref, dependencies: [acceptableCharacters] });
    useEvent('input', () => {
        const inputEl = ref.current;
        if (inputEl) {
            // calculate new synthetic caret position in the unformatted value
            const currentCaretPosition = inputEl.selectionStart ?? 0;
            rawValueCaretPositionRef.current = inputEl.value
                .slice(0, currentCaretPosition)
                .replace(new RegExp(`[^${acceptableCharacters}]`, 'gu'), '').length;
        }
    }, { target: ref, dependencies: [acceptableCharacters] });
    useEffect(() => {
        const inputEl = ref.current;
        if (inputEl && rawValueCaretPositionRef.current !== undefined) {
            // create regexp with every raw value character wrapped in possible formatting characters
            const rawValueRegExpSource = `[^${acceptableCharacters}]*${rawValue
                .slice(0, rawValueCaretPositionRef.current)
                .split('')
                .join(`[^${acceptableCharacters}]*`)}`;
            const match = inputEl.value.match(new RegExp(rawValueRegExpSource, 'gu'));
            if (match) {
                // if it matches move the real caret to the corresponding index in the raw value
                inputEl.setSelectionRange(match[0].length, match[0].length);
            }
            else {
                // just re-position the caret otherwise
                inputEl.setSelectionRange(rawValueCaretPositionRef.current, rawValueCaretPositionRef.current);
            }
            rawValueCaretPositionRef.current = undefined;
        }
    }, [rawValue, acceptableCharacters]);
    return formatter(rawValue);
};
export default useInputFormatter;
//# sourceMappingURL=useInputFormatter.js.map