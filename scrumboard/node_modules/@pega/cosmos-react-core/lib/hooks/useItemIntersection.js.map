{"version":3,"file":"useItemIntersection.js","sourceRoot":"","sources":["../../src/hooks/useItemIntersection.ts"],"names":[],"mappings":"AAAA,OAAO,EAAa,SAAS,EAAE,MAAM,OAAO,CAAC;AAE7C;;;;;;;GAOG;AAEH,MAAM,mBAAmB,GAAG,CAC1B,YAAoC,EACpC,MAAc,EACd,EAAc,EACd,YAAoB,EACpB,EAAE;IACF,SAAS,CAAC,GAAG,EAAE;QACb,IAAI,IAAI,GAAuB,IAAI,CAAC;QACpC,IAAI,MAAM,GAAG,CAAC,EAAE;YACd,MAAM,KAAK,GAA4B,CACrC,YAAY,CAAC,OAAO,KAAK,IAAI,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,YAAY,CAAC,OAAO,CACrE,CAAC,gBAAgB,CAAC,YAAY,CAAC,CAAC;YAEjC,IAAI,KAAK,CAAC,MAAM,GAAG,MAAM,EAAE;gBACzB,IAAI,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC;aACtB;SACF;QACD,IAAI,IAAI,EAAE;YACR,MAAM,oBAAoB,GAAG,IAAI,oBAAoB,CACnD,CAAC,OAAoC,EAAE,EAAE;gBACvC,IAAI,OAAO,CAAC,CAAC,CAAC,CAAC,cAAc,EAAE;oBAC7B,EAAE,EAAE,CAAC;iBACN;YACH,CAAC,EACD;gBACE,IAAI,EAAE,YAAY,CAAC,OAAO;aAC3B,CACF,CAAC;YACF,oBAAoB,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;YACnC,OAAO,GAAG,EAAE;gBACV,oBAAoB,CAAC,UAAU,EAAE,CAAC;YACpC,CAAC,CAAC;SACH;IACH,CAAC,EAAE,CAAC,EAAE,EAAE,YAAY,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC,CAAC;AACzC,CAAC,CAAC;AAEF,eAAe,mBAAmB,CAAC","sourcesContent":["import { RefObject, useEffect } from 'react';\n\n/**\n * @example useItemIntersection(listRef,offset,() => { do_some_thing; });\n * @param containerRef The ref of the List.\n * @param offset  Index of the list item which needs to be observed.\n * @param cb Callback that needs to be fired on intersect\n * @param itemSelector Selector used to get the node list of items\n * @returns void.\n */\n\nconst useItemIntersection = (\n  containerRef: RefObject<HTMLElement>,\n  offset: number,\n  cb: () => void,\n  itemSelector: string\n) => {\n  useEffect(() => {\n    let item: HTMLElement | null = null;\n    if (offset > 0) {\n      const items: NodeListOf<HTMLElement> = (\n        containerRef.current === null ? document.body : containerRef.current\n      ).querySelectorAll(itemSelector);\n\n      if (items.length > offset) {\n        item = items[offset];\n      }\n    }\n    if (item) {\n      const intersectionObserver = new IntersectionObserver(\n        (entries: IntersectionObserverEntry[]) => {\n          if (entries[0].isIntersecting) {\n            cb();\n          }\n        },\n        {\n          root: containerRef.current\n        }\n      );\n      intersectionObserver.observe(item);\n      return () => {\n        intersectionObserver.disconnect();\n      };\n    }\n  }, [cb, containerRef.current, offset]);\n};\n\nexport default useItemIntersection;\n"]}