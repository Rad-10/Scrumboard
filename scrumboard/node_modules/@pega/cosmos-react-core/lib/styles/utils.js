import { parseToHsl, lighten, readableColor, darken, getContrast, hsl, modularScale } from 'polished';
import { tryCatch } from '../utils';
export const getHoverColors = (color) => {
    const backgroundLightness = tryCatch(() => parseToHsl(color).lightness, () => 1);
    let hoverColor = tryCatch(() => lighten(0.1, color));
    let hoverContrastColor = tryCatch(() => readableColor(lighten(0.1, color)));
    if (backgroundLightness > 0.35) {
        hoverColor = tryCatch(() => darken(0.1, color));
        hoverContrastColor = tryCatch(() => readableColor(darken(0.1, color)));
    }
    return { background: hoverColor, foreground: hoverContrastColor };
};
const wcagContrast = {
    // https://www.w3.org/TR/WCAG21/#contrast-minimum
    AA: 4.5,
    AALarge: 3,
    // https://www.w3.org/TR/WCAG21/#contrast-enhanced
    AAA: 7,
    AAALarge: 4.5,
    // https://www.w3.org/TR/WCAG21/#non-text-contrast
    AANonText: 3
};
export const readableHue = (color1, color2, { mode = 'both', level = 'AA' } = {}) => {
    const minContrast = typeof level === 'string' ? wcagContrast[level] : level;
    if (getContrast(color1, color2) >= minContrast)
        return color1;
    const { lightness, ...hueSaturation } = parseToHsl(color1);
    let shouldLighten = true;
    let shouldDarken = true;
    let lightEnough = '';
    let darkEnough = '';
    for (let i = 0; i <= 1; i += 0.01) {
        if (shouldLighten) {
            const lightented = hsl({
                ...hueSaturation,
                lightness: Math.min(lightness + i, 1)
            });
            if (getContrast(lightented, color2) >= minContrast) {
                if (mode !== 'dark')
                    return lightented;
                shouldLighten = false;
                lightEnough = lightented;
            }
            if (lightness + i >= 1)
                shouldLighten = false;
        }
        if (shouldDarken) {
            const darkened = hsl({
                ...hueSaturation,
                lightness: Math.max(lightness - i, 0)
            });
            if (getContrast(darkened, color2) >= minContrast) {
                if (mode !== 'light')
                    return darkened;
                shouldDarken = false;
                darkEnough = darkened;
            }
            if (lightness - i <= 0)
                shouldDarken = false;
        }
        if (!shouldLighten && !shouldDarken)
            break;
    }
    if (lightEnough)
        return lightEnough;
    if (darkEnough)
        return darkEnough;
    return readableColor(color2);
};
export const omitProps = (...props) => ({
    shouldForwardProp: (prop, defaultValidatorFn) => !props.includes(prop) && defaultValidatorFn(prop)
});
const stepsMap = {
    xxs: -2,
    xs: -1,
    s: 0,
    m: 1,
    l: 2,
    xl: 3,
    xxl: 4
};
export const calculateFontSize = (baseFontSize, baseFontScale) => {
    if (baseFontScale === 'linear')
        return Object.fromEntries(Object.entries(stepsMap).map(([size, steps]) => [
            size,
            `calc(${baseFontSize} + (${steps} * 0.0625rem))`
        ]));
    return Object.fromEntries(Object.entries(stepsMap).map(([size, steps]) => [
        size,
        tryCatch(() => modularScale(steps, baseFontSize, baseFontScale), () => baseFontSize)
    ]));
};
//# sourceMappingURL=utils.js.map