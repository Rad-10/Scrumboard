import { jsx as _jsx } from "react/jsx-runtime";
import { useEffect, useState, useCallback, useMemo, forwardRef, createContext } from 'react';
import styled, { css } from 'styled-components';
import { defaultThemeProp } from '../../theme';
import { reflow } from '../../utils';
import Flex from '../Flex';
import { useConsolidatedRef, useElement } from '../../hooks';
export const BackdropContext = createContext({
    el: null
});
const transitionSpeedToTheme = {
    slow: 2,
    medium: 1,
    fast: 0.5,
    none: 0
};
export const StyledBackdrop = styled.div(props => {
    const { theme: { base } } = props;
    const { opacity, alpha, variant, position } = props;
    const transitionDuration = `max(calc(${transitionSpeedToTheme[props.transitionSpeed]} * ${base.animation.speed}), 1ms)`;
    return css `
    position: ${position};
    z-index: ${position === 'fixed' ? base['z-index'].backdrop : base['z-index'].popover + 1};
    top: 0;
    left: 0;
    height: 100%;
    width: 100%;
    border-radius: inherit;
    opacity: ${opacity};
    transition-property: opacity;
    transition-timing-function: ${props.theme.base.animation.timing.ease};

    /* stylelint-disable declaration-block-no-duplicate-properties */
    transition-duration: 1ms;
    transition-duration: ${transitionDuration};

    /* stylelint-enable declaration-block-no-duplicate-properties */

    ${variant === 'dark' &&
        css `
      background: rgba(0, 0, 0, ${alpha});
    `}

    ${variant === 'light' &&
        css `
      background: rgba(255, 255, 255, ${alpha});
    `}
  `;
});
StyledBackdrop.defaultProps = defaultThemeProp;
const Backdrop = forwardRef((props, ref) => {
    const { children, container, open = false, variant = 'dark', transitionSpeed = 'medium', alpha = 0.6, position = 'fixed', onBeforeTransitionIn, onAfterTransitionIn, onBeforeTransitionOut, onAfterTransitionOut, ...restProps } = props;
    const [state, setState] = useState('closed');
    const [backdropEl, setBackdropEl] = useElement();
    const backdropRef = useConsolidatedRef(ref, setBackdropEl);
    const onTransitionEnd = useCallback((e) => {
        if (e.propertyName !== 'opacity' || e.target !== e.currentTarget)
            return;
        let nextState;
        if (state === 'closing') {
            nextState = 'closed';
            onAfterTransitionOut?.();
        }
        else {
            nextState = 'open';
            onAfterTransitionIn?.();
        }
        setState(nextState);
    }, [state, onAfterTransitionOut, onAfterTransitionIn]);
    useEffect(() => {
        if (open) {
            if (state === 'closed' || state === 'closing') {
                onBeforeTransitionIn?.();
                reflow();
                setState('opening');
            }
        }
        else if (state === 'open' || state === 'opening') {
            onBeforeTransitionOut?.();
            setState('closing');
        }
    }, [open, onBeforeTransitionIn, onBeforeTransitionOut]);
    const ctxValue = useMemo(() => ({ el: backdropEl }), [backdropEl]);
    return !open && state === 'closed' ? null : (_jsx(BackdropContext.Provider, { value: ctxValue, children: _jsx(Flex, { container: { justify: 'center', alignItems: 'center', ...container }, as: StyledBackdrop, transitionSpeed: transitionSpeed, opacity: state === 'opening' || state === 'open' ? 1 : 0, alpha: alpha, variant: variant, position: position, onTransitionEnd: onTransitionEnd, ref: backdropRef, ...restProps, children: children }) }));
});
export default Backdrop;
//# sourceMappingURL=Backdrop.js.map