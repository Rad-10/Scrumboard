import { createElement as _createElement } from "react";
import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import { useReducer, useMemo, useEffect, useContext, memo } from 'react';
import { createPortal } from 'react-dom';
import { createUID, windowIsAvailable } from '../../utils';
import { useConfiguration, useScrollToggle } from '../../hooks';
import '../../init';
import DockedModals from './DockedModals';
import { ModalContext, ModalManagerContext } from './Contexts';
const reducer = (modals, payload) => {
    switch (payload.action) {
        case 'create':
            return [
                ...modals.map(modal => {
                    if ((!payload.modal.options.alert &&
                        payload.modal.state === 'open' &&
                        !modal.options.alert &&
                        modal.state === 'open' &&
                        modal.options.minimizable) ||
                        payload.modal.options.dockable) {
                        modal.state = 'minimized';
                    }
                    return modal;
                }),
                payload.modal
            ];
        case 'unmount':
            return modals.filter(modal => modal.id !== payload.modal.id);
        case 'dismiss':
            return modals.map(modal => {
                modal.state = modal.id === payload.modal.id ? 'closed' : modal.state;
                return modal;
            });
        case 'update':
            return modals.map(modal => {
                modal.props =
                    modal.id === payload.modal.id ? { ...modal.props, ...payload.modal.props } : modal.props;
                return modal;
            });
        case 'activate':
            return modals.map(modal => {
                if (modal.id === payload.modal.id && !modal.options.dockable) {
                    modal.state = 'open';
                }
                else if (modal.id === payload.modal.id && modal.options.dockable) {
                    modal.state = 'docked';
                }
                else if (!modal.options.alert && modal.state === 'open' && modal.options.minimizable) {
                    modal.state = 'minimized';
                }
                return modal;
            });
        case 'minimize':
            return modals.map(modal => {
                modal.state =
                    modal.id === payload.modal.id && modal.options.minimizable ? 'minimized' : modal.state;
                return modal;
            });
        case 'maximize':
            return modals.map(modal => {
                modal.state =
                    modal.id === payload.modal.id && modal.options.maximizable ? 'maximized' : modal.state;
                return modal;
            });
        case 'dock':
            return modals.map(modal => {
                modal.state =
                    modal.id === payload.modal.id && modal.options.dockable ? 'docked' : 'minimized';
                return modal;
            });
        default:
            return modals;
    }
};
const WrappedModal = memo(({ Component, id, options: { alert, dismissible, dockable, minimizable, maximizable }, state, methods, props, top }) => (_jsx(ModalContext.Provider, { value: {
        id,
        alert,
        dismissible,
        minimizable,
        maximizable,
        dockable,
        state,
        top,
        initialized: true,
        ...methods
    }, children: _jsx(Component, { ...props }) })));
const RenderModals = ({ modals }) => {
    const { open, minimized, alerts } = modals.reduce((obj, modal) => {
        if (modal.options.alert)
            obj.alerts.push(modal);
        else if (modal.state === 'minimized' || modal.state === 'docked') {
            obj.minimized.push(modal);
        }
        else
            obj.open.push(modal);
        return obj;
    }, { open: [], minimized: [], alerts: [] });
    return (_jsxs(_Fragment, { children: [open.map((modal, i) => (_createElement(WrappedModal, { ...modal, top: alerts.length === 0 && i === open.length - 1, key: modal.id }))), minimized.length > 0 && (_jsx(DockedModals, { children: minimized.map(modal => (_createElement(WrappedModal, { ...modal, top: false, key: modal.id }))) })), alerts.map((modal, i) => (_createElement(WrappedModal, { ...modal, top: i === open.length - 1, key: modal.id })))] }));
};
const ModalManager = ({ children }) => {
    const [modals, dispatch] = useReducer(reducer, []);
    const { disableScroll, enableScroll } = useScrollToggle();
    const providerValue = useMemo(() => ({
        create: (Component, props, options) => {
            const id = options?.id || createUID();
            const initiatorRef = document.activeElement ? new WeakRef(document.activeElement) : null;
            const methods = {
                dismiss: () => {
                    dispatch({ action: 'dismiss', modal: { id } });
                    options?.onDismiss?.(id);
                    // cSpell:words deref
                    const initiator = initiatorRef?.deref();
                    if (initiator?.isConnected &&
                        (initiator instanceof HTMLElement || initiator instanceof SVGElement)) {
                        initiator.focus();
                    }
                },
                update: updateProps => {
                    dispatch({
                        action: 'update',
                        modal: { id, props: updateProps }
                    });
                },
                minimize: () => {
                    dispatch({ action: 'minimize', modal: { id } });
                    options?.onMinimize?.(id);
                },
                maximize: () => {
                    dispatch({ action: 'maximize', modal: { id } });
                    options?.onMaximize?.(id);
                },
                dock: () => {
                    dispatch({ action: 'dock', modal: { id } });
                    options?.onDock?.(id);
                },
                activate: () => {
                    dispatch({ action: 'activate', modal: { id } });
                    options?.onActivate?.(id);
                },
                unmount: () => {
                    dispatch({ action: 'unmount', modal: { id } });
                }
            };
            let defaultState;
            if (options?.defaultMinimized) {
                defaultState = 'minimized';
            }
            else if (options?.dockable) {
                defaultState = 'docked';
            }
            else {
                defaultState = 'open';
            }
            dispatch({
                action: 'create',
                modal: {
                    id,
                    methods,
                    Component,
                    props,
                    state: defaultState,
                    options: {
                        alert: false,
                        minimizable: false,
                        maximizable: false,
                        dockable: false,
                        defaultMinimized: false,
                        unmountWhenMinimized: true,
                        ...options,
                        dismissible: !!(options?.alert ? false : options?.dismissible ?? true)
                    }
                }
            });
            return methods;
        },
        ModalContext,
        initialized: true
    }), []);
    useEffect(() => {
        if (modals.some(modal => modal.state === 'open' && !modal.options.dockable)) {
            disableScroll();
        }
        else {
            enableScroll();
        }
    }, [modals]);
    const { portalTarget } = useConfiguration();
    const context = windowIsAvailable
        ? window.cosmos.modalManagerContext ?? ModalManagerContext
        : ModalManagerContext;
    const priorCtx = useContext(context);
    // Don't create additional Modal portals.
    if (priorCtx.initialized)
        return _jsx(context.Provider, { value: priorCtx, children: children });
    return (_jsxs(context.Provider, { value: providerValue, children: [children, modals.length > 0 &&
                portalTarget &&
                createPortal(_jsx(RenderModals, { modals: modals }), portalTarget)] }));
};
export default ModalManager;
//# sourceMappingURL=ModalManager.js.map