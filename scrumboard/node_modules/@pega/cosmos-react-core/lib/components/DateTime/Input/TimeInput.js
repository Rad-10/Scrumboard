import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { useRef, useState, forwardRef } from 'react';
import styled from 'styled-components';
import FormField from '../../FormField';
import Flex from '../../Flex';
import Select, { Option } from '../../Select';
import Button from '../../Button';
import Icon, { registerIcon } from '../../Icon';
import * as timesIcon from '../../Icon/icons/times.icon';
import * as clockIcon from '../../Icon/icons/clock.icon';
import Popover from '../../Popover';
import TimePicker from '../Picker/TimePicker';
import { useConfiguration, useConsolidatedRef, useFocusWithin, useI18n } from '../../../hooks';
import { StyledFormControl } from '../../FormControl';
import { sameWidth } from '../../Popover/modifiers';
import { getDateFormat, parseToDate, is12HClockFormat, validateTime, getTimeOptions } from './utils';
import StyledDateTime, { StyledInputContainer } from './DateTime.styles';
import PartInput from './PartInput';
import usePickerButton from './usePickerButton';
import useAutoFocusNextInput from './useAutoFocusNextInput';
registerIcon(timesIcon, clockIcon);
export const StyledTimeInput = styled(StyledDateTime) `
  padding-inline-end: 0;
`;
function getMeridiem(hour) {
    return hour >= 12 ? 'PM' : 'AM';
}
const convertTo12h = (hour) => {
    let converted = hour;
    if (hour > 12)
        converted = hour - 12;
    else if (hour === 0)
        converted = 12;
    return converted;
};
const convertTo24h = (hour, meridiem) => {
    let converted = hour;
    if (meridiem === 'PM' && hour < 12)
        converted = hour + 12;
    else if (meridiem === 'AM' && hour === 12)
        converted = 0;
    return converted;
};
const convertToCallbackParameter = (date, { hour, minute, second = date.getUTCSeconds().toString(), dayPeriod: meridiem }) => {
    if ([hour, minute, second].every(Boolean)) {
        const is12h = meridiem !== undefined;
        if (!validateTime(Number(hour), Number(minute), Number(second), is12h)) {
            return {
                valueAsISOString: '',
                valueAsTimestamp: NaN,
                state: 'invalid'
            };
        }
        const resultDate = new Date(date);
        resultDate.setUTCHours(is12h ? convertTo24h(Number(hour), meridiem) : Number(hour), Number(minute), Number(second));
        return {
            valueAsISOString: resultDate.toISOString(),
            valueAsTimestamp: resultDate.getTime()
        };
    }
    if ([hour, minute, second].every(p => !p)) {
        return {
            valueAsISOString: '',
            valueAsTimestamp: undefined
        };
    }
    return {
        valueAsISOString: '',
        valueAsTimestamp: NaN,
        state: 'incomplete'
    };
};
const TimeInput = forwardRef((props, ref) => {
    const { locale } = useConfiguration();
    const { defaultValue, value = defaultValue, id, label, labelHidden, status, withSeconds = false, pickerInterval = 30, clockFormat, info = getDateFormat(locale, getTimeOptions(withSeconds), true).join(''), required, readOnly, disabled, onChange, onFocus, onBlur, onResolveSuggestion, autoFocus, additionalInfo, ...restProps } = props;
    const date = value !== undefined ? parseToDate(value) : undefined;
    const is12h = clockFormat ? clockFormat === 12 : is12HClockFormat(locale);
    const [meridiem, setMeridiem] = useState(is12h ? () => (date ? getMeridiem(date.getUTCHours()) : 'AM') : undefined);
    const [hourInputRef, minuteInputRef, secondInputRef, meridiemSelectRef] = [
        useRef(null),
        useRef(null),
        useRef(null),
        useRef(null)
    ];
    useAutoFocusNextInput([hourInputRef, minuteInputRef, secondInputRef]);
    const pickParts = () => {
        const parts = {
            hour: hourInputRef.current?.value || undefined,
            minute: minuteInputRef.current?.value || undefined
        };
        if (withSeconds)
            parts.second = secondInputRef.current?.value;
        if (is12h)
            parts.dayPeriod = meridiemSelectRef.current?.value;
        return parts;
    };
    const currentlySelectedTime = () => {
        const parts = pickParts();
        if (Object.values(parts).every(Boolean)) {
            const hour = Number(parts.hour);
            const minute = Number(parts.minute);
            const second = parts.minute ? Number(parts.minute) : 0;
            const current = date ?? new Date();
            return validateTime(hour, minute, second, is12h)
                ? new Date(current.setUTCHours(is12h ? convertTo24h(hour, meridiem) : hour, minute, second))
                : undefined;
        }
    };
    const [open, setOpen, , setPopoverRef, buttonEl, setButtonEl] = usePickerButton();
    const inputContainerRef = useRef(null);
    const onFocusChange = (focused) => {
        const callbackParam = convertToCallbackParameter(date ? new Date(date) : new Date(), pickParts());
        if (onFocus && focused)
            onFocus(callbackParam);
        if (!focused) {
            if (inputContainerRef.current)
                inputContainerRef.current.scrollTop = 0;
            onBlur?.(callbackParam);
        }
    };
    const onInputChange = () => {
        onChange?.(convertToCallbackParameter(date ? new Date(date) : new Date(), pickParts()));
    };
    const t = useI18n();
    const displayNames = new Intl.DisplayNames(locale, { style: 'long', type: 'dateTimeField' });
    const hour = date && is12h ? convertTo12h(date.getUTCHours()) : date?.getUTCHours();
    const HourInput = (_jsx(PartInput, { placeholder: t('hour_placeholder'), "aria-label": displayNames.of('hour'), value: hour, onChange: onInputChange, size: 2, maxLength: 2, readOnly: readOnly, min: is12h ? 1 : 0, max: is12h ? 12 : 23, ref: hourInputRef, autoFocus: autoFocus }, 'hour'));
    const MinuteInput = (_jsx(PartInput, { placeholder: t('minute_placeholder'), "aria-label": displayNames.of('minute'), value: date?.getUTCMinutes(), onChange: onInputChange, size: 2, maxLength: 2, readOnly: readOnly, max: 59, ref: minuteInputRef }, 'minute'));
    const SecondInput = (_jsx(PartInput, { placeholder: t('second_placeholder'), "aria-label": displayNames.of('second'), value: date?.getUTCSeconds(), onChange: onInputChange, size: 2, maxLength: 2, readOnly: readOnly, max: 59, ref: secondInputRef }, 'second'));
    const Period = (_jsxs(Select, { ref: meridiemSelectRef, "aria-label": displayNames.of('dayPeriod'), value: meridiem, required: required, disabled: disabled, onChange: (e) => {
            setMeridiem(e.target.value);
            if (Object.values(pickParts()).every(Boolean))
                onInputChange();
        }, readOnly: readOnly, children: [_jsx(Option, { value: 'AM', children: t('meridiem_value_am') }), _jsx(Option, { value: 'PM', children: t('meridiem_value_pm') })] }, 'period'));
    const containerRef = useConsolidatedRef(ref);
    useFocusWithin([containerRef], onFocusChange);
    const Picker = (_jsxs(_Fragment, { children: [_jsx(Button, { variant: 'simple', icon: true, ref: setButtonEl, onClick: () => setOpen(cur => !cur), "aria-label": t(open ? 'close_time_button_a11y' : 'open_time_button_a11y'), readOnly: readOnly, disabled: disabled, children: _jsx(Icon, { name: open ? 'times' : 'clock' }) }), _jsx(Popover, { show: open, ref: setPopoverRef, target: containerRef.current, placement: 'bottom-end', strategy: 'fixed', modifiers: [
                    {
                        name: 'flip',
                        options: {
                            fallbackPlacements: ['top-end']
                        }
                    },
                    sameWidth
                ], children: _jsx(TimePicker, { selected: currentlySelectedTime(), interval: pickerInterval, onSelect: selected => {
                        hourInputRef.current.value = (is12h ? convertTo12h(selected.getUTCHours()) : selected.getUTCHours())
                            .toString()
                            .padStart(2, '0');
                        minuteInputRef.current.value = selected.getUTCMinutes().toString().padStart(2, '0');
                        if (withSeconds)
                            secondInputRef.current.value = selected
                                .getUTCSeconds()
                                .toString()
                                .padStart(2, '0');
                        if (meridiemSelectRef.current) {
                            meridiemSelectRef.current.value = getMeridiem(selected.getUTCHours());
                        }
                        setMeridiem(getMeridiem(selected.getUTCHours()));
                        setOpen(false);
                        setTimeout(() => buttonEl?.focus());
                        onInputChange();
                    }, clockFormat: clockFormat }) })] }));
    const Comp = (_jsxs(Flex, { as: StyledTimeInput, forwardedAs: StyledFormControl, hasSuggestion: status === 'pending' && !!onResolveSuggestion, container: { alignItems: 'center', wrap: 'nowrap' }, status: status, readOnly: readOnly, disabled: disabled, ref: containerRef, onClick: (e) => {
            if (e.target === containerRef.current)
                hourInputRef.current?.focus();
        }, ...restProps, children: [_jsx(Flex, { ref: inputContainerRef, as: StyledInputContainer, container: { alignItems: 'center', wrap: 'wrap' }, children: getDateFormat(locale, getTimeOptions(withSeconds, is12h)).map(part => {
                    switch (part) {
                        case 'hh':
                            return HourInput;
                        case 'mm':
                            return MinuteInput;
                        case 'ss':
                            return SecondInput;
                        case 'AM':
                        case 'PM':
                            return Period;
                        default:
                            return part;
                    }
                }) }), !readOnly && Picker] }));
    return label ? (_jsx(FormField, { as: 'fieldset', labelAs: 'legend', ...{
            label,
            labelHidden,
            id,
            info,
            status,
            required,
            disabled,
            onResolveSuggestion,
            additionalInfo
        }, ref: ref, children: Comp })) : (Comp);
});
export default TimeInput;
//# sourceMappingURL=TimeInput.js.map