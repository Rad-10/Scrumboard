import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import { forwardRef, useRef } from 'react';
import styled, { css } from 'styled-components';
import { defaultThemeProp } from '../../../theme';
import { useConfiguration, useConsolidatedRef, useFocusWithin, useI18n, useOuterEvent } from '../../../hooks';
import { cap } from '../../../utils';
import FormField from '../../FormField';
import Button from '../../Button';
import Icon, { registerIcon } from '../../Icon';
import * as timesIcon from '../../Icon/icons/times.icon';
import * as calendarIcon from '../../Icon/icons/calendar.icon';
import Flex from '../../Flex';
import { StyledFormControl } from '../../FormControl';
import DatePicker from '../Picker/DatePicker';
import Popover from '../../Popover';
import { parseToDate, getWeekYear, getWeek, generatePickerButtonAriaLabel, convertWeekYearToDate } from './utils';
import StyledDateTime, { BareInput, StyledInputContainer } from './DateTime.styles';
import usePickerButton from './usePickerButton';
import PartInput from './PartInput';
import useAutoFocusNextInput from './useAutoFocusNextInput';
registerIcon(timesIcon, calendarIcon);
export const StyledWeekInput = styled(StyledDateTime)(props => {
    const { theme: { base } } = props;
    return css `
    padding-inline-end: 0;

    ${StyledInputContainer} > ${BareInput}:first-of-type {
      margin-inline-start: ${base.spacing};
    }
  `;
});
StyledWeekInput.defaultProps = defaultThemeProp;
const convertToCallbackParameter = (date, parts) => {
    if ([parts.week, parts.year].every(Boolean)) {
        const { year, month, day } = convertWeekYearToDate(parts) ?? {};
        date.setUTCFullYear(Number(year), Number(month), Number(day));
        return {
            valueAsISOString: date.toISOString(),
            valueAsTimestamp: date.getTime()
        };
    }
    if ([parts.week, parts.year].every(p => !p)) {
        return {
            valueAsISOString: '',
            valueAsTimestamp: undefined
        };
    }
    return {
        valueAsISOString: '',
        valueAsTimestamp: NaN,
        state: 'incomplete'
    };
};
const WeekInput = forwardRef((props, ref) => {
    const { defaultValue, value = defaultValue, min, max, id, label, labelHidden, status, info, required, readOnly, disabled, onChange, onFocus, onBlur, autoFocus, additionalInfo, ...restProps } = props;
    const { locale } = useConfiguration();
    const t = useI18n();
    const containerRef = useConsolidatedRef(ref);
    const date = value !== undefined ? parseToDate(value) : undefined;
    const [weekInputRef, yearInputRef] = [
        useRef(null),
        useRef(null)
    ];
    useAutoFocusNextInput([weekInputRef, yearInputRef]);
    const pickParts = () => {
        return {
            week: weekInputRef.current?.value || undefined,
            year: yearInputRef.current?.value || undefined
        };
    };
    const currentlySelectedDate = () => {
        const dateParts = convertWeekYearToDate(pickParts());
        if (dateParts) {
            const year = Number(dateParts.year);
            const month = Number(dateParts.month);
            const day = Number(dateParts.day);
            const current = date ?? new Date();
            return new Date(current.setUTCFullYear(year ?? current.getUTCFullYear(), month ?? current.getUTCMonth(), day ?? current.getUTCDate()));
        }
    };
    const inputContainerRef = useRef(null);
    const onFocusChange = (focused) => {
        const callbackParam = convertToCallbackParameter(date ? new Date(date) : new Date(), pickParts());
        if (onFocus && focused)
            onFocus(callbackParam);
        if (!focused) {
            if (inputContainerRef.current)
                inputContainerRef.current.scrollTop = 0;
            onBlur?.(callbackParam);
        }
    };
    const [open, setOpen, , setPopoverRef, buttonEl, setButtonEl] = usePickerButton();
    const onInputChange = () => {
        onChange?.(convertToCallbackParameter(date ? new Date(date) : new Date(), pickParts()));
        buttonEl?.setAttribute('aria-label', generatePickerButtonAriaLabel(currentlySelectedDate(), 'week', locale, t, open));
    };
    // autoclose picker on focusing out
    useOuterEvent('focusin', [containerRef], e => {
        if (containerRef.current?.contains(e.relatedTarget))
            setOpen(false);
    });
    const displayNames = new Intl.DisplayNames(locale, {
        style: 'long',
        type: 'dateTimeField'
    });
    const WeekNumberInput = (_jsx(PartInput, { placeholder: t('week_placeholder'), "aria-label": displayNames.of('weekOfYear'), value: date ? getWeek(date) : undefined, onChange: onInputChange, size: 2, maxLength: 2, min: 1, max: 53, readOnly: readOnly, ref: weekInputRef, autoFocus: autoFocus }, 'week'));
    const YearInput = (_jsx(PartInput, { placeholder: t('year_placeholder'), "aria-label": displayNames.of('year'), value: date ? getWeekYear(date) : undefined, onChange: onInputChange, size: 4, maxLength: 4, min: 1, readOnly: readOnly, ref: yearInputRef }, 'year'));
    useFocusWithin([containerRef], onFocusChange);
    const Picker = (_jsxs(_Fragment, { children: [_jsx(Button, { variant: 'simple', icon: true, ref: setButtonEl, onClick: () => setOpen(cur => !cur), "aria-label": generatePickerButtonAriaLabel(currentlySelectedDate(), 'week', locale, t, open), readOnly: readOnly, disabled: disabled, children: _jsx(Icon, { name: open ? 'times' : 'calendar' }) }), open && (_jsx(Popover, { ref: setPopoverRef, target: buttonEl, strategy: 'fixed', placement: 'bottom-end', modifiers: [
                    {
                        name: 'flip',
                        options: {
                            fallbackPlacements: ['top-end', 'right', 'left']
                        }
                    }
                ], children: _jsx(DatePicker, { selected: currentlySelectedDate(), onChange: selected => {
                        weekInputRef.current.value =
                            (selected && getWeek(selected).toString().padStart(2, '0')) || '';
                        yearInputRef.current.value = (selected && getWeekYear(selected).toString()) || '';
                        setOpen(false);
                        setTimeout(() => buttonEl?.focus());
                        onInputChange();
                    }, min: min, max: max, mode: 'week' }) }))] }));
    const Comp = (_jsxs(Flex, { as: StyledWeekInput, forwardedAs: StyledFormControl, container: { alignItems: 'center', wrap: 'nowrap' }, status: status, readOnly: readOnly, disabled: disabled, ref: containerRef, onClick: (e) => {
            if (e.target === containerRef.current)
                weekInputRef.current?.focus();
        }, ...restProps, children: [_jsxs(Flex, { ref: inputContainerRef, as: StyledInputContainer, container: { alignItems: 'center', wrap: 'wrap' }, children: [cap(displayNames.of('weekOfYear')), " ", WeekNumberInput, ",", YearInput] }), !readOnly && Picker] }));
    return label ? (_jsx(FormField, { as: 'fieldset', labelAs: 'legend', ...{ label, labelHidden, id, info, status, required, disabled, additionalInfo }, ref: ref, children: Comp })) : (Comp);
});
export default WeekInput;
//# sourceMappingURL=WeekInput.js.map