import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { forwardRef, useEffect, useRef, useState } from 'react';
import styled from 'styled-components';
import { hasProp } from '@pega/cosmos-react-core/lib/utils';
import { defaultThemeProp } from '../../../theme';
import { StyledFormControl } from '../../FormControl';
import FormField from '../../FormField';
import { useConfiguration, useConsolidatedRef, useFocusWithin, useI18n, useOuterEvent } from '../../../hooks';
import Select, { Option } from '../../Select';
import Flex from '../../Flex';
import Button from '../../Button';
import Icon, { registerIcon } from '../../Icon';
import * as timesIcon from '../../Icon/icons/times.icon';
import * as calendarIcon from '../../Icon/icons/calendar.icon';
import Popover from '../../Popover';
import DatePicker from '../Picker/DatePicker';
import StyledDateTime, { StyledInputContainer } from './DateTime.styles';
import { generatePickerButtonAriaLabel, getDateFormat, getTimeOptions, is12HClockFormat, parsePastedTextToDate, parseToDate, validateDate, validateTime } from './utils';
import TimeInput from './TimeInput';
import useAutoFocusNextInput from './useAutoFocusNextInput';
import PartInput from './PartInput';
import usePickerButton from './usePickerButton';
registerIcon(timesIcon, calendarIcon);
export const StyledDateTimeInput = styled(StyledDateTime) `
  padding-inline-end: 0;
  min-width: 0;
`;
StyledDateTimeInput.defaultProps = defaultThemeProp;
const StyledDateTimeFieldset = styled.fieldset `
  min-width: 0;
`;
function getMeridiem(hour) {
    return hour >= 12 ? 'PM' : 'AM';
}
const convertTo12h = (hour) => {
    let converted = hour;
    if (hour > 12)
        converted = hour - 12;
    else if (hour === 0)
        converted = 12;
    return converted;
};
const convertTo24h = (hour, meridiem) => {
    let converted = hour;
    if (meridiem === 'PM' && hour < 12)
        converted = hour + 12;
    else if (meridiem === 'AM' && hour === 12)
        converted = 0;
    return converted;
};
function validateDateTimeState(year, month, day, hour, minute, second, is12h) {
    return validateDate(year, month, day) && validateTime(hour, minute, second, is12h);
}
const convertToCallbackParameter = (date, parts) => {
    const withSeconds = hasProp(parts, 'second');
    const { year, month: monthIndex, day, hour, minute, second = date.getUTCSeconds().toString(), dayPeriod: meridiem } = parts;
    const toValidate = withSeconds
        ? [year, monthIndex, day, hour, minute, second]
        : [year, monthIndex, day, hour, minute];
    if (toValidate.every(Boolean)) {
        const is12h = meridiem !== undefined;
        if (!validateDateTimeState(Number(year), Number(monthIndex) + 1, Number(day), Number(hour), Number(minute), Number(second), is12h)) {
            return {
                valueAsISOString: '',
                valueAsTimestamp: NaN,
                state: 'invalid'
            };
        }
        const resultDate = new Date(date);
        resultDate.setUTCFullYear(Number(year), Number(monthIndex), Number(day));
        resultDate.setUTCHours(is12h ? convertTo24h(Number(hour), meridiem) : Number(hour), Number(minute), Number(second));
        return {
            valueAsISOString: resultDate.toISOString(),
            valueAsTimestamp: resultDate.getTime()
        };
    }
    if (toValidate.every(p => !p)) {
        return {
            valueAsISOString: '',
            valueAsTimestamp: undefined
        };
    }
    return {
        valueAsISOString: '',
        valueAsTimestamp: NaN,
        state: 'incomplete'
    };
};
function dateOptions() {
    return {
        year: 'numeric',
        month: 'numeric',
        day: 'numeric'
    };
}
const DateTimeInput = forwardRef((props, ref) => {
    const { locale } = useConfiguration();
    const { defaultValue, value = defaultValue, min, max, id, label, labelHidden, withSeconds = false, clockFormat, info = `${getDateFormat(locale).join('')} ${getDateFormat(locale, getTimeOptions(withSeconds), true).join('')}`, status, required, readOnly, disabled, showWeekNumber, pickerInterval = 30, onChange, onFocus, onBlur, onResolveSuggestion, additionalInfo, autoFocus, ...restProps } = props;
    const t = useI18n();
    const containerRef = useConsolidatedRef(ref);
    const dateTime = value !== undefined ? parseToDate(value) : undefined;
    const is12h = clockFormat ? clockFormat === 12 : is12HClockFormat(locale);
    const [meridiem, setMeridiem] = useState(is12h ? () => (dateTime ? getMeridiem(dateTime.getUTCHours()) : 'AM') : undefined);
    const newMeridiem = dateTime ? getMeridiem(dateTime.getUTCHours()) : 'AM';
    useEffect(() => {
        setMeridiem(newMeridiem);
    }, [newMeridiem]);
    const [yearInputRef, monthInputRef, dayInputRef, hourInputRef, minuteInputRef, secondInputRef, meridiemSelectRef] = [
        useRef(null),
        useRef(null),
        useRef(null),
        useRef(null),
        useRef(null),
        useRef(null),
        useRef(null)
    ];
    useAutoFocusNextInput([
        yearInputRef,
        monthInputRef,
        dayInputRef,
        hourInputRef,
        minuteInputRef,
        secondInputRef
    ]);
    const pickDateParts = () => {
        return {
            day: dayInputRef.current?.value || undefined,
            month: monthInputRef.current?.value
                ? (Number(monthInputRef.current.value) - 1).toString()
                : undefined,
            year: yearInputRef.current?.value || undefined
        };
    };
    const pickTimeParts = () => {
        const parts = {
            hour: hourInputRef.current?.value || undefined,
            minute: minuteInputRef.current?.value || undefined
        };
        if (withSeconds)
            parts.second = secondInputRef.current?.value;
        if (is12h)
            parts.dayPeriod = meridiemSelectRef.current?.value;
        return parts;
    };
    const pickParts = () => {
        return { ...pickDateParts(), ...pickTimeParts() };
    };
    const currentlySelectedDate = () => {
        const parts = pickDateParts();
        if (Object.values(parts).every(Boolean)) {
            const year = Number(parts.year);
            const month = Number(parts.month);
            const day = Number(parts.day);
            return validateDate(year, month + 1, day)
                ? new Date(Date.UTC(year, month, day))
                : undefined;
        }
    };
    const currentlySelectedTime = () => {
        const parts = pickParts();
        if (Object.values(parts).every(Boolean)) {
            const hour = Number(parts.hour);
            const minute = Number(parts.minute);
            const second = parts.second ? Number(parts.second) : 0;
            const current = dateTime ?? new Date();
            return validateTime(hour, minute, second, is12h)
                ? new Date(current.setUTCHours(is12h ? convertTo24h(hour, parts.dayPeriod) : hour, minute, second))
                : undefined;
        }
    };
    const currentlySelectedDateTime = () => {
        const selectedDate = currentlySelectedDate();
        const selectedTime = currentlySelectedTime();
        return selectedDate && selectedTime
            ? new Date(selectedDate.setUTCHours(selectedTime.getUTCHours(), selectedTime.getUTCMinutes(), selectedTime.getUTCSeconds()))
            : undefined;
    };
    const setDefaultTimeIfEmpty = () => {
        // set value to midnight if time empty, skip if date not fully set
        if (Object.values(pickDateParts()).every(Boolean) &&
            Object.values(pickTimeParts()).every(p => !p)) {
            if (hourInputRef.current)
                hourInputRef.current.value = is12h ? '12' : '00';
            if (minuteInputRef.current)
                minuteInputRef.current.value = '00';
            if (withSeconds && secondInputRef.current)
                secondInputRef.current.value = '00';
            if (is12h && meridiemSelectRef.current) {
                meridiemSelectRef.current.value = 'AM';
                setMeridiem('AM');
            }
        }
    };
    const [open, setOpen, , setPopoverRef, buttonEl, setButtonEl] = usePickerButton(setDefaultTimeIfEmpty);
    const onInputChange = () => {
        onChange?.(convertToCallbackParameter(dateTime ? new Date(dateTime) : new Date(), pickParts()));
        buttonEl?.setAttribute('aria-label', generatePickerButtonAriaLabel(currentlySelectedDateTime(), 'datetime', locale, t, open));
    };
    const setInputValue = (newValue) => {
        dayInputRef.current.value = newValue.getUTCDate().toString().padStart(2, '0');
        monthInputRef.current.value = (newValue.getUTCMonth() + 1).toString().padStart(2, '0');
        yearInputRef.current.value = newValue.getUTCFullYear().toString();
        const hours = newValue.getUTCHours();
        hourInputRef.current.value = (is12h ? convertTo12h(hours) : hours)
            .toString()
            .padStart(2, '0');
        minuteInputRef.current.value = newValue.getUTCMinutes().toString().padStart(2, '0');
        if (withSeconds) {
            secondInputRef.current.value = newValue.getUTCSeconds().toString().padStart(2, '0');
        }
        if (meridiemSelectRef.current) {
            meridiemSelectRef.current.value = newValue ? getMeridiem(newValue.getUTCHours()) : 'AM';
        }
        setMeridiem(newValue ? getMeridiem(newValue.getUTCHours()) : 'AM');
    };
    const onPaste = (e) => {
        const text = e.clipboardData.getData('text');
        const date = parsePastedTextToDate(text, locale, dateTime || new Date());
        if (date) {
            e.preventDefault();
            setInputValue(date);
            onInputChange();
        }
    };
    const inputContainerRef = useRef(null);
    const onFocusChange = (focused) => {
        const callbackParam = convertToCallbackParameter(dateTime ? new Date(dateTime) : new Date(), pickParts());
        if (onFocus && focused)
            onFocus(callbackParam);
        if (!focused) {
            if (inputContainerRef.current)
                inputContainerRef.current.scrollTop = 0;
            onBlur?.(callbackParam);
        }
    };
    // autoclose picker on focusing out
    useOuterEvent('focusin', [containerRef], e => {
        if (containerRef.current?.contains(e.relatedTarget))
            setOpen(false);
    });
    const displayNames = new Intl.DisplayNames(locale, { style: 'long', type: 'dateTimeField' });
    const DayInput = (_jsx(PartInput, { placeholder: t('day_placeholder'), "aria-label": displayNames.of('day'), value: dateTime?.getUTCDate(), onChange: onInputChange, size: 2, maxLength: 2, readOnly: readOnly, min: 1, max: 31, ref: dayInputRef }, 'day'));
    const MonthInput = (_jsx(PartInput, { placeholder: t('month_placeholder'), "aria-label": displayNames.of('month'), value: dateTime ? dateTime.getUTCMonth() + 1 : undefined, onChange: onInputChange, size: 2, maxLength: 2, readOnly: readOnly, min: 1, max: 12, ref: monthInputRef }, 'month'));
    const YearInput = (_jsx(PartInput, { placeholder: t('year_placeholder'), "aria-label": displayNames.of('year'), value: dateTime?.getUTCFullYear(), onChange: onInputChange, size: 4, maxLength: 4, padWithZeros: false, readOnly: readOnly, min: 1, ref: yearInputRef }, 'year'));
    const hour = dateTime && is12h ? convertTo12h(dateTime.getUTCHours()) : dateTime?.getUTCHours();
    const HourInput = (_jsx(PartInput, { placeholder: t('hour_placeholder'), "aria-label": displayNames.of('hour'), value: hour, onChange: onInputChange, size: 2, maxLength: 2, readOnly: readOnly, min: is12h ? 1 : 0, max: is12h ? 12 : 23, ref: hourInputRef }, 'hour'));
    const MinuteInput = (_jsx(PartInput, { placeholder: t('minute_placeholder'), "aria-label": displayNames.of('minute'), value: dateTime?.getUTCMinutes(), onChange: onInputChange, size: 2, maxLength: 2, readOnly: readOnly, max: 59, ref: minuteInputRef }, 'minute'));
    const SecondInput = (_jsx(PartInput, { placeholder: t('second_placeholder'), "aria-label": displayNames.of('second'), value: dateTime?.getUTCSeconds(), onChange: onInputChange, size: 2, maxLength: 2, readOnly: readOnly, max: 59, ref: secondInputRef }, 'second'));
    const Period = (_jsxs(Select, { ref: meridiemSelectRef, "aria-label": displayNames.of('dayPeriod'), value: meridiem, required: required, disabled: disabled, onChange: (e) => {
            setMeridiem(e.target.value);
            if (Object.values(pickParts()).every(Boolean))
                onInputChange();
        }, readOnly: readOnly, children: [_jsx(Option, { value: 'AM', children: t('meridiem_value_am') }), _jsx(Option, { value: 'PM', children: t('meridiem_value_pm') })] }, 'period'));
    const orderedRefs = [];
    const dateInputs = getDateFormat(locale, dateOptions()).map(part => {
        switch (part) {
            case 'DD':
                orderedRefs.push(dayInputRef);
                return DayInput;
            case 'MM':
                orderedRefs.push(monthInputRef);
                return MonthInput;
            case 'YYYY':
                orderedRefs.push(yearInputRef);
                return YearInput;
            default:
                return part;
        }
    });
    const timeInputs = getDateFormat(locale, getTimeOptions(withSeconds, is12h)).map(part => {
        switch (part) {
            case 'hh':
                orderedRefs.push(hourInputRef);
                return HourInput;
            case 'mm':
                orderedRefs.push(minuteInputRef);
                return MinuteInput;
            case 'ss':
                orderedRefs.push(secondInputRef);
                return SecondInput;
            case 'AM':
            case 'PM':
                return Period;
            default:
                return part;
        }
    });
    useEffect(() => {
        if (autoFocus)
            orderedRefs[0].current?.focus();
    }, [autoFocus]);
    useFocusWithin([containerRef], onFocusChange);
    const [timeInputStatus, setTimeInputStatus] = useState();
    const Picker = (_jsxs(_Fragment, { children: [_jsx(Button, { variant: 'simple', icon: true, ref: setButtonEl, onClick: () => {
                    setTimeInputStatus(undefined);
                    setOpen(cur => !cur);
                }, "aria-label": generatePickerButtonAriaLabel(currentlySelectedDateTime(), 'datetime', locale, t, open), readOnly: readOnly, disabled: disabled, children: _jsx(Icon, { name: open ? 'times' : 'calendar' }) }), open && (_jsxs(Popover, { ref: setPopoverRef, target: buttonEl, placement: 'bottom-end', strategy: 'fixed', modifiers: [
                    {
                        name: 'flip',
                        options: {
                            fallbackPlacements: ['top-end', 'right', 'left']
                        }
                    }
                ], children: [_jsx(DatePicker, { selected: currentlySelectedDate(), onChange: selected => {
                            dayInputRef.current.value = selected.getUTCDate().toString().padStart(2, '0');
                            monthInputRef.current.value = (selected.getUTCMonth() + 1)
                                .toString()
                                .padStart(2, '0');
                            yearInputRef.current.value = selected.getUTCFullYear().toString();
                            onInputChange();
                        }, min: min, max: max, showWeekNumber: showWeekNumber }), _jsx(TimeInput, { label: t('time_text'), pickerInterval: pickerInterval, value: currentlySelectedTime(), withSeconds: withSeconds, clockFormat: clockFormat, status: timeInputStatus, onChange: selected => {
                            if (Number.isNaN(selected.valueAsTimestamp)) {
                                if (selected.state !== 'incomplete') {
                                    setTimeInputStatus('warning');
                                }
                                return;
                            }
                            setTimeInputStatus(undefined);
                            const selectedDate = selected.valueAsTimestamp
                                ? new Date(selected.valueAsTimestamp)
                                : undefined;
                            hourInputRef.current.value = selectedDate
                                ? (is12h ? convertTo12h(selectedDate.getUTCHours()) : selectedDate.getUTCHours())
                                    .toString()
                                    .padStart(2, '0')
                                : '';
                            minuteInputRef.current.value = selectedDate
                                ? selectedDate.getUTCMinutes().toString().padStart(2, '0')
                                : '';
                            if (withSeconds)
                                secondInputRef.current.value = selectedDate
                                    ? selectedDate.getUTCSeconds().toString().padStart(2, '0')
                                    : '';
                            if (selectedDate) {
                                if (meridiemSelectRef.current) {
                                    meridiemSelectRef.current.value = getMeridiem(selectedDate.getUTCHours());
                                }
                                setMeridiem(getMeridiem(selectedDate.getUTCHours()));
                            }
                            onInputChange();
                        }, onBlur: selected => {
                            if (Number.isNaN(selected.valueAsTimestamp))
                                setTimeInputStatus('warning');
                            else
                                setTimeInputStatus(undefined);
                        } })] }))] }));
    const Comp = (_jsxs(Flex, { as: StyledDateTimeInput, forwardedAs: StyledFormControl, hasSuggestion: status === 'pending' && !!onResolveSuggestion, container: { alignItems: 'center', wrap: 'nowrap' }, status: status, readOnly: readOnly, disabled: disabled, ref: containerRef, onClick: (e) => {
            if (e.target === containerRef.current)
                orderedRefs[0].current?.focus();
        }, ...restProps, children: [_jsxs(Flex, { ref: inputContainerRef, as: StyledInputContainer, container: { alignItems: 'center', wrap: 'wrap' }, onPaste: onPaste, children: [dateInputs, timeInputs] }), !readOnly && Picker] }));
    useAutoFocusNextInput(orderedRefs);
    return label ? (_jsx(FormField, { as: StyledDateTimeFieldset, labelAs: 'legend', "aria-labelledby": id, ref: ref, ...{
            label,
            labelHidden,
            id,
            info,
            status,
            required,
            disabled,
            onResolveSuggestion,
            additionalInfo
        }, children: Comp })) : (Comp);
});
export default DateTimeInput;
//# sourceMappingURL=DateTimeInput.js.map