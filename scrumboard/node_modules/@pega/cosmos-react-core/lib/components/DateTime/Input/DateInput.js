import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import { forwardRef, useRef, useImperativeHandle, useEffect } from 'react';
import styled from 'styled-components';
import { defaultThemeProp } from '../../../theme';
import { useConfiguration, useFocusWithin, useI18n, useOuterEvent } from '../../../hooks';
import FormField from '../../FormField';
import Flex from '../../Flex';
import Button from '../../Button';
import Icon, { registerIcon } from '../../Icon';
import * as timesIcon from '../../Icon/icons/times.icon';
import * as calendarIcon from '../../Icon/icons/calendar.icon';
import DatePicker from '../Picker/DatePicker';
import Popover from '../../Popover';
import { StyledFormControl } from '../../FormControl';
import { getDateFormat, parsePastedTextToDate, parseToDate, validateDate, generatePickerButtonAriaLabel } from './utils';
import StyledDateTime, { StyledInputContainer } from './DateTime.styles';
import useAutoFocusNextInput from './useAutoFocusNextInput';
import PartInput from './PartInput';
import usePickerButton from './usePickerButton';
registerIcon(timesIcon, calendarIcon);
export const StyledDateInput = styled(StyledDateTime) `
  padding-inline-end: 0;
`;
StyledDateInput.defaultProps = defaultThemeProp;
const convertToCallbackParameter = (date, { year, month: monthIndex, day }) => {
    if ([year, monthIndex, day].every(Boolean)) {
        if (!validateDate(Number(year), Number(monthIndex) + 1, Number(day))) {
            return {
                valueAsISOString: '',
                valueAsTimestamp: NaN,
                state: 'invalid'
            };
        }
        date.setUTCFullYear(Number(year), Number(monthIndex), Number(day));
        return {
            valueAsISOString: date.toISOString(),
            valueAsTimestamp: date.getTime()
        };
    }
    if ([year, monthIndex, day].every(p => !p)) {
        return {
            valueAsISOString: '',
            valueAsTimestamp: undefined
        };
    }
    return {
        valueAsISOString: '',
        valueAsTimestamp: NaN,
        state: 'incomplete'
    };
};
const DateInput = forwardRef((props, ref) => {
    const { locale } = useConfiguration();
    const { defaultValue, value = defaultValue, min, max, id, label, labelHidden, info = getDateFormat(locale).join(''), status, required, readOnly, disabled, onChange, onFocus, onBlur, onResolveSuggestion, showWeekNumber, picker: { renderer: PickerComp = DatePicker, rendererProps = {} } = {}, autoFocus, additionalInfo, ...restProps } = props;
    const t = useI18n();
    const containerRef = useRef(null);
    const date = value !== undefined ? parseToDate(value) : undefined;
    const [yearInputRef, monthInputRef, dayInputRef] = [
        useRef(null),
        useRef(null),
        useRef(null)
    ];
    const pickParts = () => {
        return {
            day: dayInputRef.current?.value || undefined,
            month: monthInputRef.current?.value
                ? (Number(monthInputRef.current.value) - 1).toString()
                : undefined,
            year: yearInputRef.current?.value || undefined
        };
    };
    const currentlySelectedDate = () => {
        const parts = pickParts();
        if (Object.values(parts).every(Boolean)) {
            const year = Number(parts.year);
            const monthIndex = Number(parts.month);
            const day = Number(parts.day);
            return validateDate(year, monthIndex + 1, day)
                ? new Date(Date.UTC(year, monthIndex, day))
                : undefined;
        }
    };
    const [open, setOpen, , setPopoverRef, buttonEl, setButtonEl] = usePickerButton();
    const inputContainerRef = useRef(null);
    const onFocusChange = (focused) => {
        const callbackParam = convertToCallbackParameter(date ? new Date(date) : new Date(), pickParts());
        if (onFocus && focused)
            onFocus(callbackParam);
        if (!focused) {
            if (inputContainerRef.current)
                inputContainerRef.current.scrollTop = 0;
            onBlur?.(callbackParam);
        }
    };
    const onInputChange = () => {
        onChange?.(convertToCallbackParameter(date ? new Date(date) : new Date(), pickParts()));
        buttonEl?.setAttribute('aria-label', generatePickerButtonAriaLabel(currentlySelectedDate(), 'date', locale, t, open));
    };
    const setInputValue = (newValue) => {
        if (dayInputRef.current && monthInputRef.current && yearInputRef.current) {
            dayInputRef.current.value = newValue?.getUTCDate().toString().padStart(2, '0') ?? '';
            monthInputRef.current.value =
                (newValue && (newValue?.getUTCMonth() + 1).toString().padStart(2, '0')) ?? '';
            yearInputRef.current.value = newValue?.getUTCFullYear().toString() ?? '';
        }
    };
    const onPaste = (e) => {
        const text = e.clipboardData.getData('text');
        const newDate = parsePastedTextToDate(text, locale, date || new Date());
        if (newDate) {
            e.preventDefault();
            setInputValue(newDate);
            onInputChange();
        }
    };
    // autoclose picker on focusing out
    useOuterEvent('focusin', [containerRef], e => {
        if (containerRef.current?.contains(e.relatedTarget))
            setOpen(false);
    });
    const displayNames = new Intl.DisplayNames(locale, { style: 'long', type: 'dateTimeField' });
    const DayInput = (_jsx(PartInput, { placeholder: t('day_placeholder'), "aria-label": displayNames.of('day'), value: date?.getUTCDate(), onChange: onInputChange, size: 2, maxLength: 2, readOnly: readOnly, min: 1, max: 31, ref: dayInputRef }, 'day'));
    const MonthInput = (_jsx(PartInput, { placeholder: t('month_placeholder'), "aria-label": displayNames.of('month'), value: date ? date?.getUTCMonth() + 1 : undefined, onChange: onInputChange, size: 2, maxLength: 2, readOnly: readOnly, min: 1, max: 12, ref: monthInputRef }, 'month'));
    const YearInput = (_jsx(PartInput, { placeholder: t('year_placeholder'), "aria-label": displayNames.of('year'), value: date?.getUTCFullYear(), onChange: onInputChange, size: 4, maxLength: 4, padWithZeros: false, readOnly: readOnly, min: 1, ref: yearInputRef }, 'year'));
    useFocusWithin([containerRef], onFocusChange);
    useImperativeHandle(ref, () => ({
        setOpen,
        buttonEl,
        get value() {
            return currentlySelectedDate();
        }
    }));
    const PickerButton = (_jsxs(_Fragment, { children: [_jsx(Button, { variant: 'simple', icon: true, ref: setButtonEl, onClick: () => setOpen(cur => !cur), "aria-label": generatePickerButtonAriaLabel(currentlySelectedDate(), 'date', locale, t, open), readOnly: readOnly, disabled: disabled, children: _jsx(Icon, { name: open ? 'times' : 'calendar' }) }), open && (_jsx(Popover, { ref: setPopoverRef, target: buttonEl, placement: 'bottom-end', strategy: 'fixed', modifiers: [
                    {
                        name: 'flip',
                        options: {
                            fallbackPlacements: ['top-end', 'right', 'left']
                        }
                    }
                ], children: _jsx(PickerComp, { selected: currentlySelectedDate(), min: min, max: max, showWeekNumber: showWeekNumber, ...rendererProps, onChange: selected => {
                        setInputValue(selected);
                        setOpen(false);
                        setTimeout(() => buttonEl?.focus());
                        onInputChange();
                        rendererProps?.onChange?.(selected);
                    } }) }))] }));
    const orderedRefs = [];
    const Comp = (_jsxs(Flex, { as: StyledDateInput, forwardedAs: StyledFormControl, hasSuggestion: status === 'pending' && !!onResolveSuggestion, container: { alignItems: 'center', wrap: 'nowrap' }, status: status, readOnly: readOnly, disabled: disabled, ref: containerRef, onClick: (e) => {
            if (e.target === containerRef.current)
                orderedRefs[0].current?.focus();
        }, ...restProps, children: [_jsx(Flex, { ref: inputContainerRef, as: StyledInputContainer, container: { alignItems: 'center', wrap: 'wrap' }, onPaste: onPaste, children: getDateFormat(locale).map(part => {
                    switch (part) {
                        case 'DD':
                            orderedRefs.push(dayInputRef);
                            return DayInput;
                        case 'MM':
                            orderedRefs.push(monthInputRef);
                            return MonthInput;
                        case 'YYYY':
                            orderedRefs.push(yearInputRef);
                            return YearInput;
                        default:
                            return part;
                    }
                }) }), !readOnly && PickerButton] }));
    useEffect(() => {
        if (autoFocus)
            orderedRefs[0].current?.focus();
    }, [autoFocus]);
    useAutoFocusNextInput(orderedRefs);
    return label ? (_jsx(FormField, { as: 'fieldset', "aria-labelledby": id, labelAs: 'legend', ...{
            label,
            labelHidden,
            id,
            info,
            status,
            required,
            disabled,
            onResolveSuggestion,
            additionalInfo
        }, ref: ref, children: Comp })) : (Comp);
});
export default DateInput;
//# sourceMappingURL=DateInput.js.map