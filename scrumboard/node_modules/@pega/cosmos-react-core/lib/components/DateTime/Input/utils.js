import { cap } from '../../../utils';
import { CALENDAR_TYPES, CALENDAR_TYPE_LOCALES } from './local';
// https://weeknumber.net/how-to/javascript
export const getWeekYear = (date) => {
    const result = new Date(date.getTime());
    result.setUTCDate(result.getUTCDate() + 3 - ((result.getUTCDay() + 6) % 7));
    return result.getUTCFullYear();
};
export const getDayOfWeek = (date, calendarType = CALENDAR_TYPES.ISO_8601) => {
    const weekday = date.getUTCDay();
    switch (calendarType) {
        case CALENDAR_TYPES.ISO_8601:
            // Shifts days of the week so that Monday is 0, Sunday is 6
            return (weekday + 6) % 7;
        case CALENDAR_TYPES.ARABIC:
            return (weekday + 1) % 7;
        case CALENDAR_TYPES.HEBREW:
        case CALENDAR_TYPES.US:
            return weekday;
        default:
            throw new Error('Unsupported calendar type.');
    }
};
export const getWeekdays = (calendarType) => {
    const date = new Date();
    const beginOfMonth = new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), 1));
    const year = beginOfMonth.getUTCFullYear();
    const monthIndex = beginOfMonth.getUTCMonth();
    return Array.from({ length: 7 }, (v, weekDay) => {
        return new Date(year, monthIndex, weekDay + 1 - getDayOfWeek(beginOfMonth, calendarType));
    });
};
const getDateWithCorrectYear = (initialDate, year) => {
    const dateObj = new Date(initialDate);
    // 2 digits years are converted to 19XX by Date constructors
    // setting year value directly to ensure it is correct
    if (!Number.isNaN(dateObj.getTime()) && year < 100)
        dateObj.setUTCFullYear(year);
    return dateObj;
};
// https://weeknumber.net/how-to/javascript
export const getWeek = (date, calendarType = CALENDAR_TYPES.ISO_8601) => {
    const result = new Date(date.getTime());
    result.setUTCHours(0, 0, 0, 0);
    // Thursday in current week decides the year.
    result.setUTCDate(result.getUTCDate() + 3 - getDayOfWeek(result, calendarType));
    // January 4 is always in week 1.
    const week1 = getDateWithCorrectYear(new Date(result.getUTCFullYear(), 0, 4), result.getUTCFullYear());
    // Adjust to Thursday in week 1 and count number of weeks from date to week1.
    return (1 +
        Math.round(((result.getTime() - week1.getTime()) / 86400000 - 3 + getDayOfWeek(result, calendarType)) / 7));
};
export const getCalendarTypeFromLocale = (localeTag) => {
    const calendarType = Object.keys(CALENDAR_TYPE_LOCALES).find(type => CALENDAR_TYPE_LOCALES[type].includes(localeTag ?? navigator.language));
    return calendarType || CALENDAR_TYPES.ISO_8601;
};
export const getDateOfISOWeek = (week, year) => {
    const dateOfWeek = getDateWithCorrectYear(Date.UTC(year, 0, 1 + (week - 1) * 7), year);
    const dayOfWeek = dateOfWeek.getUTCDay();
    const weekStartISO = dateOfWeek;
    if (dayOfWeek <= 4)
        weekStartISO.setUTCDate(dateOfWeek.getUTCDate() - dayOfWeek + 1);
    else
        weekStartISO.setUTCDate(dateOfWeek.getUTCDate() + 8 - dayOfWeek);
    return weekStartISO;
};
const timeRegex = /^T?\d{2}:\d{2}/;
export const parseToDate = (value) => {
    let result = new Date(value);
    if (typeof value === 'string') {
        let [year, month, day, hour, minute, second] = [1970, 1, 1, 0, 0, 0];
        if (timeRegex.test(value)) {
            [hour, minute, second = 0] = value
                .toString()
                .slice(Number(value.startsWith('T')))
                .split(/[.:/]/)
                .map(Number);
        }
        else {
            [year, month, day = 0, hour = 0, minute = 0, second = 0] = value
                .toString()
                .split(/[.: T+-]/)
                .map(Number);
        }
        result = getDateWithCorrectYear(Date.UTC(year, month - 1, day, hour, minute, second), year);
    }
    else if (typeof value === 'number') {
        result = new Date(value);
    }
    return result;
};
export function getQuarter(date) {
    const parsedDate = parseToDate(date);
    const quarter = [1, 2, 3, 4];
    return quarter[Math.floor(parsedDate.getUTCMonth() / 3)];
}
export const getDateFormat = (localeTag, options, labelFormat) => {
    return new Intl.DateTimeFormat(localeTag, options).formatToParts().map(({ type, value }) => {
        switch (type) {
            case 'day':
                return 'DD';
            case 'month':
                return 'MM';
            case 'year':
                return 'YYYY';
            case 'hour':
                return 'hh';
            case 'minute':
                return 'mm';
            case 'second':
                return 'ss';
            case 'dayPeriod':
                if (labelFormat)
                    return '';
                return value;
            case 'literal':
                return value;
            default:
                return '';
        }
    });
};
export const getStartOfWeek = (date, calendarType = CALENDAR_TYPES.ISO_8601) => {
    const startDate = new Date(date);
    const day = getDayOfWeek(startDate, calendarType);
    if (day !== 0)
        startDate.setUTCHours(-24 * day);
    return startDate;
};
export const getEndOfWeek = (date, calendarType = CALENDAR_TYPES.ISO_8601) => {
    const endDate = new Date(date);
    const day = getDayOfWeek(endDate, calendarType);
    if (day !== 6)
        endDate.setUTCHours(24 * (6 - day));
    return endDate;
};
export const convertWeekYearToDate = ({ week, year }) => {
    if ([week, year].every(Boolean)) {
        const dateOfWeek = getDateOfISOWeek(Number(week), Number(year));
        return {
            year: dateOfWeek.getUTCFullYear().toString(),
            month: dateOfWeek.getUTCMonth().toString(),
            day: dateOfWeek.getUTCDate().toString()
        };
    }
    return undefined;
};
export const is12HClockFormat = (localeTag) => {
    const meridiem = new Intl.DateTimeFormat(localeTag, {
        hour: 'numeric'
    })
        .formatToParts()
        .find(({ type }) => type === 'dayPeriod');
    return !!meridiem?.value;
};
const objDate = new Date();
objDate.setUTCDate(1);
export const getLocalizedMonths = (localeTag) => {
    return [...Array(12).keys()].map(monthNo => {
        objDate.setUTCMonth(monthNo);
        return cap(objDate.toLocaleString(localeTag, { month: 'long', timeZone: 'UTC' }));
    });
};
export const getLocalizedWeekDays = (localeTag) => {
    const calendarType = getCalendarTypeFromLocale(localeTag);
    return getWeekdays(calendarType).reduce((accumulator, dayDate, index) => {
        accumulator[index + 1] = cap(dayDate.toLocaleString(localeTag, {
            weekday: 'long'
        }));
        return accumulator;
    }, {});
};
export const MS_IN_SECOND = 1000;
export const MS_IN_MINUTE = 1000 * 60;
export const MS_IN_HOUR = 1000 * 60 * 60;
export const MS_IN_DAY = 1000 * 60 * 60 * 24;
export const msToTimeFormat = (ms) => {
    if (ms < 0) {
        return { hour: undefined, minute: undefined, second: undefined };
    }
    return {
        hour: Math.floor(ms / MS_IN_HOUR),
        minute: Math.floor((ms / MS_IN_MINUTE) % 60),
        second: Math.floor((ms / MS_IN_SECOND) % 60)
    };
};
export const timeFormatToMs = ({ hour, minute, second }) => {
    if (hour < 0 || minute < 0 || second < 0) {
        return 0;
    }
    return second * MS_IN_SECOND + minute * MS_IN_MINUTE + hour * MS_IN_HOUR;
};
export const msToTimeUnit = (ms, format) => {
    if (ms < 0) {
        return 0;
    }
    switch (format) {
        case 'seconds':
            return Math.floor(ms / MS_IN_SECOND);
        case 'minutes':
            return Math.floor(ms / MS_IN_MINUTE);
        case 'hours':
            return Math.floor(ms / MS_IN_HOUR);
        case 'days':
            return Math.floor(ms / MS_IN_DAY);
        default:
            return 0;
    }
};
export const timeUnitToMs = (count, format) => {
    if (count < 0) {
        return 0;
    }
    switch (format) {
        case 'seconds':
            return count * MS_IN_SECOND;
        case 'minutes':
            return count * MS_IN_MINUTE;
        case 'hours':
            return count * MS_IN_HOUR;
        case 'days':
            return count * MS_IN_DAY;
        default:
            return 0;
    }
};
export const getTimeOptions = (withSeconds, is12h = false) => {
    return {
        hour: 'numeric',
        minute: 'numeric',
        ...(withSeconds && { second: 'numeric' }),
        hour12: is12h
    };
};
export const validateDate = (year, month, day) => {
    return !(year.toString().length < 4 ||
        month < 1 ||
        month > 12 ||
        day < 1 ||
        day > new Date(year, month, 0).getDate());
};
export const validateTime = (hour, minute, second, is12h) => {
    const hourMax = is12h ? 12 : 23;
    const hourMin = is12h ? 1 : 0;
    return !(hour > hourMax || hour < hourMin || minute > 59 || second > 59);
};
export const toUTCDateString = (date, format) => {
    const adjustedDate = new Date(date.getTime() + date.getTimezoneOffset() * 60000);
    return format?.format(adjustedDate) ?? adjustedDate.toDateString();
};
const ISO_DATE_REG_EXP = /(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/;
export const isISODate = (value) => {
    return ISO_DATE_REG_EXP.test(value);
};
const TIME_REG_EXP = /^([01]?\d|2[0-3]):[0-5]?\d(:[0-5]?\d)?$/;
export const isTime = (value) => {
    return TIME_REG_EXP.test(value);
};
export const parseLocaleTextToDateParams = (value, localeTag) => {
    const template = getDateFormat(localeTag, {
        year: 'numeric',
        month: 'numeric',
        day: 'numeric'
    })
        .join('')
        .match(/\w+/g);
    const valueParts = value.match(/\d+/g);
    if (template && valueParts?.length === template?.length) {
        let year = 0;
        let month = 0;
        let day = 0;
        template.forEach((part, index) => {
            if (part === 'YYYY') {
                year = Number(valueParts[index]);
            }
            else if (part === 'MM') {
                month = Number((Number(valueParts[index]) - 1).toString().padStart(2, '0'));
            }
            else if (part === 'DD') {
                day = Number(valueParts[index].padStart(2, '0'));
            }
        });
        return [year, month, day];
    }
    return undefined;
};
export const parsePastedTextToDate = (value, localeTag, currentDate) => {
    let result;
    const dateParams = parseLocaleTextToDateParams(value, localeTag);
    if (isTime(value)) {
        const [hour, minute, second = 0] = value.split(':').map(Number);
        result = new Date(currentDate.getTime()); // clone currentDate object to avoid parameter manipulation
        result.setUTCHours(hour, minute, second);
    }
    else if (dateParams) {
        const [year, month, day] = dateParams;
        if (validateDate(year, month, day)) {
            result = new Date(currentDate.getTime());
            result.setUTCFullYear(year, month, day);
        }
    }
    else if (isISODate(value)) {
        result = new Date(value);
    }
    return result;
};
export const generatePickerButtonAriaLabel = (date, type, locale, translateFn, open) => {
    let datePart = '';
    if (type === 'week') {
        const displayNames = new Intl.DisplayNames(locale, { style: 'long', type: 'dateTimeField' });
        datePart = date
            ? `${translateFn('selected_date_a11y')} ${displayNames.of('weekOfYear')} ${getWeek(date, CALENDAR_TYPES.ISO_8601)}, ${date.getUTCFullYear()}, `
            : '';
    }
    else {
        datePart = date
            ? `${translateFn('selected_date_a11y')} ${date.toLocaleString(locale, {
                timeZone: 'UTC',
                dateStyle: 'full',
                ...(type === 'datetime' ? { timeStyle: 'short' } : {})
            })}, `
            : '';
    }
    return `${datePart}${translateFn(open ? 'close_calendar_button_a11y' : 'open_calendar_button_a11y')}`;
};
//# sourceMappingURL=utils.js.map