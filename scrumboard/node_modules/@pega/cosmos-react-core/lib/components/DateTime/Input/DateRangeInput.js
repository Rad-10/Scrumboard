import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useRef, forwardRef, useCallback, useReducer } from 'react';
import styled, { css } from 'styled-components';
import { useConsolidatedRef, useFocusWithin, useI18n } from '../../../hooks';
import { defaultThemeProp } from '../../../theme';
import Flex from '../../Flex';
import FormField, { StyledFormField } from '../../FormField/FormField';
import DateRangePicker from '../Picker/DateRangePicker';
import { StyledRangeInputContainer } from '../../Input/Input.styles';
import DateInput from './DateInput';
import { parseToDate } from './utils';
import StyledDateInput from './DateTime.styles';
const StyledDateRangeInput = styled.div(props => {
    const { theme: { components: { input } } } = props;
    return css `
    border: 0;
    min-width: min-content;

    ${StyledFormField} {
      &:last-child > ${StyledDateInput} {
        margin-inline-start: -${input['border-width']};
      }
      & legend {
        align-self: center;
      }
      &:focus,
      &:hover,
      &:focus-within {
        z-index: 2;
      }
    }
  `;
});
StyledDateRangeInput.defaultProps = defaultThemeProp;
const reducer = (prevState, action) => {
    switch (action.type) {
        case 'start': {
            return { ...prevState, start: action.value };
        }
        case 'end': {
            return { ...prevState, end: action.value };
        }
        default:
            return prevState;
    }
};
const convertToCallbackParameter = (v) => {
    return {
        valueAsISOString: v === undefined || Number.isNaN(v) ? '' : new Date(v).toISOString(),
        valueAsTimestamp: v
    };
};
const getSelected = (first, second) => {
    const selected = first ?? second;
    return selected ? parseToDate(selected) : undefined;
};
const parseValueToDate = (value) => {
    return value ? parseToDate(value) : undefined;
};
const DateRangeInput = forwardRef(({ value = {}, min, max, label, fromLabel, toLabel, labelHidden, status, required, readOnly, disabled, onChange, onFocus, onBlur, showWeekNumber, autoFocus, fromAdditionalInfo, toAdditionalInfo, ...restProps }, ref) => {
    const t = useI18n();
    const startDateInputRef = useRef(null);
    const endDateInputRef = useRef(null);
    const [state, dispatch] = useReducer(reducer, {
        start: value.start ? parseToDate(value.start).getTime() : undefined,
        end: value.end ? parseToDate(value.end).getTime() : undefined
    });
    // Need to keep the value in ref also, to be able to call onBlur with newest value
    const startDateRef = useRef(state.start);
    const endDateRef = useRef(state.end);
    const onFocusChange = useCallback((focused) => {
        (focused ? onFocus : onBlur)?.({
            start: convertToCallbackParameter(startDateRef.current),
            end: convertToCallbackParameter(endDateRef.current)
        });
    }, [onFocus, onBlur]);
    const containerRef = useConsolidatedRef(ref);
    useFocusWithin([containerRef], onFocusChange);
    const onStartDateChange = (selectedDate) => {
        if (state.end && selectedDate && selectedDate.getTime() > state.end) {
            dispatch({ type: 'start', value: state.end });
            dispatch({ type: 'end', value: selectedDate.getTime() });
            onChange({
                start: convertToCallbackParameter(state.start),
                end: convertToCallbackParameter(state.end)
            });
        }
        else {
            dispatch({ type: 'start', value: selectedDate?.getTime() });
            onChange({
                start: convertToCallbackParameter(selectedDate?.getTime()),
                end: convertToCallbackParameter(state.end)
            });
        }
        startDateRef.current = state.start;
        endDateRef.current = state.end;
        endDateInputRef.current?.setOpen(true);
    };
    const onEndDateChange = (selectedDate) => {
        if (state.start && selectedDate && selectedDate.getTime() < state.start) {
            dispatch({ type: 'end', value: state.start });
            dispatch({ type: 'start', value: selectedDate.getTime() });
            onChange({
                start: convertToCallbackParameter(state.start),
                end: convertToCallbackParameter(state.end)
            });
        }
        else {
            dispatch({ type: 'end', value: selectedDate?.getTime() });
            onChange({
                start: convertToCallbackParameter(state.start),
                end: convertToCallbackParameter(selectedDate?.getTime())
            });
        }
        startDateRef.current = state.start;
        endDateRef.current = state.end;
    };
    const getSelectedRange = () => {
        const startDate = parseValueToDate(state.start);
        const endDate = parseValueToDate(state.end);
        if (startDate && endDate && startDate > endDate)
            return undefined;
        return {
            startDate,
            endDate
        };
    };
    const commonProps = {
        required,
        readOnly,
        disabled,
        min,
        max,
        status
    };
    return (_jsx(FormField, { as: StyledDateRangeInput, ...restProps, ref: containerRef, container: { wrap: 'nowrap' }, labelHidden: labelHidden, label: label, labelAs: 'legend', required: required, readOnly: readOnly, status: status, disabled: disabled, children: _jsxs(Flex, { container: true, as: StyledRangeInputContainer, children: [_jsx(DateInput, { ...commonProps, value: state.start, ref: startDateInputRef, picker: {
                        renderer: DateRangePicker,
                        rendererProps: {
                            selected: getSelected(state.start, state.end),
                            selectedRange: getSelectedRange(),
                            onChange: onStartDateChange
                        }
                    }, onBlur: changedValue => {
                        if (!changedValue.state)
                            dispatch({ type: 'start', value: changedValue.valueAsTimestamp });
                        startDateRef.current = changedValue.valueAsTimestamp;
                        onChange({
                            start: changedValue,
                            end: convertToCallbackParameter(state.end)
                        });
                    }, additionalInfo: fromAdditionalInfo, label: fromLabel, "aria-label": `${t('range_from_datetime') + (label ? ` - ${label}` : '')}`, autoFocus: autoFocus }), _jsx(DateInput, { ...commonProps, value: state.end, ref: endDateInputRef, picker: {
                        renderer: DateRangePicker,
                        rendererProps: {
                            selected: getSelected(state.end, state.start),
                            selectedRange: getSelectedRange(),
                            onChange: onEndDateChange
                        }
                    }, onBlur: changedValue => {
                        if (!changedValue.state)
                            dispatch({ type: 'end', value: changedValue.valueAsTimestamp });
                        endDateRef.current = changedValue.valueAsTimestamp;
                        onChange({
                            start: convertToCallbackParameter(state.start),
                            end: changedValue
                        });
                    }, additionalInfo: toAdditionalInfo, label: toLabel, "aria-label": `${t('range_to_datetime') + (label ? ` - ${label}` : '')}` })] }) }));
});
export default DateRangeInput;
//# sourceMappingURL=DateRangeInput.js.map