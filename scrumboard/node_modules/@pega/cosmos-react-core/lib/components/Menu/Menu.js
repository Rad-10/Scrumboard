import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { forwardRef, useCallback, useEffect, useState, useRef, useMemo } from 'react';
import { useConsolidatedRef, useUID, useActiveDescendant, useLazyDescendant, useI18n, usePrevious, useDirection } from '../../hooks';
import { cap } from '../../utils';
import VisuallyHiddenText from '../VisuallyHiddenText';
import FlyoutMenuList from './FlyoutMenuList';
import MenuContext from './Menu.context';
import { StyledMenu, StyledMenuListWrapper } from './Menu.styles';
import MenuList from './MenuList';
const Menu = forwardRef((props, ref) => {
    const uid = useUID();
    const { id = uid, items = [], mode = 'action', accent, scrollAt = 7, emptyText, onItemClick, onItemActive, onItemExpand, loadMore, onItemCollapse, loading = false, currentItemId, header, footer, variant = 'drill-down', focusControlEl, focusElOnClose = true, arrowNavigationUnsupported, 'aria-describedby': ariaDescribedBy, 'aria-label': label, role = 'menu', listId, pauseDescendantEvaluation, ...restProps } = props;
    const t = useI18n();
    const { end: endDirection, start: startDirection } = useDirection();
    const radioName = useUID();
    const menuRef = useConsolidatedRef(ref);
    const previousItemCount = useRef(0);
    const [activeDescendantUpdateId, setActiveDescendantUpdateId] = useState(0);
    const [focusDescendant, setFocusDescendant] = useState(null);
    const [flyOutActiveIdStack, setFlyoutActiveIdStack] = useState([id]);
    const [focusReturnEl, setFocusReturnEl] = useState();
    const [preventInitialScroll, setPreventInitialScroll] = useState(false);
    const [flyoutFocusReturnStack, setFlyoutFocusReturnStack] = useState([]);
    const activeFlyoutSelector = useMemo(() => `fieldset[data-flyout-menu-id="${flyOutActiveIdStack[flyOutActiveIdStack.length - 1]}"]`, [flyOutActiveIdStack]);
    const focusControl = useMemo(() => {
        return focusControlEl || menuRef.current;
    }, [focusControlEl, menuRef.current]);
    const pushFlyoutId = useCallback((flyoutId) => {
        setFlyoutActiveIdStack([...flyOutActiveIdStack, flyoutId]);
    }, [flyOutActiveIdStack]);
    useEffect(() => {
        setFlyoutActiveIdStack([...flyOutActiveIdStack, id]);
    }, [id]);
    const updateParentDescendantStack = useCallback((item) => {
        setFlyoutFocusReturnStack([...flyoutFocusReturnStack, item]);
    }, [flyoutFocusReturnStack]);
    const getScopedItemId = useCallback((itemId) => {
        return `${id}-item-${itemId}`;
    }, [id]);
    const getUnscopedItemId = useCallback((itemId) => {
        return itemId.split(`${id}-item-`)[1];
    }, [id]);
    const updateActiveDescendants = useCallback(({ preventScroll = false } = {}) => {
        setPreventInitialScroll(preventScroll);
        setActiveDescendantUpdateId(Math.random());
    }, []);
    const uadConfig = useMemo(() => ({
        focusEl: focusControl,
        scope: menuRef.current,
        scopeSelector: variant === 'drill-down'
            ? 'fieldset[aria-hidden="false"]'
            : activeFlyoutSelector,
        selector: `[role="${role === 'menu' ? 'menuitem' : 'option'}"], legend button`,
        focusDescendantEl: focusDescendant,
        clearFocusDescendant: () => {
            setFocusDescendant(null);
            if (focusElOnClose)
                focusControl?.focus();
        },
        focusReturnEl,
        clearFocusReturn: () => {
            setFocusReturnEl(null);
        },
        currentDescendantId: currentItemId ? getScopedItemId(currentItemId) : undefined,
        preventInitialScroll,
        clearPreventScroll: () => {
            setPreventInitialScroll(false);
        },
        pauseDescendantEvaluation
    }), [
        focusControl,
        menuRef.current,
        activeFlyoutSelector,
        focusReturnEl,
        focusDescendant,
        currentItemId,
        preventInitialScroll,
        pauseDescendantEvaluation
    ]);
    const { activeDescendant, descendants } = useActiveDescendant(uadConfig, [
        activeDescendantUpdateId
    ]);
    const previousActiveDescendant = usePrevious(activeDescendant);
    useLazyDescendant({
        loading,
        descendants,
        previousActiveDescendant,
        activeDescendant,
        focusReturnEl,
        setFocusReturnEl,
        scrollEl: uadConfig.scope?.querySelector(uadConfig.scopeSelector)?.querySelector('ul')
    });
    // ## Bind Menu-specific navigation keyDown.
    useEffect(() => {
        const expandOrCollapse = (action = null) => {
            if (activeDescendant) {
                // expand
                if (activeDescendant.dataset.expand === 'true' && action !== 'collapse') {
                    activeDescendant.querySelector('button')?.click();
                    return;
                }
                // collapse
                if (action !== 'expand') {
                    if (variant === 'flyout' &&
                        flyOutActiveIdStack.length > 1 &&
                        flyoutFocusReturnStack.length > 0) {
                        setFlyoutActiveIdStack([...flyOutActiveIdStack].slice(0, -1));
                        const parentDescendant = flyoutFocusReturnStack.pop();
                        if (parentDescendant !== undefined)
                            setFocusReturnEl(parentDescendant);
                        updateActiveDescendants();
                    }
                    else if (activeDescendant.dataset.collapse === 'true')
                        activeDescendant.click();
                }
            }
        };
        const additionalKeydown = (e) => {
            switch (e.key) {
                case `Arrow${cap(endDirection)}`: {
                    if (arrowNavigationUnsupported)
                        break;
                    expandOrCollapse('expand');
                    break;
                }
                case `Arrow${cap(startDirection)}`: {
                    if (arrowNavigationUnsupported)
                        break;
                    expandOrCollapse('collapse');
                    break;
                }
                case 'Escape': {
                    if (variant === 'flyout' &&
                        flyOutActiveIdStack.length > 1 &&
                        flyoutFocusReturnStack.length > 0) {
                        e.preventDefault();
                        e.stopPropagation();
                        setFlyoutActiveIdStack([...flyOutActiveIdStack].slice(0, -1));
                        const parentDescendant = flyoutFocusReturnStack.pop();
                        if (parentDescendant !== undefined)
                            setFocusReturnEl(parentDescendant);
                        updateActiveDescendants();
                    }
                    break;
                }
                default:
                    break;
            }
            if (arrowNavigationUnsupported && (e.key === ' ' || e.key === 'Spacebar') && e.shiftKey) {
                e.preventDefault();
                expandOrCollapse();
            }
        };
        if (activeDescendant)
            onItemActive?.(getUnscopedItemId(activeDescendant.id));
        focusControl?.addEventListener('keydown', additionalKeydown);
        return () => focusControl?.removeEventListener('keydown', additionalKeydown);
    }, [focusControl, activeDescendant, flyOutActiveIdStack]);
    // ## Update useActiveDescendant on change of items, not selection of items.
    useEffect(() => {
        // Next tick for DOM updates.
        const timeoutId = setTimeout(() => {
            if (items.length === previousItemCount.current) {
                const previousDescendantIds = descendants?.map(node => node.id);
                const newDescendants = uadConfig.scope
                    ?.querySelector(uadConfig.scopeSelector)
                    ?.querySelectorAll(uadConfig.selector);
                if (!newDescendants) {
                    updateActiveDescendants();
                    return;
                }
                const scopedDescendants = Array.from(newDescendants);
                if (scopedDescendants?.length !== previousDescendantIds?.length) {
                    updateActiveDescendants();
                    return;
                }
                const itemsUnchanged = scopedDescendants.every((node, index) => node.id === previousDescendantIds[index]);
                if (!itemsUnchanged) {
                    updateActiveDescendants();
                }
                return;
            }
            previousItemCount.current = items.length;
            updateActiveDescendants();
        }, 0);
        return () => clearTimeout(timeoutId);
    }, [items]);
    const contextValue = useMemo(() => {
        return {
            componentId: id,
            mode,
            arrowNavigationUnsupported,
            onItemClick,
            onItemActive,
            onItemExpand,
            onItemCollapse,
            accent,
            scrollAt,
            emptyText,
            radioName,
            loadMore,
            loading,
            variant,
            focusControl,
            updateActiveDescendants,
            setFocusReturnEl,
            setFocusDescendant,
            getScopedItemId,
            pushFlyoutId,
            flyOutActiveIdStack,
            updateParentDescendantStack
        };
    }, [
        id,
        mode,
        arrowNavigationUnsupported,
        onItemClick,
        onItemActive,
        onItemExpand,
        onItemCollapse,
        accent,
        scrollAt,
        emptyText,
        radioName,
        loadMore,
        loading,
        variant,
        focusControl,
        updateActiveDescendants,
        setFocusReturnEl,
        setFocusDescendant,
        getScopedItemId,
        pushFlyoutId,
        flyOutActiveIdStack,
        updateParentDescendantStack
    ]);
    return (_jsxs(StyledMenu, { id: id, "aria-describedby": !focusControlEl ? `${id}-menuDescription` : undefined, ...restProps, ref: menuRef, children: [!focusControlEl && (_jsx("span", { id: `${id}-menuDescription`, hidden: true, children: (`${t('menu_selection_instructions')} ` && ariaDescribedBy) || '' })), label && _jsx(VisuallyHiddenText, { id: `${id}-menuLabel`, children: label }), header && _jsx("header", { children: header }), _jsx(StyledMenuListWrapper, { children: _jsx(MenuContext.Provider, { value: contextValue, children: variant === 'drill-down' ? (_jsx(MenuList, { items: items, id: listId, menuRole: role, "aria-labelledby": label ? `${id}-menuLabel` : undefined })) : (_jsx(FlyoutMenuList, { items: items, menuRole: role })) }) }), footer && _jsx("footer", { children: footer })] }));
});
export default Menu;
//# sourceMappingURL=Menu.js.map