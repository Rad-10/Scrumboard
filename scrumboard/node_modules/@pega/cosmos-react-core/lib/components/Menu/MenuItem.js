import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import { Fragment, useCallback, useContext, useEffect, useRef, useMemo } from 'react';
import MetaList from '../MetaList';
import SummaryItem from '../SummaryItem';
import Flex from '../Flex';
import Icon, { registerIcon } from '../Icon';
import * as caretLeftIcon from '../Icon/icons/caret-left.icon';
import * as caretRightIcon from '../Icon/icons/caret-right.icon';
import * as checkIcon from '../Icon/icons/check.icon';
import Text from '../Text';
import { Count } from '../Badges';
import BareButton from '../Button/BareButton';
import { replaceMatchWithElement } from '../../utils';
import { useElement, useI18n, usePrevious, useDirection } from '../../hooks';
import Tooltip from '../Tooltip';
import Mark from '../Mark';
import menuHelpers from './helpers';
import MenuContext from './Menu.context';
import { StyledAncestors, StyledExpandButton, StyledItemLabel, StyledMenuItem, StyledVisibilityHidden } from './Menu.styles';
registerIcon(caretLeftIcon, caretRightIcon, checkIcon);
const AncestorPath = ({ ancestors = [] }) => {
    const truncatedPath = ancestors.length > 2;
    const pathParts = truncatedPath ? [ancestors[0], ancestors[ancestors.length - 1]] : ancestors;
    const { end } = useDirection();
    return (_jsx(Flex, { container: { gap: 0.5, alignItems: 'center' }, as: StyledAncestors, title: ancestors.map(a => (menuHelpers.isItem(a) ? a.primary : a.label)).join(' > '), children: pathParts.map((ancestor, i, arr) => {
            const label = menuHelpers.isItem(ancestor) ? ancestor.primary : ancestor.label;
            return (_jsxs(Fragment, { children: [_jsx(Text, { variant: 'secondary', children: label }), i < arr.length - 1 && (_jsxs(_Fragment, { children: [_jsx(Text, { variant: 'secondary', children: _jsx(Icon, { name: `caret-${end}` }) }), truncatedPath && (_jsxs(_Fragment, { children: [_jsx(Text, { variant: 'secondary', children: "\u2026" }), _jsx(Text, { variant: 'secondary', children: _jsx(Icon, { name: `caret-${end}` }) })] }))] }))] }, label));
        }) }));
};
const MenuItem = ({ id, primary, secondary, ancestors, visual, count, items, selected, partial, href, tooltip, onClick, onExpand, disabled, role = 'menuitem', ...restProps }) => {
    const t = useI18n();
    const { mode, onItemClick, accent, radioName, variant: menuVariant, setFocusDescendant, getScopedItemId, arrowNavigationUnsupported } = useContext(MenuContext);
    const previouslySelected = usePrevious(selected);
    const selectionMode = mode === 'single-select' || mode === 'multi-select';
    const isParentItem = useMemo(() => selectionMode && items, [selectionMode, items]);
    const selectableParent = isParentItem && typeof selected === 'boolean';
    const inputRef = useRef(null);
    const itemId = useMemo(() => getScopedItemId(id), [id, getScopedItemId]);
    const { end } = useDirection();
    const clickHandler = useCallback((e) => {
        const mouseClick = e.detail !== 0;
        if (mouseClick) {
            const target = e.target;
            const focusAtEl = target.getAttribute('role') === role ? target : target.closest(`li[role="${role}"]`);
            if (focusAtEl)
                setFocusDescendant(focusAtEl);
        }
        onClick?.(id, e);
        onItemClick?.(id, e);
    }, [onClick, onItemClick, id]);
    const expandHandler = useCallback((e) => {
        onExpand?.(id, e);
    }, [onExpand, id]);
    const navigationInteractionId = `${id}-description`;
    const secondaryId = `${id}-secondary`;
    let accentedPrimary;
    if (accent && !items) {
        const accentRegex = typeof accent === 'function' ? accent(primary) : accent;
        accentedPrimary = replaceMatchWithElement(primary, accentRegex, str => {
            return _jsx(Mark, { children: str });
        });
    }
    const secondaryContent = ancestors ? (_jsx(AncestorPath, { ancestors: ancestors })) : (secondary && _jsx(MetaList, { items: secondary, id: secondaryId, wrapItems: false }));
    const [summaryItemRef, setSummaryItemRef] = useElement();
    const summaryItem = (_jsxs(_Fragment, { children: [_jsx(SummaryItem, { ref: setSummaryItemRef, primary: accentedPrimary || (!items ? _jsx(Text, { children: primary }) : primary), secondary: secondaryContent, visual: visual, actions: (items && !selectableParent) || count ? (_jsxs(Flex, { container: { gap: 1 }, children: [_jsx(Count, { children: count ?? null }), items && !selectableParent && _jsx(Icon, { name: `caret-${end}` })] })) : undefined, container: {
                    colGap: 1
                } }), tooltip && (_jsx(Tooltip, { target: summaryItemRef, hideDelay: 'none', showDelay: 'none', portal: true, children: tooltip }))] }));
    let InteractiveWrap;
    if (href) {
        InteractiveWrap = href ? 'a' : BareButton;
    }
    else if (mode === 'action' || items) {
        InteractiveWrap = BareButton;
    }
    const itemChild = InteractiveWrap ? (_jsx(InteractiveWrap, { onMouseDown: (e) => {
            e.preventDefault();
        }, onClick: items ? expandHandler : clickHandler, onMouseEnter: menuVariant === 'flyout' ? expandHandler : undefined, href: href, tabIndex: '-1', disabled: disabled, children: summaryItem })) : (summaryItem);
    useEffect(() => {
        if (inputRef.current) {
            inputRef.current.indeterminate = !!partial;
        }
    }, [partial]);
    const labelRef = useRef(null);
    const itemLabel = useMemo(() => {
        const label = selected ? t('checked_noun', [primary]) : primary;
        return isParentItem ? t('expand_noun', [label]) : label;
    }, [selected, primary, isParentItem]);
    const describedBy = useMemo(() => {
        const hasItems = !!items;
        const hasSecondary = !!secondary;
        let idString = hasSecondary ? secondaryId : undefined;
        if (hasItems) {
            if (hasSecondary)
                idString = idString.concat(`, ${navigationInteractionId}`);
            else
                idString = navigationInteractionId;
        }
        return idString;
    }, [items, secondary, navigationInteractionId, secondaryId]);
    const navigationInstructions = useMemo(() => {
        if (arrowNavigationUnsupported) {
            return t('menu_item_shift_space_expand_collapse');
        }
        return t('menu_item_expand_arrow');
    }, []);
    const interactionNotification = useMemo(() => {
        if (previouslySelected === undefined)
            return '';
        return `${selected ? t('selected_noun', [primary]) : t('deselected_noun', [primary])}`;
    }, [selected]);
    return (_jsxs(Flex, { ...restProps, container: { alignItems: 'stretch', justify: 'between' }, id: itemId, as: StyledMenuItem, "aria-label": itemLabel, "aria-describedby": describedBy, isParentItem: isParentItem, role: role, "aria-disabled": disabled, "data-expand": !!items, tabIndex: '-1', children: [selectionMode && typeof selected === 'boolean' ? (_jsxs(_Fragment, { children: [_jsxs(Flex, { ref: labelRef, as: StyledItemLabel, container: { alignItems: 'center', gap: 1 }, item: { grow: 1 }, onMouseDown: (e) => {
                            e.preventDefault();
                        }, 
                        // https://stackoverflow.com/questions/32958091/how-to-prevent-clicking-on-a-checkboxs-label-from-stealing-focus
                        onClick: (e) => {
                            if (labelRef.current?.control !== e.target) {
                                e.preventDefault();
                                // Preserve detail property (lost with .click()).
                                const event = new window.MouseEvent(e.nativeEvent.type, e.nativeEvent);
                                labelRef.current?.control?.dispatchEvent(event);
                            }
                        }, children: [_jsx("input", { ref: inputRef, type: mode === 'single-select' ? 'radio' : 'checkbox', name: mode === 'single-select' ? radioName : undefined, "aria-label": primary, checked: !!selected, disabled: disabled, onClick: clickHandler, onKeyDown: (e) => {
                                    if (mode === 'single-select' && e.key === 'Enter') {
                                        e.currentTarget.click();
                                    }
                                }, 
                                // no-op since React will complain about a controlled input without an onChange
                                onChange: () => { }, onMouseDown: e => {
                                    e.preventDefault();
                                }, tabIndex: -1 }), (mode === 'single-select' || mode === 'multi-select') && _jsx(Icon, { name: 'check' }), summaryItem] }), isParentItem && (_jsx(StyledExpandButton, { icon: true, variant: 'simple', onClick: expandHandler, tabIndex: '-1', children: _jsx(Icon, { name: `caret-${end}` }) }))] })) : (itemChild), !!items && (_jsx(StyledVisibilityHidden, { id: navigationInteractionId, children: navigationInstructions })), _jsx(StyledVisibilityHidden, { role: 'alert', children: interactionNotification })] }));
};
export default MenuItem;
//# sourceMappingURL=MenuItem.js.map