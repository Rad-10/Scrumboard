import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { forwardRef, useContext, useRef, useEffect, useMemo, useState } from 'react';
import { createPortal } from 'react-dom';
import { usePopper } from 'react-popper';
import { useAfterInitialEffect, useConfiguration, useConsolidatedRef, useElement, useUID } from '../../hooks';
import { popoverMap, windowIsAvailable } from '../../utils';
import { BackdropContext } from '../Backdrop/Backdrop';
import { PopoverManagerContext } from './PopoverContext';
import { StyledPopover, StyledPopoverContent, StyledPopoverArrow } from './Popover.styles';
import { applyMaxSize, maxSize } from './modifiers';
const delays = {
    none: 0,
    short: 500,
    long: 1000
};
const Popover = forwardRef(({ show = true, portal = true, target, placement, strategy = 'fixed', style, modifiers = [], arrow = false, groupId, showDelay = 'none', hideDelay = 'none', hideOnTargetHidden = false, children, onHide, ...restProps }, ref) => {
    const { portalTarget: configurationPortal } = useConfiguration();
    const { el: backdropPortal } = useContext(BackdropContext);
    const { checkActive, setActive, popovers } = useContext(PopoverManagerContext);
    const [, setPopperEl] = useElement();
    const popperRef = useConsolidatedRef(ref, setPopperEl);
    const arrowRef = useRef(null);
    const forceUpdateRef = useRef();
    const [showPopover, setShowPopover] = useState(show);
    const timeout = useRef();
    const uid = useUID();
    const pointerId = useUID();
    const portalTarget = typeof portal === 'boolean' ? backdropPortal ?? configurationPortal : portal;
    const memoedModifiers = useMemo(() => [
        {
            name: 'computeStyles',
            options: {
                gpuAcceleration: false
            }
        },
        {
            name: 'offset',
            options: {
                offset: [0, arrow ? 5.5 : 2]
            }
        },
        { name: 'hide', enabled: hideOnTargetHidden },
        { name: 'arrow', enabled: arrow, options: { element: arrowRef.current } },
        {
            name: 'preventOverflow',
            options: {
                tether: !modifiers.find(m => m.name === 'sameWidth')
            }
        },
        maxSize,
        applyMaxSize,
        ...modifiers
    ], [modifiers, arrow, hideOnTargetHidden]);
    const offset = useMemo(() => {
        const offsetModifier = [...memoedModifiers]
            .reverse()
            .find(m => m.name === 'offset' && m.enabled !== false);
        return Array.isArray(offsetModifier?.options?.offset)
            ? offsetModifier?.options?.offset[1] ?? 0
            : 0;
    }, [memoedModifiers]);
    const { styles, attributes, forceUpdate } = usePopper(target, popperRef.current, {
        placement,
        strategy,
        modifiers: memoedModifiers
    });
    if (forceUpdate)
        forceUpdateRef.current = forceUpdate;
    useEffect(() => {
        const observer = new ResizeObserver(() => {
            forceUpdateRef.current?.();
        });
        if (popperRef.current)
            observer.observe(popperRef.current);
        if (target instanceof Element)
            observer.observe(target);
        return () => {
            observer.disconnect();
        };
    }, [forceUpdate, popperRef.current, target]);
    useEffect(() => {
        if (groupId && show)
            setActive(uid, groupId);
        if (windowIsAvailable) {
            if (timeout.current)
                clearTimeout(timeout.current);
            timeout.current = window.setTimeout(() => {
                setShowPopover(show);
            }, delays[show ? showDelay : hideDelay]);
        }
        else {
            setShowPopover(show);
        }
    }, [show]);
    useEffect(() => {
        return () => clearTimeout(timeout.current);
    }, []);
    useAfterInitialEffect(() => {
        if (!showPopover) {
            onHide?.();
        }
    }, [showPopover]);
    useEffect(() => {
        if (groupId && popovers[groupId] && popovers[groupId] !== uid) {
            setShowPopover(false);
        }
    }, [groupId ? popovers[groupId] : undefined]);
    useEffect(() => {
        if (!portal)
            return;
        const resolvedTarget = target instanceof Element ? target : target?.contextElement;
        if (!resolvedTarget)
            return;
        if (!popoverMap.has(resolvedTarget)) {
            popoverMap.set(resolvedTarget, new Set());
        }
        if (!resolvedTarget.hasAttribute('data-popover-target')) {
            resolvedTarget.toggleAttribute('data-popover-target', true);
        }
        popoverMap.get(resolvedTarget).add(pointerId);
        return () => {
            if (!popoverMap.has(resolvedTarget))
                return;
            popoverMap.get(resolvedTarget).delete(pointerId);
            if (popoverMap.get(resolvedTarget).size === 0) {
                popoverMap.delete(resolvedTarget);
                resolvedTarget.removeAttribute('data-popover-target');
            }
        };
    }, [portal, target, pointerId]);
    const content = (_jsxs(StyledPopover, { ...restProps, "data-popover-id": pointerId, portal: !!(portal && portalTarget), offset: offset, ref: popperRef, style: { ...style, ...styles.popper }, ...attributes.popper, children: [arrow && _jsx(StyledPopoverArrow, { ref: arrowRef, style: { ...styles.arrow } }), _jsx(StyledPopoverContent, { children: children })] }));
    if (!target || !showPopover || (groupId && !checkActive(uid, groupId)))
        return null;
    return portal && portalTarget ? createPortal(content, portalTarget) : content;
});
export default Popover;
//# sourceMappingURL=Popover.js.map