import { jsxs as _jsxs, jsx as _jsx, Fragment as _Fragment } from "react/jsx-runtime";
import { forwardRef, useCallback, useMemo, useRef, useState } from 'react';
import Actions from '../Actions';
import Text from '../Text';
import Button from '../Button';
import { useBreakpoint, useConsolidatedRef, useI18n } from '../../hooks';
import Flex from '../Flex';
import SearchInput from '../SearchInput';
import Icon, { registerIcon } from '../Icon';
import * as filterIcon from '../Icon/icons/filter.icon';
import * as arrowUpDownIcon from '../Icon/icons/arrow-up-down.icon';
import * as rowIcon from '../Icon/icons/row.icon';
import * as plusIcon from '../Icon/icons/plus.icon';
import * as moreIcon from '../Icon/icons/more.icon';
import { hasProp } from '../../utils';
import MenuButton from '../MenuButton';
import { Count } from '../Badges';
import PresetMenuPopover from './PresetMenuPopover';
import { StyledViewSelector, StyledSearchForm, StyledListToolbar, StyledHeadingText } from './ListToolbar.styles';
import QueryOptionPopover from './QueryOptionPopover';
registerIcon(filterIcon, arrowUpDownIcon, rowIcon, plusIcon, moreIcon);
const CountMeta = ({ count }) => {
    const t = useI18n();
    return (_jsxs(Text, { variant: 'secondary', children: [count.total !== undefined &&
                t('results_count', [count.totalHasMore ? `${count.total}+` : count.total], {
                    count: count.total
                }), count.total !== undefined && count.selected !== undefined && ' ', count.selected !== undefined &&
                `(${t('selected_count', [count.selected], { count: count.selected })})`] }));
};
const QueryOptionButton = ({ id, queryOptionProps, iconOnly, onClick }) => {
    const t = useI18n();
    let i18nKey;
    let icon;
    if (id === 'filter') {
        i18nKey = 'filter';
        icon = 'filter';
    }
    else if (id === 'sort') {
        i18nKey = 'sort';
        icon = 'arrow-up-down';
    }
    else {
        i18nKey = 'group';
        icon = 'row';
    }
    const text = t(i18nKey);
    const variant = iconOnly ? 'simple' : 'text';
    if (hasProp(queryOptionProps, 'renderer')) {
        return (_jsx("div", { children: _jsx(Button, { variant: variant, icon: iconOnly, label: iconOnly ? text : undefined, onClick: onClick, children: _jsxs(Flex, { container: { inline: true, alignItems: 'center', gap: 1 }, as: 'span', children: [_jsx(Icon, { name: icon }), !iconOnly && text, !iconOnly && queryOptionProps.count && _jsx(Count, { children: queryOptionProps.count })] }) }) }));
    }
    if (hasProp(queryOptionProps, 'items')) {
        return (_jsx("div", { children: _jsx(MenuButton, { variant: variant, text: text, icon: icon, iconOnly: iconOnly, count: queryOptionProps.count, onClick: onClick, menu: {
                    mode: queryOptionProps.mode,
                    items: queryOptionProps.items.map(item => ({ ...item, primary: item.text })),
                    onItemClick: queryOptionProps.onItemClick
                } }) }));
    }
    return null;
};
const ListToolbar = forwardRef(({ heading, formControlProps, createNew, search, count, additionalActions, filter, sort, group, actions, actionsButtonRef, condensed }, ref) => {
    const t = useI18n();
    const isSmallOrAbove = useBreakpoint('sm');
    const isMediumOrAbove = useBreakpoint('md');
    const consolidatedActionsButtonRef = useConsolidatedRef(actionsButtonRef);
    const [currentQueryOptionId, setCurrentQueryOptionId] = useState(null);
    const queryOptionPopoverTarget = useRef();
    const [actionsQueryOptionPreset, setActionsQueryOptionPreset] = useState();
    const [optionPresetMenuOpen, setOptionPresetMenuOpen] = useState(false);
    const createNewButton = useMemo(() => {
        if (!createNew?.onClick)
            return null;
        const text = createNew.label ?? t('create_new');
        return (_jsx(Button, { variant: isSmallOrAbove ? 'secondary' : 'simple', icon: !isSmallOrAbove, label: isSmallOrAbove ? undefined : text, "aria-label": text, onClick: createNew.onClick, children: isSmallOrAbove ? text : _jsx(Icon, { name: 'plus' }) }));
    }, [t, createNew, isSmallOrAbove]);
    const filterButton = filter && (_jsx(QueryOptionButton, { id: 'filter', queryOptionProps: filter, iconOnly: !isMediumOrAbove, onClick: e => {
            setCurrentQueryOptionId('filter');
            queryOptionPopoverTarget.current = e.currentTarget;
        } }));
    const sortButton = sort && (_jsx(QueryOptionButton, { id: 'sort', queryOptionProps: sort, iconOnly: !isMediumOrAbove, onClick: e => {
            setCurrentQueryOptionId('sort');
            queryOptionPopoverTarget.current = e.currentTarget;
        } }));
    const groupButton = group && (_jsx(QueryOptionButton, { id: 'group', queryOptionProps: group, iconOnly: !isMediumOrAbove, onClick: e => {
            setCurrentQueryOptionId('group');
            queryOptionPopoverTarget.current = e.currentTarget;
        } }));
    let queryOptionPopover = null;
    if (currentQueryOptionId) {
        const queryOptionProps = { filter, sort, group }[currentQueryOptionId];
        if (queryOptionProps && hasProp(queryOptionProps, 'renderer')) {
            queryOptionPopover = (_jsx(QueryOptionPopover, { target: queryOptionPopoverTarget.current, heading: t(`${currentQueryOptionId}_by`), onCancel: () => {
                    if (queryOptionProps.onCancel() === false)
                        return;
                    setCurrentQueryOptionId(null);
                }, onSubmit: () => {
                    if (queryOptionProps.onSubmit() === false)
                        return;
                    setCurrentQueryOptionId(null);
                }, children: _jsx(queryOptionProps.renderer, {}) }));
        }
    }
    const getQueryOptionAction = useCallback((id, icon, queryOptionProps) => {
        return {
            text: t(id),
            id,
            icon,
            count: queryOptionProps.count,
            onClick: () => {
                if (hasProp(queryOptionProps, 'renderer')) {
                    setCurrentQueryOptionId(id);
                    queryOptionPopoverTarget.current = consolidatedActionsButtonRef.current ?? undefined;
                }
                if (hasProp(queryOptionProps, 'items')) {
                    setActionsQueryOptionPreset({
                        heading: t(`${id}_by`),
                        menu: {
                            mode: queryOptionProps.mode,
                            items: queryOptionProps.items.map(item => ({ ...item, primary: item.text })),
                            onItemClick: queryOptionProps.onItemClick
                        }
                    });
                    setOptionPresetMenuOpen(true);
                }
            }
        };
    }, []);
    const basicModeActions = useMemo(() => {
        let basicActions = [];
        if (filter) {
            const filterAction = getQueryOptionAction('filter', 'filter', filter);
            basicActions.push(filterAction);
        }
        if (sort) {
            const sortAction = getQueryOptionAction('sort', 'arrow-up-down', sort);
            basicActions.push(sortAction);
        }
        if (group) {
            const groupAction = getQueryOptionAction('group', 'row', group);
            basicActions.push(groupAction);
        }
        if (actions) {
            basicActions = basicActions.concat(actions);
        }
        return basicActions.length ? basicActions : undefined;
    }, [actions, filter, sort, group, getQueryOptionAction]);
    return (_jsxs(Flex, { as: StyledListToolbar, container: { direction: 'column', gap: 2 }, item: { grow: 1 }, ref: ref, role: 'toolbar', children: [(heading ||
                createNewButton ||
                (condensed && (count || additionalActions || search || basicModeActions))) && (_jsxs(Flex, { container: { alignItems: 'start', justify: 'between', gap: 2 }, children: [_jsxs(Flex, { container: { alignItems: 'center', gap: 2, wrap: 'wrap' }, children: [heading &&
                                (typeof heading === 'string' ? (_jsx(StyledHeadingText, { variant: 'h3', required: formControlProps?.required, children: heading })) : (_jsx(StyledViewSelector, { variant: 'text', text: heading.views.find(view => view.selected)?.text ?? heading.views[0].text, menu: {
                                        mode: 'single-select',
                                        items: heading.views.map(view => ({
                                            ...view,
                                            primary: `${view.text}${view.id === heading.defaultId ? ` (${t('default')})` : ''}${view.id === heading.appDefaultId ? ` (${t('app_default')})` : ''}`
                                        })),
                                        onItemClick: heading.onViewSelect
                                    }, required: formControlProps?.required }))), isSmallOrAbove && condensed && (_jsxs(_Fragment, { children: [count && _jsx(CountMeta, { count: count }), additionalActions] }))] }), _jsxs(Flex, { container: { alignItems: 'center', gap: 2 }, children: [search && condensed && isSmallOrAbove && _jsx(SearchInput, { ...search }), createNewButton, condensed && basicModeActions && (_jsx("span", { children: _jsx(Actions, { items: basicModeActions.map(({ icon, ...restProps }) => ({
                                        visual: icon ? _jsx(Icon, { name: icon }) : undefined,
                                        ...restProps
                                    })), menuAt: 1, ref: consolidatedActionsButtonRef }) }))] })] })), (!condensed || !isSmallOrAbove) && (_jsxs(Flex, { container: { alignItems: 'start', justify: 'between', gap: 2 }, children: [_jsxs(Flex, { as: StyledSearchForm, container: { alignItems: 'center', wrap: 'wrap', gap: 2 }, item: { grow: 1 }, children: [search && _jsx(SearchInput, { ...search }), isSmallOrAbove && !condensed && (_jsxs(_Fragment, { children: [count && _jsx(CountMeta, { count: count }), additionalActions] }))] }), !condensed && (filterButton || sortButton || groupButton || actions) && (_jsxs(Flex, { container: { alignItems: 'center', gap: 1 }, md: { container: { gap: 2 } }, children: [_jsxs(_Fragment, { children: [filterButton, sortButton, groupButton] }), actions && (_jsx(Actions, { items: actions.map(({ icon, ...restProps }) => ({
                                    visual: icon ? _jsx(Icon, { name: icon }) : undefined,
                                    ...restProps
                                })), menuAt: 1, ref: consolidatedActionsButtonRef }))] }))] })), !isSmallOrAbove && (count || additionalActions) && (_jsxs(Flex, { container: { alignItems: 'center', wrap: 'wrap', gap: 2 }, children: [count && _jsx(CountMeta, { count: count }), additionalActions] })), queryOptionPopover, condensed && (_jsx(PresetMenuPopover, { buttonRef: consolidatedActionsButtonRef, heading: actionsQueryOptionPreset?.heading, menu: actionsQueryOptionPreset?.menu, isOpen: optionPresetMenuOpen, onClose: () => setOptionPresetMenuOpen(false) }))] }));
});
export default ListToolbar;
//# sourceMappingURL=ListToolbar.js.map