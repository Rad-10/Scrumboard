import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { forwardRef, useEffect, useLayoutEffect, useRef, useState } from 'react';
import styled, { css } from 'styled-components';
import { useConsolidatedRef, useElement, useEscape, useFocusTrap, useI18n, useOuterEvent, usePrevious, useUID } from '../../hooks';
import { defaultThemeProp } from '../../theme';
import { getFocusables } from '../../utils';
import Button from '../Button';
import { CardContent, CardFooter, CardHeader } from '../Card';
import Icon from '../Icon';
import Popover from '../Popover';
import Progress from '../Progress';
import Text from '../Text';
import VisuallyHiddenText from '../VisuallyHiddenText';
export const StyledDialog = styled.dialog(({ theme: { base: { 'content-width': contentWidth, palette: { 'foreground-color': foregroundColor } } } }) => {
    return css `
      border: none;
      min-width: ${contentWidth.sm};
      max-width: ${contentWidth.lg};
      color: ${foregroundColor};
    `;
});
StyledDialog.defaultProps = defaultThemeProp;
export const StyledDialogTitle = styled(Text)(({ theme: { base: { shadow, 'border-radius': borderRadius } } }) => {
    return css `
      position: relative;
      ::after {
        content: '';
        border-radius: ${borderRadius};
        position: absolute;
        inset: -0.25rem;
      }
      :focus-visible {
        outline: none;
        ::after {
          box-shadow: ${shadow.focus}, inset ${shadow['focus-solid']};
        }
      }
    `;
});
StyledDialogTitle.defaultProps = defaultThemeProp;
export const useDialog = () => {
    const [target, setTarget] = useState(null);
    const [loading, setLoading] = useState(false);
    const setTargetWithEvent = (e) => {
        if (e.target instanceof HTMLElement) {
            setTarget(e.target);
        }
    };
    return {
        target,
        loading,
        setLoading,
        events: {
            onMouseDown: (e) => {
                setTargetWithEvent(e);
            },
            onKeyDown: (e) => {
                if (e.key === 'Enter') {
                    setTargetWithEvent(e);
                }
            }
        },
        setTargetWithEvent
    };
};
const Dialog = forwardRef(({ target, placement, heading, headingHidden = false, onSubmit, onClose, onOpen, loading, children, ...restProps }, ref) => {
    const t = useI18n();
    const headingId = useUID();
    const [popoverEl, setPopoverEl] = useElement();
    const popoverRef = useConsolidatedRef(ref, setPopoverEl);
    const headingRef = useRef(null);
    const [currentTarget, setCurrentTarget] = useState(() => target);
    const [show, setShow] = useState(false);
    const skipChangeShow = useRef(false);
    const prevTarget = usePrevious(target);
    useEscape(() => {
        if (show) {
            setShow(false);
        }
    }, undefined, [show, setShow]);
    useOuterEvent('mousedown', [target, popoverEl], () => {
        if (target && popoverEl && show) {
            setShow(false);
            onClose?.();
        }
    });
    useFocusTrap(popoverRef);
    useEffect(() => {
        if (!show) {
            currentTarget?.focus();
        }
    }, [show]);
    useEffect(() => {
        if (show && popoverEl) {
            if (headingRef.current) {
                headingRef.current.focus();
            }
            else {
                const focusables = getFocusables(popoverRef);
                focusables[0]?.focus();
            }
        }
    }, [show, popoverEl]);
    useLayoutEffect(() => {
        const onTargetClick = (e) => {
            setCurrentTarget(prev => (e.target ? e.target : prev));
            if (!skipChangeShow.current) {
                setShow(prev => !prev);
            }
            else {
                skipChangeShow.current = false;
            }
        };
        if (target instanceof HTMLElement) {
            target.addEventListener('click', onTargetClick);
        }
        return () => {
            if (target instanceof HTMLElement) {
                target.removeEventListener('click', onTargetClick);
            }
        };
    }, [target]);
    useEffect(() => {
        if (show) {
            onOpen?.();
        }
        else {
            onClose?.();
        }
    }, [show]);
    useEffect(() => {
        /* If our target is changing and the popover is already open we will want
        to skip the next change. The next show change would come from a click on the new button,
        the popover should stay open. */
        if (target !== prevTarget && show) {
            skipChangeShow.current = true;
        }
    }, [target, show]);
    const onTitleKeyDown = (e) => {
        const focusables = getFocusables(popoverRef);
        if (e.shiftKey && e.key === 'Tab') {
            e.preventDefault();
            focusables[focusables.length - 1].focus();
        }
    };
    const progress = loading ? _jsx(Progress, { placement: 'local' }) : null;
    return (_jsxs(Popover, { ...restProps, as: StyledDialog, ref: popoverRef, target: currentTarget, placement: placement, show: show, open: show, "aria-labelledby": headingId, children: [_jsx(CardHeader, { actions: !onSubmit ? (_jsx(Button, { icon: true, variant: 'simple', onClick: () => setShow(false), "aria-label": t('close'), children: _jsx(Icon, { name: 'times' }) })) : undefined, children: headingHidden ? (_jsx(VisuallyHiddenText, { id: headingId, children: heading })) : (_jsx(StyledDialogTitle, { variant: 'h2', tabIndex: -1, ref: headingRef, onKeyDown: onTitleKeyDown, id: headingId, children: heading })) }), _jsxs(CardContent, { children: [children, progress] }), onSubmit && (_jsxs(CardFooter, { justify: 'between', children: [_jsx(Button, { variant: 'secondary', onClick: () => setShow(false), children: t('cancel') }), _jsx(Button, { variant: 'primary', onClick: () => onSubmit({ close: () => setShow(false) }), disabled: loading, children: t('submit') })] }))] }));
});
export default Dialog;
//# sourceMappingURL=Dialog.js.map