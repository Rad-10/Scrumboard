import { createElement as _createElement } from "react";
import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { useContext, useReducer, useMemo, useLayoutEffect, useRef, useState, forwardRef, useEffect } from 'react';
import { createPortal } from 'react-dom';
import styled, { css } from 'styled-components';
import Button from '../Button';
import Icon, { registerIcon } from '../Icon';
import * as timesIcon from '../Icon/icons/times.icon';
import { createUID, windowIsAvailable } from '../../utils';
import { useConfiguration, useI18n } from '../../hooks';
import { defaultThemeProp } from '../../theme';
import Flex from '../Flex';
import '../../init';
import { ToasterContext } from './Context';
registerIcon(timesIcon);
const StyledToastButton = styled.button(({ theme }) => css `
    border: none;
    color: inherit;
    padding: 0;
    font-size: 1rem;

    &:enabled:hover {
      background: #ffffff19;
    }

    &:enabled:focus {
      box-shadow: ${theme.base.shadow['focus-inverted']};
    }
  `);
StyledToastButton.defaultProps = defaultThemeProp;
const StyledToastContent = styled.div(({ theme }) => {
    return css `
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
    font-size: ${theme.base['font-size']};
    margin-inline-start: calc(${theme.base['border-radius']} / 2);
  `;
});
StyledToastContent.defaultProps = defaultThemeProp;
const StyledToast = styled.div(({ theme }) => {
    return css `
    position: absolute;
    inset-block-start: 0;
    inset-inline-start: 0;
    width: 100%;
    padding: calc(${theme.base.spacing} / 2);
    background: ${theme.base.colors.slate['extra-dark']};
    color: ${theme.base.colors.white};
    border-radius: calc(${theme.base['border-radius']} / 2);
    opacity: var(--opacity);
    transform: translateY(var(--translateY)) scale(var(--scale));
    transition-property: transform, opacity;
    transition-duration: ${theme.base.animation.speed};
    transition-timing-function: ${theme.base.animation.timing.ease};
  `;
});
StyledToast.defaultProps = defaultThemeProp;
const StyledToaster = styled.div `
  position: fixed;
  z-index: ${({ theme }) => theme.base['z-index'].toast};
  width: min(40ch, calc(100% - 1rem));
  inset-inline-start: 50%;
  transform: translateX(-50%);
  top: 100%;
`;
StyledToaster.defaultProps = defaultThemeProp;
function reducer(current, action) {
    switch (action.type) {
        case 'push':
            return [
                ...current,
                {
                    ...action.payload
                }
            ];
        case 'unmount':
            return current.filter(m => m.id !== action.payload);
        default:
            return current;
    }
}
const Toast = forwardRef(({ dispatch, topLevelDismiss, dismissAfter, ...message }, ref) => {
    const { content, translateY } = message;
    const [dismissed, setDismissed] = useState(false);
    const timeoutRef = useRef(NaN);
    const t = useI18n();
    const onTransitionEnd = (e) => {
        if (dismissed && e.propertyName === 'opacity' && e.target === e.currentTarget) {
            dispatch({ type: 'unmount', payload: message.id });
        }
    };
    const dismiss = () => {
        clearTimeout(timeoutRef.current);
        if (dismissed)
            return;
        setDismissed(true);
        topLevelDismiss?.({ id: message.id, timeout: false });
    };
    useEffect(() => {
        if (Number.isFinite(dismissAfter)) {
            timeoutRef.current = setTimeout(dismiss, dismissAfter);
        }
        return () => {
            clearTimeout(timeoutRef.current);
        };
    }, []);
    return (_jsxs(Flex, { container: { alignItems: 'center', gap: 0.25 }, as: StyledToast, ref: ref, style: {
            '--translateY': `${-translateY}px`,
            '--opacity': dismissed ? '0' : '1',
            '--scale': dismissed ? '0' : '1'
        }, onTransitionEnd: onTransitionEnd, children: [_jsx(Flex, { item: { grow: 1 }, as: StyledToastContent, children: content }), _jsx(Button, { as: StyledToastButton, variant: 'simple', onClick: dismiss, icon: true, "aria-label": t('dismiss_label'), children: _jsx(Icon, { name: 'times' }) })] }));
});
const Toaster = ({ children, dismissAfter = Infinity, onDismiss }) => {
    const { portalTarget } = useConfiguration();
    const [messages, dispatch] = useReducer(reducer, []);
    const [yOffsets, setYOffsets] = useState([]);
    const heightHashRef = useRef({});
    // This effect will cause a re-render with a translateY value set for each toast.
    useLayoutEffect(() => {
        const heights = [...messages].reverse().map(({ id }) => heightHashRef.current[id]);
        setYOffsets(heights
            .map((_, i) => heights.slice(0, i + 1).reduce((sum, cur) => sum + cur + 4, 0))
            .reverse());
    }, [messages.length]);
    const providerValue = useMemo(() => ({
        push(incoming) {
            const message = {
                ...incoming,
                id: incoming.id ?? createUID()
            };
            dispatch({
                type: 'push',
                payload: message
            });
        },
        initialized: true
    }), [onDismiss, dismissAfter]);
    // Don't create additional ToasterContext.Providers.
    const context = windowIsAvailable
        ? window.cosmos.toasterContext ?? ToasterContext
        : ToasterContext;
    const priorCtx = useContext(context);
    if (priorCtx.initialized) {
        return _jsx(context.Provider, { value: priorCtx, children: children });
    }
    return (_jsxs(_Fragment, { children: [_jsx(context.Provider, { value: providerValue, children: children }), !!messages.length &&
                portalTarget &&
                createPortal(_jsx(StyledToaster, { children: messages.map((message, i) => {
                        return (_createElement(Toast, { ...message, translateY: yOffsets[i] ?? 0, topLevelDismiss: onDismiss, dismissAfter: message.dismissAfter ?? dismissAfter, key: message.id, dispatch: dispatch, ref: el => {
                                if (el) {
                                    heightHashRef.current[message.id] = el.offsetHeight;
                                }
                                else {
                                    delete heightHashRef.current[message.id];
                                }
                            } }));
                    }) }), portalTarget)] }));
};
export default Toaster;
//# sourceMappingURL=Toaster.js.map