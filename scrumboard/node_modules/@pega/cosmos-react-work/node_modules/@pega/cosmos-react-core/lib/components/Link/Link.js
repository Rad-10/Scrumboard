import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { forwardRef, useState, useRef, useContext, useEffect } from 'react';
import styled, { css } from 'styled-components';
import { readableColor } from 'polished';
import Button from '../Button';
import Popover from '../Popover';
import BareButton from '../Button/BareButton';
import { defaultThemeProp } from '../../theme';
import { useBreakpoint, useConsolidatedRef, useI18n, useUID, useModalContext, useOS } from '../../hooks';
import { tryCatch } from '../../utils';
import { calculateFontSize } from '../../styles';
import AppShellContext from '../AppShell/AppShellContext';
import { Keyboard } from '../Badges';
import Text, { StyledText } from '../Text';
import { StyledKeyboard } from '../Badges/Keyboard';
import Flex from '../Flex';
export const StyledLinkPopover = styled.div(({ theme, preview }) => css `
    background-color: ${theme.components.tooltip['background-color']};
    ${preview &&
    css `
      padding: ${theme.base.spacing};
    `}
  `);
StyledLinkPopover.defaultProps = defaultThemeProp;
export const StyledLinkPopoverBtn = styled(BareButton)(({ theme }) => {
    const contrastColor = tryCatch(() => readableColor(theme.base.palette.interactive));
    const fontSize = calculateFontSize(theme.base['font-size'], theme.base['font-scale']);
    return css `
    position: relative;
    display: inline-flex;
    align-items: center;
    z-index: 1;
    padding: 0 ${theme.base.spacing};
    min-height: 1.5rem;
    line-height: 1;
    color: ${contrastColor};
    font-size: ${fontSize.xs};
    text-decoration: none;

    /* FIXME: Button selector specificity... */
    & + & {
      margin: 0;
    }

    & + &::before {
      content: '';
      position: absolute;
      inset-inline-start: 0;
      inset-block: 0;
      width: 1px; /* stylelint-disable-line unit-allowed-list */
      background-color: ${contrastColor};
      opacity: ${theme.base.transparency['transparent-3']};
    }

    &:hover,
    &:active {
      text-decoration: underline;
    }

    &:focus {
      box-shadow: inset 0 0 0 0.0625rem ${theme.base.palette.light},
        0 0 0.125rem 0.0625rem ${theme.base.palette.interactive};
    }
  `;
});
StyledLinkPopoverBtn.defaultProps = defaultThemeProp;
export const StyledLinkPreviewPopoverBtn = styled(StyledLinkPopoverBtn)(({ theme }) => {
    return css `
    width: 100%;
    padding: unset;

    &:hover,
    &:active {
      text-decoration: none;
      ${StyledText} span {
        text-decoration: underline;
      }
    }

    ${StyledText} {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
    }

    ${StyledKeyboard} {
      color: ${theme.base.palette.light};
      background-color: ${theme.base.colors.gray.dark};
      border-color: ${theme.base.colors.gray.medium};
      inset-block-start: unset;

      &:first-of-type {
        margin-inline: ${theme.base.spacing};
      }
    }
  `;
});
StyledLinkPreviewPopoverBtn.defaultProps = defaultThemeProp;
export const StyledLink = styled(Button) ``;
StyledLink.defaultProps = defaultThemeProp;
const Link = forwardRef(({ href, variant = 'link', previewable, onPreview, ...restProps }, ref) => {
    const { initialized: inModal } = useModalContext();
    const { previewTriggerRef } = useContext(AppShellContext);
    const uid = useUID();
    const linkRef = useConsolidatedRef(ref);
    const [popover, setPopover] = useState(false);
    const [popoverHideDelay, setPopoverHideDelay] = useState('short');
    const [previewPopover, setPreviewPopover] = useState(false);
    const previewBtnRef = useRef(null);
    const isSmallOrAbove = useBreakpoint('sm');
    const t = useI18n();
    const { macintosh } = useOS();
    const contextMenuOpened = useRef(false);
    const showPopover = () => {
        if (isSmallOrAbove) {
            setPopover(true);
            setPreviewPopover(false);
        }
    };
    const showPreviewPopover = () => {
        if (isSmallOrAbove && !popover && !contextMenuOpened.current)
            setPreviewPopover(true);
    };
    const hidePopover = () => {
        setPopover(false);
    };
    const hidePreviewPopover = () => {
        setPreviewPopover(false);
    };
    const onEnterLink = () => {
        if (previewable)
            showPopover();
    };
    const onFocusLink = () => {
        if (previewable)
            showPreviewPopover();
    };
    const onBlurLink = () => {
        contextMenuOpened.current = false;
        hidePreviewPopover();
    };
    const onPreviewClick = () => {
        previewTriggerRef.current = linkRef.current;
        onPreview?.({ href });
    };
    const onKeyUp = (e) => {
        if (e.getModifierState('Alt') && e.code === 'KeyP') {
            onPreviewClick();
        }
    };
    useEffect(() => {
        if (popoverHideDelay === 'none' && !popover && !previewPopover) {
            setPopoverHideDelay('short');
        }
    }, [popoverHideDelay, popover, previewPopover]);
    return (_jsxs(_Fragment, { children: [_jsx(StyledLink, { href: href, variant: variant, ref: linkRef, ...restProps, onMouseEnter: onEnterLink, onMouseLeave: hidePopover, onFocus: onFocusLink, onBlur: onBlurLink, onKeyUp: onKeyUp, onContextMenu: () => {
                    contextMenuOpened.current = true;
                    setPopoverHideDelay('none');
                    setPreviewPopover(false);
                    setPopover(false);
                }, "aria-describedby": previewable ? `${uid}-preview-instructions` : undefined }), !inModal && (_jsx(Popover, { show: previewPopover, groupId: 'link_preview', showDelay: 'short', hideDelay: popoverHideDelay, placement: 'bottom', target: linkRef.current, onMouseEnter: showPreviewPopover, onMouseLeave: hidePreviewPopover, as: StyledLinkPopover, arrow: true, preview: true, onHide: hidePreviewPopover, children: _jsx(StyledLinkPreviewPopoverBtn, { preview: true, type: 'button', ref: previewBtnRef, onClick: onPreviewClick, tabIndex: '-1', children: _jsxs(Text, { children: [_jsx("span", { children: t('preview') }), _jsxs(Flex, { container: { inline: true, justify: 'end' }, children: [_jsx(Keyboard, { keyName: 'Alt' }), _jsx(Keyboard, { keyName: 'P' })] })] }) }) })), _jsxs(Popover, { show: popover, groupId: 'link_preview', showDelay: 'short', hideDelay: popoverHideDelay, placement: 'bottom', target: linkRef.current, onMouseEnter: showPopover, onMouseLeave: hidePopover, as: StyledLinkPopover, arrow: true, children: [!inModal && (_jsx(StyledLinkPopoverBtn, { preview: true, type: 'button', ref: previewBtnRef, onClick: onPreviewClick, tabIndex: '-1', children: t('preview') })), _jsx(StyledLinkPopoverBtn, { forwardedAs: 'a', href: href, target: '_blank', rel: 'noreferrer', tabIndex: '-1', children: t('link_open_in_tab_text') })] }), previewable && (_jsx("span", { id: `${uid}-preview-instructions`, hidden: true, children: t('preview_link_instruction', [macintosh ? 'option' : 'alt']) }))] }));
});
export default Link;
//# sourceMappingURL=Link.js.map