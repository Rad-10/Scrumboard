import { jsx as _jsx } from "react/jsx-runtime";
import { forwardRef, useCallback, useEffect, useRef, useState } from 'react';
import styled, { css } from 'styled-components';
import { defaultThemeProp } from '../../theme';
import Popover from '../Popover';
import { useConsolidatedRef, useUID } from '../../hooks';
import { calculateFontSize } from '../../styles';
export const StyledTooltip = styled.div(({ theme }) => {
    const fontSize = calculateFontSize(theme.base['font-size'], theme.base['font-scale']);
    return css `
    background-color: ${theme.components.tooltip['background-color']};
    color: ${theme.components.tooltip['foreground-color']};
    font-size: ${fontSize.xxs};
    max-width: 40ch;
    padding: ${theme.base.spacing};
    white-space: pre-line;
    word-break: break-word;
    pointer-events: none;
    z-index: ${theme.base['z-index'].tooltip};
  `;
});
StyledTooltip.defaultProps = defaultThemeProp;
const Tooltip = forwardRef(({ children, target, showDelay = 'short', hideDelay = 'long', portal = true, placement = 'bottom', describeTarget = true, ...restProps }, ref) => {
    const id = useUID();
    const [show, setShow] = useState(false);
    const tooltipRef = useConsolidatedRef(ref);
    const lastClickedRef = useRef(null);
    const showTooltip = useCallback(() => {
        setShow(true);
    }, []);
    const onMouseDown = useCallback(({ target: eTarget }) => {
        lastClickedRef.current = eTarget;
        if (eTarget === tooltipRef.current || eTarget === target)
            return;
        setShow(false);
    }, [target]);
    const onFocusOut = useCallback(() => {
        if (lastClickedRef.current !== tooltipRef.current) {
            setShow(false);
        }
        lastClickedRef.current = null;
    }, []);
    const onMouseEnter = useCallback(() => {
        setShow(true);
    }, [target]);
    const onMouseLeave = useCallback(() => {
        if (document.activeElement !== target) {
            setShow(false);
        }
    }, [target]);
    const onKeyDown = useCallback(({ key }) => {
        if (key === 'Escape' && document.activeElement === target) {
            setShow(false);
        }
    }, [target]);
    useEffect(() => {
        if (!target)
            return;
        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('mousedown', onMouseDown);
        target.addEventListener('focusin', showTooltip);
        target.addEventListener('focusout', onFocusOut);
        target.addEventListener('mouseenter', onMouseEnter);
        target.addEventListener('mouseleave', onMouseLeave);
        return () => {
            document.removeEventListener('keydown', onKeyDown);
            document.removeEventListener('mousedown', onMouseDown);
            target.removeEventListener('focusin', showTooltip);
            target.removeEventListener('focusout', onFocusOut);
            target.removeEventListener('mouseenter', onMouseEnter);
            target.removeEventListener('mouseleave', onMouseLeave);
        };
    }, [target, showTooltip, onMouseDown, onFocusOut, onMouseLeave, onKeyDown]);
    useEffect(() => {
        if (target && describeTarget && show) {
            const describedBy = target.getAttribute('aria-describedby');
            // Set the attribute to the old attribute plus the id
            target.setAttribute('aria-describedby', describedBy ? `${describedBy} ${id}` : id);
        }
        else if (target) {
            // Get the old attribute
            const describedBy = target.getAttribute('aria-describedby');
            if (describedBy) {
                // If the old attribute matches the id just remove it entirely
                if (describedBy === id) {
                    target.removeAttribute('aria-describedby');
                }
                else {
                    // Otherwise we want to just remove the id that was added and reset the attribute to what it was before
                    const oldDescribedBy = describedBy.replace(new RegExp(`(?:^|\\s+)${id}`), '');
                    target.setAttribute('aria-describedby', oldDescribedBy);
                }
            }
        }
    }, [describeTarget, target, show]);
    return (_jsx(Popover, { id: id, ...restProps, show: show, showDelay: showDelay, hideDelay: hideDelay, groupId: 'tooltip', strategy: 'fixed', portal: portal, as: StyledTooltip, role: 'tooltip', target: target, arrow: true, placement: placement, onMouseDown: onMouseDown, hideOnTargetHidden: true, ref: tooltipRef, children: children }));
});
export default Tooltip;
//# sourceMappingURL=Tooltip.js.map