{"version":3,"file":"helpers.js","sourceRoot":"","sources":["../../../src/components/Tree/helpers.ts"],"names":[],"mappings":"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","sourcesContent":["import type { TreeNode } from './Tree';\n\nconst helpers = {\n  getNode<T extends TreeNode = TreeNode>(nodes: T[], id: T['id']): T | undefined {\n    let found;\n    nodes.some(node => {\n      if (node.id === id) {\n        found = node;\n        return true;\n      }\n\n      if (node.nodes) {\n        found = this.getNode(node.nodes, id);\n        return !!found;\n      }\n\n      return false;\n    });\n\n    return found;\n  },\n\n  getParentNode<T extends TreeNode = TreeNode>(nodes: T[], id: T['id']): T | undefined {\n    let found: T | undefined;\n    nodes.some(node => {\n      const childNodes = node.nodes || [];\n      childNodes.some(childNode => {\n        if (childNode.id === id) {\n          found = node;\n          return true;\n        }\n\n        if (childNode.nodes) {\n          found = this.getParentNode(childNodes, id) as T;\n          return !!found;\n        }\n\n        return false;\n      });\n\n      return !!found;\n    });\n\n    return found;\n  },\n\n  mapTree<T1 extends TreeNode = TreeNode, T2 extends TreeNode = T1>(\n    nodes: T1[],\n    fn: (node: T1, index: number, nodes: T1[]) => T2\n  ): T2[] {\n    return nodes.map((node, index, array) => {\n      let newNode = node;\n\n      if (node.nodes) {\n        newNode = {\n          ...newNode,\n          nodes: this.mapTree(node.nodes as T1[], fn)\n        };\n      }\n\n      return fn(newNode, index, array);\n    });\n  },\n\n  mapNode<T1 extends TreeNode = TreeNode, T2 extends TreeNode = T1>(\n    nodes: T1[],\n    id: T1['id'],\n    fn: (node: T1, index: number, array: T1[]) => T2\n  ): (T1 | T2)[] {\n    return nodes.map((node, index, array) => {\n      let newNode: T1 | T2 = node;\n\n      if (node.nodes) {\n        newNode = {\n          ...newNode,\n          nodes: this.mapNode(node.nodes as T1[], id, fn)\n        };\n      }\n\n      if (node.id === id) {\n        newNode = fn(newNode, index, array);\n      }\n\n      return newNode;\n    });\n  },\n\n  flatten<T extends TreeNode = TreeNode>(nodes: T[], ancestors?: T[]): (T & { ancestors?: T[] })[] {\n    return nodes.reduce<(T & { ancestors?: T[] })[]>((flatNodes, node) => {\n      if (node.nodes) {\n        return [\n          ...flatNodes,\n          node,\n          ...this.flatten(node.nodes as T[], ancestors ? [...ancestors, node] : [node])\n        ];\n      }\n\n      return [...flatNodes, ancestors ? { ...node, ancestors } : node];\n    }, []);\n  },\n\n  appendTo<T extends TreeNode = TreeNode>(nodes: T[], id: T['id'], newNodes: T[]): T[] {\n    if (id) {\n      return this.mapNode(nodes, id, node => ({\n        ...node,\n        nodes: [...(node.nodes ?? []), ...newNodes]\n      }));\n    }\n\n    return [...nodes, ...newNodes];\n  },\n\n  expandTo<T extends TreeNode = TreeNode>(nodes: T[], id: T['id']): T[] {\n    return nodes.map(node => {\n      // leaf node\n      if (node.id === id) {\n        return {\n          ...node,\n          expanded: true\n        };\n      }\n\n      // parent node\n      if (node.nodes && !!this.getNode(node.nodes, id)) {\n        return {\n          ...node,\n          nodes: this.expandTo(node.nodes, id),\n          expanded: true\n        };\n      }\n\n      return { ...node, expanded: false };\n    });\n  },\n\n  getFirstChildNode<T extends TreeNode = TreeNode>(nodes: T[], id: T['id']): T | undefined {\n    let firstChildNode;\n    const node = this.getNode(nodes, id);\n    if (node && node.expanded && node.nodes && node.nodes.length > 0) {\n      const childNodes = node.nodes as T[];\n      firstChildNode = childNodes[0];\n    }\n    return firstChildNode;\n  },\n\n  getAdjacentNode<T extends TreeNode = TreeNode>(nodes: T[], id: T['id']): T | undefined {\n    let nextNode;\n    const parent = this.getParentNode(nodes, id);\n    if (parent && parent.nodes && parent.nodes.length > 0) {\n      const childNodes = parent.nodes as T[];\n      const currentIndex = childNodes.map(nodeEl => nodeEl.id).indexOf(id);\n      if (currentIndex === childNodes.length - 1) {\n        nextNode = this.getAdjacentNode(nodes, parent.id);\n      } else {\n        nextNode = childNodes[currentIndex + 1];\n      }\n    } else {\n      const index = nodes.map(nodeEl => nodeEl.id).indexOf(id);\n      nextNode = nodes[index + 1];\n    }\n    return nextNode;\n  },\n\n  getNextNode<T extends TreeNode = TreeNode>(nodes: T[], id: T['id']): T | undefined {\n    let nextNode;\n    const firstChildNode = this.getFirstChildNode(nodes, id);\n    if (firstChildNode) {\n      nextNode = firstChildNode;\n    } else {\n      nextNode = this.getAdjacentNode(nodes, id);\n    }\n    return nextNode;\n  },\n\n  getDeepestNode<T extends TreeNode = TreeNode>(nodes: T[], id: T['id']): T | undefined {\n    const node = this.getNode(nodes, id);\n    let lastNode = node;\n    if (node && node.expanded && node.nodes && node.nodes.length > 0) {\n      const childNodes = node.nodes as T[];\n      const lastChildNode = childNodes[childNodes.length - 1];\n      if (lastChildNode.expanded) {\n        lastNode = this.getDeepestNode(nodes, lastChildNode.id);\n      } else {\n        lastNode = lastChildNode;\n      }\n    }\n    return lastNode;\n  },\n\n  getPreviousNode<T extends TreeNode = TreeNode>(nodes: T[], id: T['id']): T | undefined {\n    const parent = this.getParentNode(nodes, id);\n    let previousNode;\n    if (parent && parent.nodes && parent.nodes.length > 0) {\n      const childNodes = parent.nodes;\n      const currentIndex = childNodes.map(nodeEl => nodeEl.id).indexOf(id);\n      if (currentIndex === 0) {\n        previousNode = parent;\n      } else {\n        previousNode = this.getDeepestNode(nodes, childNodes[currentIndex - 1].id);\n      }\n    } else {\n      const index = nodes.map(node => node.id).indexOf(id);\n      if (nodes[index - 1]) previousNode = this.getDeepestNode(nodes, nodes[index - 1].id);\n    }\n    return previousNode;\n  }\n};\n\nexport default helpers;\n"]}