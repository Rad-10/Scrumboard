{"version":3,"file":"useScrollToggle.js","sourceRoot":"","sources":["../../src/hooks/useScrollToggle.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,WAAW,EAAE,eAAe,EAAE,MAAM,EAAE,MAAM,OAAO,CAAC;AAE7D,OAAO,EAAE,iBAAiB,EAAE,iBAAiB,EAAE,MAAM,UAAU,CAAC;AAEhE,OAAO,gBAAgB,MAAM,oBAAoB,CAAC;AAElD,MAAM,eAAe,GAAG,CAAC,WAAmB,OAAO,EAAE,EAAE;IACrD,MAAM,iBAAiB,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;IACpC,MAAM,QAAQ,GAAG,MAAM,CAA0B,IAAI,CAAC,CAAC;IACvD,MAAM,EAAE,gBAAgB,EAAE,GAAG,gBAAgB,EAAE,CAAC;IAEhD,MAAM,YAAY,GAAG,WAAW,CAAC,GAAS,EAAE;QAC1C,mGAAmG;QACnG,QAAQ,CAAC,OAAO,EAAE,MAAM,EAAE,CAAC;QAC3B,QAAQ,CAAC,OAAO,GAAG,IAAI,CAAC;IAC1B,CAAC,EAAE,EAAE,CAAC,CAAC;IAEP,MAAM,aAAa,GAAG,WAAW,CAAC,GAAS,EAAE;QAC3C,qHAAqH;QACrH,IAAI,QAAQ,CAAC,OAAO;YAAE,OAAO;QAC7B,MAAM,QAAQ,GAAG,QAAQ,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;QAClD,IAAI,CAAC,QAAQ;YAAE,OAAO;QACtB,MAAM,CAAC,SAAS,EAAE,SAAS,CAAC,GAAG,iBAAiB,CAAC,QAAQ,CAAC,CAAC;QAC3D,IAAI,CAAC,SAAS,IAAI,CAAC,SAAS;YAAE,OAAO;QAErC,QAAQ,CAAC,OAAO,GAAG,QAAQ,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;QAEnD,QAAQ,CAAC,OAAO,CAAC,WAAW,GAAG;QAC3B,QAAQ;UACN,SAAS,CAAC,CAAC,CAAC,uBAAuB,iBAAiB,CAAC,OAAO,eAAe,CAAC,CAAC,CAAC,EAAE;UAChF,SAAS,CAAC,CAAC,CAAC,sBAAsB,iBAAiB,CAAC,OAAO,eAAe,CAAC,CAAC,CAAC,EAAE;;;KAGpF,CAAC;QAEF,CAAC,gBAAgB,IAAI,QAAQ,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;IAC/D,CAAC,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC;IAEf,eAAe,CAAC,GAAG,EAAE;QACnB,iBAAiB,CAAC,OAAO,GAAG,iBAAiB,EAAE,CAAC;QAEhD,kCAAkC;QAClC,0FAA0F;QAC1F,OAAO,YAAY,CAAC;QAEpB,uIAAuI;IACzI,CAAC,EAAE,CAAC,YAAY,CAAC,CAAC,CAAC;IAEnB,OAAO,EAAE,YAAY,EAAE,aAAa,EAAE,CAAC;AACzC,CAAC,CAAC;AAEF,eAAe,eAAe,CAAC","sourcesContent":["import { useCallback, useLayoutEffect, useRef } from 'react';\n\nimport { getScrollbarWidth, testElForOverflow } from '../utils';\n\nimport useConfiguration from './useConfiguration';\n\nconst useScrollToggle = (selector: string = ':root') => {\n  const scrollbarWidthRef = useRef(0);\n  const styleRef = useRef<HTMLStyleElement | null>(null);\n  const { styleSheetTarget } = useConfiguration();\n\n  const enableScroll = useCallback((): void => {\n    // No need to short circuit if called repetitively, will just perform a simple null set on the ref.\n    styleRef.current?.remove();\n    styleRef.current = null;\n  }, []);\n\n  const disableScroll = useCallback((): void => {\n    // If we have a ref to the style el we can assume styles to disable overflow are in the DOM. No need for a DOM query.\n    if (styleRef.current) return;\n    const scrollEl = document.querySelector(selector);\n    if (!scrollEl) return;\n    const [overflowX, overflowY] = testElForOverflow(scrollEl);\n    if (!overflowX && !overflowY) return;\n\n    styleRef.current = document.createElement('style');\n\n    styleRef.current.textContent = `\n      ${selector} {\n        ${overflowY ? `padding-inline-end: ${scrollbarWidthRef.current}px !important` : ''};\n        ${overflowX ? `padding-block-end: ${scrollbarWidthRef.current}px !important` : ''};\n        overflow: hidden !important;\n      }\n    `;\n\n    (styleSheetTarget ?? document.head).append(styleRef.current);\n  }, [selector]);\n\n  useLayoutEffect(() => {\n    scrollbarWidthRef.current = getScrollbarWidth();\n\n    // cSpell:ignoreRegExp /unmounts?/\n    // To be safe, clean up when the calling component unmounts just in case it did not do so.\n    return enableScroll;\n\n    // As enableScroll is memoized with no deps, the cleanup **should** only run once on unmount. If that changes, adjust here accordingly.\n  }, [enableScroll]);\n\n  return { enableScroll, disableScroll };\n};\n\nexport default useScrollToggle;\n"]}