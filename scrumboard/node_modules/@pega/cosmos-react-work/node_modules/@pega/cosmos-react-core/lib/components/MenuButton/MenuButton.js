import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { forwardRef, useState, useCallback } from 'react';
import styled, { css } from 'styled-components';
import { defaultThemeProp } from '../../theme';
import { useConsolidatedRef, useUID, useFocusWithin, useDirection } from '../../hooks';
import Button, { StyledButton } from '../Button';
import Popover, { StyledPopover } from '../Popover';
import Menu from '../Menu';
import Icon, { registerIcon } from '../Icon';
import * as arrowMicroDownIcon from '../Icon/icons/arrow-micro-down.icon';
import Text from '../Text';
import { Count } from '../Badges';
registerIcon(arrowMicroDownIcon);
const StyledMenuButton = styled.button(({ theme: { base: { spacing } } }) => {
    return css `
      gap: ${spacing};
      flex-shrink: 0;
      white-space: nowrap;

      & + ${StyledPopover} + ${StyledButton} {
        margin-inline-start: ${spacing};
      }
    `;
});
StyledMenuButton.defaultProps = defaultThemeProp;
const StyledMenuButtonPopover = styled(Popover) `
  min-width: 20ch;
`;
const MenuButton = forwardRef((props, ref) => {
    const uid = useUID();
    const { id = uid, text, menu, popover, onClick, onKeyDown, icon, count, iconOnly = false, ...restProps } = props;
    const [isOpen, setIsOpen] = useState(false);
    const buttonRef = useConsolidatedRef(ref);
    const popoverRef = useConsolidatedRef(popover?.ref);
    const menuRef = useConsolidatedRef(menu?.ref);
    // FIXME: Type assertion required for issue in useFocusWithin generic
    useFocusWithin([popoverRef, buttonRef], useCallback(isFocused => {
        if (!isFocused)
            setIsOpen(false);
    }, []));
    const { rtl } = useDirection();
    return (_jsxs(_Fragment, { children: [_jsxs(Button, { as: StyledMenuButton, ...restProps, id: id, ref: buttonRef, "aria-expanded": isOpen, "aria-haspopup": 'menu', "aria-controls": `${id}-popover`, "aria-label": text, label: iconOnly && !isOpen ? text : undefined, onClick: (e) => {
                    // clickCount is 0 when triggered by keyboard.
                    const clickCount = e.detail;
                    // Close the menu if it is open and either:
                    //   It is a *mouse* click on the button.
                    //   Or, the menu mode is not multiselect.
                    if (isOpen && (clickCount > 0 || menu?.mode !== 'multi-select')) {
                        setIsOpen(false);
                    }
                    else {
                        setIsOpen(true);
                    }
                    onClick?.(e);
                }, onKeyDown: (e) => {
                    if (e.key === 'Escape')
                        setIsOpen(false);
                    onKeyDown?.(e);
                }, icon: iconOnly, children: [icon && _jsx(Icon, { name: icon }), !iconOnly && (_jsxs(Text, { children: [text, " ", count !== undefined && _jsx(Count, { children: count }), text && _jsx(Icon, { name: 'arrow-micro-down' })] }))] }), _jsx(StyledMenuButtonPopover, { placement: rtl ? 'bottom-end' : 'bottom-start', id: `${id}-popover`, ...popover, hideOnTargetHidden: true, show: !!menu && isOpen, target: buttonRef.current, ref: popoverRef, children: menu && (_jsx(Menu, { ...menu, ref: menuRef, items: menu.items, onItemClick: (itemId, e) => {
                        if (menu.mode !== 'multi-select' &&
                            e
                                .detail > 0) {
                            setIsOpen(false);
                        }
                        menu.onItemClick?.(itemId, e);
                    }, focusControlEl: buttonRef.current || undefined })) })] }));
});
export default MenuButton;
//# sourceMappingURL=MenuButton.js.map