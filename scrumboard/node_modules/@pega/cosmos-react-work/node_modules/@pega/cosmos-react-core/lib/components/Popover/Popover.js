import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { forwardRef, useContext, useRef, useEffect, useMemo, useState } from 'react';
import { createPortal } from 'react-dom';
import { usePopper } from 'react-popper';
import { useAfterInitialEffect, useConfiguration, useConsolidatedRef, useElement, useUID } from '../../hooks';
import { windowIsAvailable } from '../../utils';
import { PopoverManagerContext } from './PopoverContext';
import { StyledPopover, StyledPopoverContent, StyledPopoverArrow } from './Popover.styles';
import { applyMaxSize, maxSize } from './modifiers';
const delays = {
    none: 0,
    short: 500,
    long: 1000
};
const Popover = forwardRef(({ show = true, portal = false, target, placement, strategy = 'fixed', style, modifiers = [], arrow = false, groupId, showDelay = 'none', hideDelay = 'none', hideOnTargetHidden = false, children, onHide, ...restProps }, ref) => {
    const { portalTarget: configurationPortal } = useConfiguration();
    const { checkActive, setActive, popovers } = useContext(PopoverManagerContext);
    const [, setPopperEl] = useElement();
    const popperRef = useConsolidatedRef(ref, setPopperEl);
    const arrowRef = useRef(null);
    const forceUpdateRef = useRef();
    const [showPopover, setShowPopover] = useState(show);
    const timeout = useRef();
    const uid = useUID();
    const portalTarget = typeof portal === 'boolean' ? configurationPortal : portal;
    const memoedModifiers = useMemo(() => [
        {
            name: 'computeStyles',
            options: {
                gpuAcceleration: false
            }
        },
        {
            name: 'offset',
            options: {
                offset: [0, arrow ? 5.5 : 2]
            }
        },
        { name: 'hide', enabled: hideOnTargetHidden },
        { name: 'arrow', enabled: arrow, options: { element: arrowRef.current } },
        {
            name: 'preventOverflow',
            options: {
                tether: !modifiers.find(m => m.name === 'sameWidth')
            }
        },
        maxSize,
        applyMaxSize,
        ...modifiers
    ], [modifiers, arrow, hideOnTargetHidden]);
    const offset = useMemo(() => {
        const offsetModifier = [...memoedModifiers]
            .reverse()
            .find(m => m.name === 'offset' && m.enabled !== false);
        return Array.isArray(offsetModifier?.options?.offset)
            ? offsetModifier?.options?.offset[1] ?? 0
            : 0;
    }, [memoedModifiers]);
    const { styles, attributes, forceUpdate } = usePopper(target, popperRef.current, {
        placement,
        strategy,
        modifiers: memoedModifiers
    });
    if (forceUpdate)
        forceUpdateRef.current = forceUpdate;
    useEffect(() => {
        const observer = new ResizeObserver(() => {
            forceUpdateRef.current?.();
        });
        if (popperRef.current)
            observer.observe(popperRef.current);
        if (target instanceof Element)
            observer.observe(target);
        return () => {
            observer.disconnect();
        };
    }, [forceUpdate, popperRef.current, target]);
    useEffect(() => {
        if (groupId && show)
            setActive(uid, groupId);
        if (windowIsAvailable) {
            if (timeout.current)
                clearTimeout(timeout.current);
            timeout.current = window.setTimeout(() => {
                setShowPopover(show);
            }, delays[show ? showDelay : hideDelay]);
        }
        else {
            setShowPopover(show);
        }
    }, [show]);
    useEffect(() => {
        return () => clearTimeout(timeout.current);
    }, []);
    useAfterInitialEffect(() => {
        if (!showPopover) {
            onHide?.();
        }
    }, [showPopover]);
    useEffect(() => {
        if (groupId && popovers[groupId] && popovers[groupId] !== uid) {
            setShowPopover(false);
        }
    }, [groupId ? popovers[groupId] : undefined]);
    const content = (_jsxs(StyledPopover, { ...restProps, offset: offset, ref: popperRef, style: { ...style, ...styles.popper }, ...attributes.popper, children: [arrow && _jsx(StyledPopoverArrow, { ref: arrowRef, style: { ...styles.arrow } }), _jsx(StyledPopoverContent, { children: children })] }));
    if (!target || !showPopover || (groupId && !checkActive(uid, groupId)))
        return null;
    return portal && portalTarget ? createPortal(content, portalTarget) : content;
});
export default Popover;
//# sourceMappingURL=Popover.js.map