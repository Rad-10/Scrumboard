var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Stickers_scrollDebounce, _Stickers_resizeDebounce, _Stickers_isWindowScroll, _Stickers_scrollIntervalStart, _Stickers_scrollIntervalChange, _Stickers_scrollDirection, _Stickers_priorScrollY, _Stickers_resizeTimeout, _Stickers_scrollEndTimeout, _Stickers_isScrolling, _Stickers_vpHeightSnapshot, _Stickers_sfHeightSnapshot, _Stickers_stickers, _Stickers_scrollHandler, _Stickers_resizeHandler;
import { useRef, useLayoutEffect } from 'react';
const onBeforeunload = () => {
    window.scrollTo(0, 0);
};
class Stickers {
    constructor({ elements, scrollContainer = window, offset = 0 }) {
        Object.defineProperty(this, "scrollContainer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "offset", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        _Stickers_scrollDebounce.set(this, void 0);
        _Stickers_resizeDebounce.set(this, void 0);
        _Stickers_isWindowScroll.set(this, void 0);
        _Stickers_scrollIntervalStart.set(this, void 0);
        _Stickers_scrollIntervalChange.set(this, void 0);
        _Stickers_scrollDirection.set(this, void 0);
        _Stickers_priorScrollY.set(this, void 0);
        _Stickers_resizeTimeout.set(this, void 0);
        _Stickers_scrollEndTimeout.set(this, void 0);
        _Stickers_isScrolling.set(this, void 0);
        _Stickers_vpHeightSnapshot.set(this, void 0);
        _Stickers_sfHeightSnapshot.set(this, void 0);
        _Stickers_stickers.set(this, void 0);
        _Stickers_scrollHandler.set(this, void 0);
        _Stickers_resizeHandler.set(this, void 0);
        this.scrollContainer = scrollContainer;
        this.offset = offset;
        __classPrivateFieldSet(this, _Stickers_scrollDebounce, 100, "f");
        __classPrivateFieldSet(this, _Stickers_resizeDebounce, 300, "f");
        __classPrivateFieldSet(this, _Stickers_resizeTimeout, NaN, "f");
        __classPrivateFieldSet(this, _Stickers_scrollEndTimeout, NaN, "f");
        __classPrivateFieldSet(this, _Stickers_priorScrollY, NaN, "f");
        __classPrivateFieldSet(this, _Stickers_isScrolling, false, "f");
        __classPrivateFieldSet(this, _Stickers_vpHeightSnapshot, NaN, "f");
        __classPrivateFieldSet(this, _Stickers_sfHeightSnapshot, NaN, "f");
        __classPrivateFieldSet(this, _Stickers_scrollHandler, () => { }, "f");
        __classPrivateFieldSet(this, _Stickers_resizeHandler, () => { }, "f");
        __classPrivateFieldSet(this, _Stickers_isWindowScroll, this.scrollContainer === window, "f");
        // Only gets reset after scroll stop timeout fires
        __classPrivateFieldSet(this, _Stickers_scrollIntervalStart, this.getScrollY(), "f");
        // Used to determine scroll change within debounced scroll handler
        __classPrivateFieldSet(this, _Stickers_scrollIntervalChange, 0, "f");
        // Used to determine scroll direction by +1(page down) -1(page up)
        __classPrivateFieldSet(this, _Stickers_scrollDirection, 0, "f");
        __classPrivateFieldSet(this, _Stickers_stickers, this.setStickers(elements), "f");
        this.snapshotItemRects();
        this.addHandlers();
    }
    setStickers(elements) {
        __classPrivateFieldSet(this, _Stickers_stickers, (typeof elements === 'string'
            ? Array.from(document.querySelectorAll(elements))
            : elements).map(element => ({
            element,
            isStuck: false,
            top: NaN,
            bottom: NaN,
            height: NaN,
            priorStickHeight: NaN
        })), "f");
        return __classPrivateFieldGet(this, _Stickers_stickers, "f");
    }
    addHandlers() {
        this.rmHandlers();
        __classPrivateFieldSet(this, _Stickers_scrollHandler, this.onScroll.bind(this), "f");
        __classPrivateFieldSet(this, _Stickers_resizeHandler, this.onResize.bind(this), "f");
        this.scrollContainer.addEventListener('scroll', __classPrivateFieldGet(this, _Stickers_scrollHandler, "f"));
        window.addEventListener('resize', __classPrivateFieldGet(this, _Stickers_resizeHandler, "f"));
        // Not sure we need this. Maybe when DOM was persisted...
        window.addEventListener('beforeunload', onBeforeunload);
    }
    rmHandlers() {
        this.scrollContainer.removeEventListener('scroll', __classPrivateFieldGet(this, _Stickers_scrollHandler, "f"));
        window.removeEventListener('resize', __classPrivateFieldGet(this, _Stickers_resizeHandler, "f"));
        window.removeEventListener('beforeunload', onBeforeunload);
    }
    snapshotItemRects() {
        __classPrivateFieldGet(this, _Stickers_stickers, "f").forEach(sticker => {
            const rect = sticker.element.getBoundingClientRect();
            sticker.top = rect.top;
            sticker.bottom = rect.bottom;
            sticker.height = rect.height;
        });
    }
    onScroll() {
        clearTimeout(__classPrivateFieldGet(this, _Stickers_scrollEndTimeout, "f"));
        const currentScrollY = this.getScrollY();
        __classPrivateFieldSet(this, _Stickers_priorScrollY, !Number.isNaN(__classPrivateFieldGet(this, _Stickers_priorScrollY, "f"))
            ? __classPrivateFieldGet(this, _Stickers_priorScrollY, "f")
            : __classPrivateFieldGet(this, _Stickers_scrollIntervalStart, "f"), "f");
        // Diff between priorScrollY and new currentScrollY to determine direction
        __classPrivateFieldSet(this, _Stickers_scrollDirection, currentScrollY - __classPrivateFieldGet(this, _Stickers_priorScrollY, "f") > 0 ? 1 : -1, "f");
        // How much scroll changed + or - within the debounce interval
        __classPrivateFieldSet(this, _Stickers_scrollIntervalChange, currentScrollY - __classPrivateFieldGet(this, _Stickers_scrollIntervalStart, "f"), "f");
        // Update old to new for next scroll event
        __classPrivateFieldSet(this, _Stickers_priorScrollY, currentScrollY, "f");
        // When scrolling has stopped
        __classPrivateFieldSet(this, _Stickers_scrollEndTimeout, window.setTimeout(() => {
            // Reset for next scroll starting point
            __classPrivateFieldSet(this, _Stickers_scrollIntervalStart, __classPrivateFieldGet(this, _Stickers_priorScrollY, "f"), "f");
            // Reset until next scroll
            __classPrivateFieldSet(this, _Stickers_vpHeightSnapshot, NaN, "f");
            __classPrivateFieldSet(this, _Stickers_sfHeightSnapshot, NaN, "f");
            __classPrivateFieldSet(this, _Stickers_isScrolling, false, "f");
        }, __classPrivateFieldGet(this, _Stickers_scrollDebounce, "f")), "f");
        // Additional scroll calls always have to test for stick state change
        if (__classPrivateFieldGet(this, _Stickers_isScrolling, "f")) {
            this.testForStick();
            return;
        }
        // Only reaches here on first call and we note as in a scrolling state
        __classPrivateFieldSet(this, _Stickers_isScrolling, true, "f");
        // grab the current rect points for stickers to test against while scrolling
        this.snapshotItemRects();
        /**
         * Get once and cache until scroll settles
         * Unlikely to change and avoids additional reflows on scroll
         */
        __classPrivateFieldSet(this, _Stickers_vpHeightSnapshot, this.getViewportHeight(), "f");
        __classPrivateFieldSet(this, _Stickers_sfHeightSnapshot, this.getScrollFrameHeight(), "f");
        this.testForStick();
    }
    onResize() {
        clearTimeout(__classPrivateFieldGet(this, _Stickers_resizeTimeout, "f"));
        __classPrivateFieldSet(this, _Stickers_resizeTimeout, window.setTimeout(() => {
            this.snapshotItemRects();
            __classPrivateFieldGet(this, _Stickers_stickers, "f").forEach(sticker => {
                if (sticker.isStuck)
                    this.addStick(sticker);
            });
        }, __classPrivateFieldGet(this, _Stickers_resizeDebounce, "f")), "f");
    }
    getScrollY() {
        return __classPrivateFieldGet(this, _Stickers_isWindowScroll, "f")
            ? this.scrollContainer.scrollY
            : this.scrollContainer.scrollTop;
    }
    getViewportHeight() {
        // If we have a height snapshot use it since this has likely been called on scroll
        if (!Number.isNaN(__classPrivateFieldGet(this, _Stickers_vpHeightSnapshot, "f"))) {
            return __classPrivateFieldGet(this, _Stickers_vpHeightSnapshot, "f");
        }
        return Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    }
    getScrollFrameHeight() {
        // If we have a height snapshot use it since this has likely been called on scroll
        if (!Number.isNaN(__classPrivateFieldGet(this, _Stickers_sfHeightSnapshot, "f"))) {
            return __classPrivateFieldGet(this, _Stickers_sfHeightSnapshot, "f");
        }
        const viewportHeight = this.getViewportHeight();
        let sfh = viewportHeight;
        if (!__classPrivateFieldGet(this, _Stickers_isWindowScroll, "f")) {
            sfh = viewportHeight - this.scrollContainer.getBoundingClientRect().top;
        }
        return sfh;
    }
    testBottomInView(sticker) {
        const vph = this.getViewportHeight();
        const sfh = this.getScrollFrameHeight();
        const sic = __classPrivateFieldGet(this, _Stickers_scrollIntervalChange, "f");
        return sfh + sic + (vph - sfh) >= sticker.bottom + this.offset;
    }
    testForStick() {
        // Don't do anything if scrolling up
        if (__classPrivateFieldGet(this, _Stickers_scrollDirection, "f") === -1)
            return;
        __classPrivateFieldGet(this, _Stickers_stickers, "f").forEach(sticker => {
            const bottomIsInView = this.testBottomInView(sticker);
            const hasHeightChange = !Number.isNaN(sticker.priorStickHeight) && sticker.height !== sticker.priorStickHeight;
            if (bottomIsInView) {
                if (!sticker.isStuck || hasHeightChange) {
                    window.requestAnimationFrame(() => this.addStick(sticker));
                }
            }
            else if (sticker.isStuck && hasHeightChange) {
                const marginTop = this.getScrollY() + sticker.top - this.offset;
                window.requestAnimationFrame(() => {
                    this.removeStick(sticker);
                    sticker.element.style.marginTop = `${marginTop}px`;
                });
            }
        });
        return this;
    }
    addStick(sticker) {
        sticker.element.style.position = 'sticky';
        sticker.element.style.marginTop = '';
        sticker.element.style.top = `${this.getStickTop(sticker)}px`;
        sticker.priorStickHeight = sticker.height;
        sticker.isStuck = true;
        return this;
    }
    removeStick(sticker) {
        sticker.element.style.position = '';
        sticker.element.style.marginTop = '';
        sticker.element.style.top = '';
        sticker.isStuck = false;
        return this;
    }
    getStickTop(sticker) {
        const spHeight = this.getScrollFrameHeight();
        let offset = this.offset;
        if (sticker.height + this.offset > spHeight) {
            offset = spHeight - sticker.height - offset;
        }
        return offset;
    }
    cleanup() {
        this.rmHandlers();
        __classPrivateFieldGet(this, _Stickers_stickers, "f").forEach(this.removeStick);
    }
}
_Stickers_scrollDebounce = new WeakMap(), _Stickers_resizeDebounce = new WeakMap(), _Stickers_isWindowScroll = new WeakMap(), _Stickers_scrollIntervalStart = new WeakMap(), _Stickers_scrollIntervalChange = new WeakMap(), _Stickers_scrollDirection = new WeakMap(), _Stickers_priorScrollY = new WeakMap(), _Stickers_resizeTimeout = new WeakMap(), _Stickers_scrollEndTimeout = new WeakMap(), _Stickers_isScrolling = new WeakMap(), _Stickers_vpHeightSnapshot = new WeakMap(), _Stickers_sfHeightSnapshot = new WeakMap(), _Stickers_stickers = new WeakMap(), _Stickers_scrollHandler = new WeakMap(), _Stickers_resizeHandler = new WeakMap();
/**
 * @example useScrollStick({ elements: [myColumnElements] | '.my-columns', offset: 20 });
 * @param options An object to set the sticky elements, the scroll container and an stuck offset in pixels.
 * @returns void.
 */
const useScrollStick = (options) => {
    const instance = useRef();
    useLayoutEffect(() => {
        if (options?.elements) {
            instance.current = new Stickers(options);
        }
        return () => {
            instance.current?.cleanup();
            instance.current = undefined;
        };
    }, [options]);
};
export default useScrollStick;
//# sourceMappingURL=useScrollStick.js.map