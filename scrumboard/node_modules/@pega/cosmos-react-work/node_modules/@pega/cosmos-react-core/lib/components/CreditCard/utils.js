import creditCardType, { getTypeInfo } from 'credit-card-type';
const prettyPrintCard = (value, gaps) => {
    const offsets = [0].concat(gaps.filter(n => n < value.length), value.length);
    const groups = [];
    for (let i = 0; offsets[i] < value.length; i += 1) {
        groups.push(value.substring(offsets[i], offsets[i + 1]));
    }
    return groups.join(' ');
};
/**
 * Returns a formatted and obfuscated on demand partial credit card number.
 * @param value starting, partial number.
 * @param formattingOptions additional formatting options
 */
export const formatCreditCard = (value, { obfuscation = 'none' } = {}) => {
    let result;
    switch (obfuscation) {
        case 'none':
            result = prettyPrintCard(value, creditCardType(value)[0]?.gaps ?? []);
            break;
        case 'partial':
            result = prettyPrintCard(value.slice(-4).padStart(16, '•'), [4, 8, 12]);
            break;
        default:
            result = Array.from({ length: 4 }).fill('•'.repeat(4)).join(' ');
    }
    return result;
};
/** Returns maximum total length of formatted credit card of given type including gaps. */
export const creditCardTotalLength = (cardType) => {
    const type = getTypeInfo(cardType);
    return Math.max(...type.lengths) + type.gaps.length;
};
/** Returns true if given first numbers match a pattern of any card, false otherwise.  */
export const isPossibleCardNumber = (cardNumber) => {
    return creditCardType(cardNumber).length > 0;
};
/** Returns true if given card number is valid (matches the pattern and length of a card type), false otherwise. */
export const isValidCreditCard = (cardNumber) => {
    return (creditCardType(cardNumber.toString())[0]?.lengths.includes(cardNumber.toString().length) ??
        false);
};
//# sourceMappingURL=utils.js.map