import { useState, useEffect, useCallback, useRef } from 'react';
import { normalizeElements } from '../utils';
/** Hook for properly handling focus state of children components.
 * @example const hasFocus = useFocusWithin([containerRef, ...], (isFocused, element) => { doSomething; });
 * @param onFocusChange Callback function that is invoked with the current focus state and the current element when any child elements takes focus or all of them lose focus.
 * @returns * hasFocus:: A boolean indicating if the ref element has focus or not.
 */
const useFocusWithin = (els, onFocusChange) => {
    const [hasFocus, setFocus] = useState(false);
    const focusedElRef = useRef(null);
    const handlerAbortControllerRef = useRef();
    useEffect(() => {
        return () => {
            handlerAbortControllerRef.current?.abort();
        };
    }, []);
    const onBlur = useCallback(({ relatedTarget }) => {
        if (!hasFocus)
            return;
        const elements = normalizeElements(els);
        if (relatedTarget instanceof Node) {
            // changing focus to another relevant child doesn't count
            const focusedEl = elements.find(el => el?.contains(relatedTarget));
            if (focusedEl) {
                // ... just update the currently focused item
                focusedElRef.current = focusedEl;
                return;
            }
        }
        // Code below is similar to the useOuterEvent hook, but single-shot only and need to be attached
        // after blur event only. Due to various order of events between browsers and OSes, we need to
        // postpone calling 'onBlur' callback until next element gets focus or on outer click to check
        // if the relevant element contains the target element, which means the focus is retained.
        const handlerAbortController = new AbortController();
        const handler = (e) => {
            if (!elements.some(el => {
                return el?.contains(e.target);
            })) {
                setFocus(false);
                onFocusChange?.(false, focusedElRef.current);
                focusedElRef.current = null;
            }
            handlerAbortController.abort();
        };
        // For keyboard and SR navigation - wait for 'focusin'.
        document.addEventListener('focusin', handler, {
            once: true,
            signal: handlerAbortController.signal
        });
        // For mouse and touch navigation - wait for 'mouseup'.
        // The chosen event need to occur before 'click' to allow the given callback code finish before
        // 'click' handlers.
        document.addEventListener('mouseup', handler, {
            once: true,
            signal: handlerAbortController.signal
        });
        handlerAbortControllerRef.current = handlerAbortController;
    }, [hasFocus, onFocusChange, els]);
    const onFocus = useCallback(({ currentTarget }) => {
        if (!hasFocus) {
            setFocus(true);
            const targetEl = currentTarget;
            onFocusChange?.(true, targetEl);
            focusedElRef.current = targetEl;
        }
    }, [hasFocus, onFocusChange]);
    useEffect(() => {
        const elements = normalizeElements(els);
        elements.forEach(el => {
            el?.addEventListener('focusin', onFocus);
            el?.addEventListener('focusout', onBlur);
        });
        return () => {
            elements.forEach(el => {
                el?.removeEventListener('focusin', onFocus);
                el?.removeEventListener('focusout', onBlur);
            });
        };
    }, [els, onFocus, onBlur]);
    return hasFocus;
};
export default useFocusWithin;
//# sourceMappingURL=useFocusWithin.js.map