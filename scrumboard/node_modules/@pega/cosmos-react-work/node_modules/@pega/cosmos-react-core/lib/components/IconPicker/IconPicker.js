import { jsx as _jsx, Fragment as _Fragment } from "react/jsx-runtime";
import { forwardRef, useState, useCallback, useRef, useEffect } from 'react';
import ComboBox from '../ComboBox';
import icons from '../Icon/iconNames';
import Icon from '../Icon';
import { menuHelpers } from '../Menu';
import { useI18n } from '../../hooks';
import { createStringMatcher } from '../../utils';
const getFilteredItems = (iconList, filterValue) => {
    if (!filterValue)
        return iconList;
    const regExp = createStringMatcher(filterValue);
    return iconList.filter(({ primary }) => regExp.test(primary));
};
const iconList = icons.map(icon => {
    return {
        id: icon,
        primary: icon,
        visual: _jsx(Icon, { name: icon }),
        selected: false
    };
});
const pageSize = 20;
const IconPicker = forwardRef((props, ref) => {
    const { defaultSelection, scrollAt, onSelect, ...restProps } = props;
    const [items, setItems] = useState(() => iconList.slice(0, pageSize));
    const [isLoading, setIsLoading] = useState(false);
    const [hasMore, setHasMore] = useState(true);
    const [selectedIcon, setSelectedIcon] = useState(defaultSelection ?? '');
    const [filterValue, setFilterValue] = useState('');
    const t = useI18n();
    const loadMoreTimeoutId = useRef();
    const resetItems = useCallback(() => {
        const filteredItems = getFilteredItems(iconList, filterValue);
        setItems(menuHelpers.selectItem(filteredItems.slice(0, pageSize), selectedIcon, 'single-select'));
        setHasMore(filteredItems.length > pageSize);
    }, [filterValue, selectedIcon]);
    useEffect(() => {
        resetItems();
    }, [filterValue, selectedIcon]);
    useEffect(() => {
        return () => {
            if (loadMoreTimeoutId.current)
                clearTimeout(loadMoreTimeoutId.current);
        };
    }, []);
    const loadMore = useCallback(() => {
        if (!isLoading) {
            setIsLoading(true);
            if (loadMoreTimeoutId.current)
                clearTimeout(loadMoreTimeoutId.current);
            loadMoreTimeoutId.current = setTimeout(() => {
                setIsLoading(false);
                setItems(prevItems => {
                    const newItems = menuHelpers.mapTree(getFilteredItems(iconList, filterValue).slice(prevItems.length, prevItems.length + pageSize), item => ({
                        ...item,
                        selected: item.items ? undefined : selectedIcon === item.id
                    }));
                    if (newItems.length === 0)
                        setHasMore(false);
                    return menuHelpers.appendTo(prevItems, newItems);
                });
            }, 500);
        }
    }, [filterValue, isLoading]);
    const selectItem = useCallback((iconName) => {
        setSelectedIcon(iconName);
        setFilterValue('');
        onSelect?.(iconName);
    }, [onSelect]);
    const clearSelection = useCallback(() => {
        setSelectedIcon('');
        setItems(cur => menuHelpers.mapTree(cur, item => {
            return {
                ...item,
                selected: false
            };
        }));
    }, []);
    return (_jsx(ComboBox, { ...restProps, ref: ref, selected: selectedIcon
            ? {
                items: {
                    id: selectedIcon,
                    text: selectedIcon
                }
            }
            : undefined, value: filterValue, onChange: (e) => {
            if (!e.target.value)
                clearSelection();
            setFilterValue(e.target.value);
        }, onBlur: () => {
            resetItems();
            setFilterValue('');
        }, menu: {
            items,
            onItemClick: selectItem,
            scrollAt,
            accent: filterValue ? createStringMatcher(filterValue) : undefined,
            emptyText: t('no_items'),
            loading: isLoading,
            loadMore: hasMore ? loadMore : undefined
        }, visual: selectedIcon ? _jsx(Icon, { name: selectedIcon }) : _jsx(_Fragment, {}) }));
});
export default IconPicker;
//# sourceMappingURL=IconPicker.js.map