import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { forwardRef, createContext, useMemo, useContext, useCallback, useState } from 'react';
import Progress from '../Progress';
import { useDirection } from '../../hooks';
import Flex from '../Flex';
import Button from '../Button';
import Actions from '../Actions';
import { cap } from '../../utils';
import { StyledStandardTreeParent, StyledToggleIcon, StyledStandardTreeItemSubTree, StyledStandardTreeLeaf, StyledStandardTree, StyledNodeInteraction, StyledStandardTreeNode, StyledNodeActions, StyledLabelContent, StyledNodeIcon, StyledNodeText } from './StandardTree.styles';
import helpers from './helpers';
const StandardTreeContext = createContext({
    currentNodeId: undefined,
    lined: false,
    onNodeClick: () => { },
    onNodeToggle: () => { },
    firstNodeId: undefined,
    lastNodeId: undefined,
    focusedNodeId: undefined,
    changeFocusedNodeId: () => { }
});
const NodeRenderer = ({ id, label, icon, depth, hasParentSibling, nodes, expanded = false, loading = false, subTree, actions, onClick }) => {
    const { currentNodeId, onNodeClick, onNodeToggle, lined, focusedNodeId, changeFocusedNodeId, firstNodeId, lastNodeId } = useContext(StandardTreeContext);
    const current = currentNodeId === id;
    const focusedEl = focusedNodeId === id;
    const firstNode = firstNodeId === id;
    const { start, end } = useDirection();
    const tabIndex = useMemo(() => {
        let index = -1;
        if (focusedNodeId) {
            index = focusedEl ? 0 : -1;
        }
        else if (currentNodeId) {
            index = current ? 0 : -1;
        }
        else {
            index = firstNode ? 0 : -1;
        }
        return index;
    }, [focusedNodeId, currentNodeId, current, focusedEl]);
    const handleToggleClick = useCallback((e) => {
        onNodeClick?.(id, e);
        changeFocusedNodeId(id);
    }, [id, onNodeClick, changeFocusedNodeId]);
    const onKeyDown = useCallback((e) => {
        if (['ArrowUp', 'ArrowDown', 'Enter', 'Home', 'End'].includes(e.key))
            e.preventDefault();
        switch (e.key) {
            case 'ArrowUp':
                changeFocusedNodeId(id, 'up');
                break;
            case 'ArrowDown':
                changeFocusedNodeId(id, 'down');
                break;
            case `Arrow${cap(end)}`:
                if (nodes) {
                    if (expanded) {
                        changeFocusedNodeId(id, 'right');
                    }
                    else {
                        onNodeToggle?.(id);
                    }
                }
                break;
            case `Arrow${cap(start)}`:
                if (expanded) {
                    onNodeToggle?.(id);
                }
                else {
                    changeFocusedNodeId(id, 'left');
                }
                break;
            case 'Enter':
                if (onClick) {
                    onClick(id, e);
                }
                else {
                    handleToggleClick(e);
                }
                break;
            case 'Home':
                if (firstNodeId)
                    changeFocusedNodeId(firstNodeId);
                break;
            case 'End':
                if (lastNodeId)
                    changeFocusedNodeId(lastNodeId);
                break;
            default:
        }
    }, [id, end, nodes, expanded, actions, firstNodeId, lastNodeId, changeFocusedNodeId]);
    const actionsJSX = useMemo(() => {
        // since Actions may render a frag of buttons and we need a wrapper for flex space-between.
        return actions ? (_jsx(StyledNodeActions, { children: _jsx(Actions, { items: actions.map(action => {
                    return {
                        ...action,
                        onClick: (actionId, e) => {
                            e.stopPropagation();
                            action?.onClick?.(actionId, e);
                        }
                    };
                }), menuAt: 3, menuButtonProps: {
                    onClick: (e) => e.stopPropagation(),
                    onKeyDown: (e) => {
                        e.stopPropagation();
                        if (['ArrowUp', 'ArrowDown'].includes(e.key)) {
                            e.preventDefault();
                        }
                    }
                } }) })) : null;
    }, [actions]);
    const labelContent = useMemo(() => {
        const internal = (
        // Wrapping in a div for handling of flex space-between when there are node actions.
        _jsxs(Flex, { container: { alignItems: 'center', gap: 0.5 }, as: StyledLabelContent, children: [icon && _jsx(StyledNodeIcon, { name: icon }), _jsx(StyledNodeText, { children: label })] }));
        return !nodes && (onClick ?? onNodeClick) ? (_jsxs(Flex, { container: { alignItems: 'center', justify: 'between', gap: 2 }, as: StyledNodeInteraction, role: 'treeitem', "aria-current": current ? 'true' : undefined, tabIndex: tabIndex, onClick: (e) => {
                onClick?.(id, e);
                onNodeClick?.(id, e);
                changeFocusedNodeId(id);
            }, onKeyDown: onKeyDown, ref: focusedEl ? (focusedRef) => focusedRef?.focus() : undefined, children: [internal, actionsJSX] })) : (internal);
    }, [
        id,
        label,
        icon,
        nodes,
        actions,
        onClick,
        onNodeClick,
        current,
        focusedEl,
        tabIndex,
        changeFocusedNodeId,
        onKeyDown
    ]);
    return (_jsx(StyledStandardTreeNode, { id: id, style: { '--depth': depth, '--has-parent-sibling': Number(hasParentSibling) }, "aria-busy": loading, children: nodes ? (_jsxs(_Fragment, { children: [_jsxs(Flex, { container: { alignItems: 'center', justify: 'between', gap: 2 }, as: StyledStandardTreeParent, role: 'treeitem', "aria-current": current ? 'true' : undefined, tabIndex: tabIndex, variant: 'text', onClick: handleToggleClick, "aria-expanded": expanded ? 'true' : 'false', "aria-label": label, onKeyDown: onKeyDown, ref: focusedEl ? (focusedElRef) => focusedElRef?.focus() : undefined, children: [_jsxs(Flex, { container: { alignItems: 'center', gap: 0.5 }, as: 'span', children: [_jsx(Button, { variant: 'simple', icon: true, compact: true, onClick: (e) => {
                                        if (onNodeToggle) {
                                            e.stopPropagation();
                                            onNodeToggle(id, e);
                                            changeFocusedNodeId(id);
                                        }
                                    }, children: _jsx(StyledToggleIcon, { name: 'caret-right' }) }), labelContent] }), actionsJSX] }), _jsxs(StyledStandardTreeItemSubTree, { lined: lined, children: [subTree, loading && _jsx(Progress, { variant: 'ring', placement: 'inline' })] })] })) : (_jsx(StyledStandardTreeLeaf, { children: labelContent })) }));
};
const StandardTreeWithNodes = forwardRef(({ nodes, currentNodeId, onNodeClick, onNodeToggle, lined = false, ...restProps }, ref) => {
    const [focusedNodeId, setFocusedNodedId] = useState();
    const lastNodeId = useMemo(() => {
        return helpers.getDeepestNode(nodes, nodes[nodes.length - 1].id)?.id;
    }, [nodes]);
    const changeFocusedNodeId = useCallback((id, type) => {
        switch (type) {
            case 'up': {
                const previousNode = helpers.getPreviousNode(nodes, id);
                if (previousNode)
                    setFocusedNodedId(previousNode.id);
                break;
            }
            case 'down': {
                const nextNode = helpers.getNextNode(nodes, id);
                if (nextNode)
                    setFocusedNodedId(nextNode.id);
                break;
            }
            case 'left': {
                const parentNode = helpers.getParentNode(nodes, id);
                if (parentNode)
                    setFocusedNodedId(parentNode.id);
                break;
            }
            case 'right': {
                const childNode = helpers.getFirstChildNode(nodes, id);
                if (childNode)
                    setFocusedNodedId(childNode.id);
                break;
            }
            default:
                setFocusedNodedId(id);
        }
    }, [nodes]);
    return (_jsx(StandardTreeContext.Provider, { value: useMemo(() => ({
            currentNodeId,
            focusedNodeId,
            lastNodeId,
            firstNodeId: nodes[0].id,
            changeFocusedNodeId,
            onNodeClick,
            onNodeToggle,
            lined
        }), [currentNodeId, onNodeClick, lined, focusedNodeId, lastNodeId, onNodeToggle]), children: _jsx(StyledStandardTree, { ...restProps, ref: ref, nodes: nodes, nodeRenderer: NodeRenderer }) }));
});
const StandardTree = forwardRef((props, ref) => {
    return props.nodes.length > 0 ? _jsx(StandardTreeWithNodes, { ...props, ref: ref }) : null;
});
export default StandardTree;
//# sourceMappingURL=StandardTree.js.map