import { jsx as _jsx } from "react/jsx-runtime";
import { forwardRef } from 'react';
import styled, { css } from 'styled-components';
import { defaultThemeProp } from '../../theme';
const prefix = (value) => {
    if (['between', 'around', 'evenly'].includes(value))
        return `space-${value}`;
    return value;
};
const getContainerStyles = (gridProps) => {
    if (!gridProps)
        return;
    if (gridProps === true) {
        return css `
      display: grid;
    `;
    }
    const { inline, pad, cols, autoCols, rows, autoRows, autoFlow, areas, template, colGap, rowGap, gap, justifyItems, justifyContent, alignItems, alignContent } = gridProps;
    return css `
    display: ${inline ? 'inline-grid' : 'grid'};

    ${pad !== undefined &&
        css `
      /* stylelint-disable function-name-case, function-whitespace-after */
      padding: ${({ theme: { base: { spacing } } }) => (Array.isArray(pad) ? pad : [pad]).map(p => `calc(${p} * ${spacing})`).join(' ')};

      /* stylelint-enable function-name-case, function-whitespace-after */
    `}

    ${cols &&
        css `
      grid-template-columns: ${cols};
    `}

    ${autoCols &&
        css `
      grid-auto-columns: ${autoCols};
    `}

    ${rows &&
        css `
      grid-template-rows: ${rows};
    `}

    ${autoRows &&
        css `
      grid-auto-rows: ${autoRows};
    `}

    ${autoFlow &&
        css `
      grid-auto-flow: ${autoFlow};
    `}

    ${areas &&
        css `
      grid-template-areas: ${areas};
    `}

    ${template &&
        css `
      grid-template: ${template};
    `}

    ${gap !== undefined &&
        css `
      gap: calc(${gap} * ${props => props.theme.base.spacing});
    `}

    ${colGap !== undefined &&
        css `
      column-gap: calc(${colGap} * ${props => props.theme.base.spacing});
    `}

    ${rowGap !== undefined &&
        css `
      row-gap: calc(${rowGap} * ${props => props.theme.base.spacing});
    `}

    ${justifyItems &&
        css `
      justify-items: ${justifyItems};
    `}

    ${justifyContent &&
        css `
      justify-content: ${prefix(justifyContent)};
    `}

    ${alignItems &&
        css `
      align-items: ${alignItems};
    `}

    ${alignContent &&
        css `
      align-content: ${prefix(alignContent)};
    `}
  `;
};
const getItemStyles = (props) => {
    if (!props)
        return;
    const { colStart, colEnd, colStartEnd, rowStart, rowEnd, rowStartEnd, area, justifySelf, alignSelf } = props;
    return css `
    ${colStart &&
        css `
      grid-column-start: ${colStart};
    `}

    ${colEnd &&
        css `
      grid-column-end: ${colEnd};
    `}

    ${colStartEnd &&
        css `
      grid-column: ${colStartEnd};
    `}

    ${rowStart &&
        css `
      grid-row-start: ${rowStart};
    `}

    ${rowEnd &&
        css `
      grid-row-end: ${rowEnd};
    `}

    ${rowStartEnd &&
        css `
      grid-row: ${rowStartEnd};
    `}

    ${area &&
        css `
      grid-area: ${area};
    `}

    ${justifySelf &&
        css `
      justify-self: ${justifySelf};
    `}

    ${alignSelf &&
        css `
      align-self: ${alignSelf};
    `}
  `;
};
const breakpointOrder = ['xs', 'sm', 'md', 'lg', 'xl'];
export const StyledGrid = styled.div(({ container, item, theme: { base: { breakpoints: themeBreakpoints } }, xs, sm, md, lg, xl }) => {
    const breakpoints = {
        xs,
        sm,
        md,
        lg,
        xl
    };
    return css `
      ${getContainerStyles(container)}
      ${getItemStyles(item)}

    ${breakpointOrder.map(breakpoint => breakpoints[breakpoint] &&
        css `
            @media screen and (min-width: ${themeBreakpoints[breakpoint]}) {
              ${getContainerStyles(breakpoints[breakpoint]?.container)}
              ${getItemStyles(breakpoints[breakpoint]?.item)}
            }
          `)}
    `;
});
StyledGrid.defaultProps = defaultThemeProp;
const Grid = forwardRef((props, ref) => {
    return _jsx(StyledGrid, { ...props, ref: ref });
});
export default Grid;
//# sourceMappingURL=Grid.js.map