import BigNumber from 'bignumber.js';
export function getDecimalSign(locale, options) {
    return (new Intl.NumberFormat(locale, options)
        .formatToParts(0.1)
        .filter((part) => part.type === 'decimal')[0]?.value || '');
}
export function getFraction(value) {
    const decPos = value.indexOf('.');
    const substrLength = decPos === -1 ? value.length : decPos;
    return value.substring(substrLength);
}
export function getCleanedValue(value, decimalSign, maximumFractionDigits) {
    let rawValue = value.replace(new RegExp(`[^${decimalSign}\\d-]+`, 'gu'), '');
    if (decimalSign && decimalSign !== '.')
        rawValue = rawValue.replace(decimalSign, '.');
    const match = rawValue.match(new RegExp(`-?\\d*(\\.\\d{0,${maximumFractionDigits}})?`));
    if (match && match.length > 0) {
        rawValue = match[0];
    }
    return rawValue;
}
const isValidUnit = (unit) => {
    try {
        // eslint-disable-next-line no-new
        new Intl.NumberFormat(undefined, { style: 'unit', unit });
        return true;
    }
    catch {
        return false;
    }
};
export const getFormattedValue = (value, locale, unit, { notation = 'standard', useGrouping = false, maximumFractionDigits, minimumFractionDigits } = {}) => {
    const isUnit = unit ? isValidUnit(unit) : false;
    const [integer, fractionPart] = value.split('.', 2);
    const formatter = new Intl.NumberFormat(locale, {
        notation,
        useGrouping,
        minimumFractionDigits: minimumFractionDigits ?? Math.min(maximumFractionDigits ?? 0, fractionPart?.length ?? 0),
        maximumFractionDigits,
        style: isUnit ? 'unit' : undefined,
        unit: isUnit ? unit : undefined
    });
    let formatted = value;
    if (value && !Number.isNaN(parseFloat(integer))) {
        const endsWithDot = fractionPart === '';
        const valueNumber = Number(endsWithDot ? `${value}1` : value);
        formatted =
            formatter.formatToParts(valueNumber).reduce((result, { type, value: part }) => {
                if (type === 'fraction' && endsWithDot)
                    return result;
                return result + part;
            }, '') + (!isUnit && unit ? `\u00a0${unit}` : '');
    }
    else if (unit) {
        if (isUnit)
            formatted = formatter
                .formatToParts(value.startsWith('-') ? -1 : 1)
                .reduce((result, { type, value: part }) => ['unit', 'minusSign'].includes(type) ? result + part : result, '');
        else
            formatted = value.startsWith('-') ? `- ${unit}` : unit;
    }
    return formatted;
};
export function isValueInRange(value, min, max) {
    return !((min !== undefined && value < min) || (max !== undefined && value > max));
}
export function getIncrementedValue(value, min, max, step) {
    const numberValue = parseFloat(value) || 0;
    const newValue = new BigNumber(numberValue).plus(step);
    if (isValueInRange(newValue.toNumber(), min, max)) {
        return newValue.toFixed();
    }
    if (min !== undefined && newValue.toNumber() < min) {
        return min.toString();
    }
    return value;
}
export function getDecrementedValue(value, min, max, step) {
    const numberValue = parseFloat(value) || 0;
    const newValue = new BigNumber(numberValue).minus(step);
    if (isValueInRange(newValue.toNumber(), min, max)) {
        return newValue.toFixed();
    }
    if (max !== undefined && newValue.toNumber() > max) {
        return max.toString();
    }
    return value;
}
export function formatNumber(value, { locale, options }) {
    const formatter = new Intl.NumberFormat(locale, options);
    return formatter.format(value);
}
//# sourceMappingURL=utils.js.map