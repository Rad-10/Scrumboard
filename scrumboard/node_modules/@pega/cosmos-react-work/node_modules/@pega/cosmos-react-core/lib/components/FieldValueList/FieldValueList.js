import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import { Fragment, useState, useLayoutEffect, useRef, useMemo, forwardRef } from 'react';
import styled, { css } from 'styled-components';
import Button from '../Button';
import ExpandCollapse from '../ExpandCollapse';
import Grid from '../Grid';
import { StyledLabel } from '../Label';
import { useBreakpoint, useConsolidatedRef, useI18n } from '../../hooks';
import { windowIsAvailable } from '../../utils';
import { defaultThemeProp } from '../../theme';
export const StyledFieldName = styled.dt `
  word-break: break-word;
`;
export const StyledFieldValue = styled.dd `
  word-break: break-word;
`;
export const StyledFieldValueList = styled.dl(({ variant, theme }) => {
    return css `
    width: 100%;

    ${variant === 'value-comparison' &&
        css `
      dt {
        width: 100%;
      }
      dd {
        text-align: end;
        padding-inline-start: calc(2 * ${theme.base.spacing});
      }
      ${StyledLabel} {
        max-width: unset;
      }
      dd:not(:last-of-type),
      dt:not(:last-of-type) {
        border-bottom: 0.0625rem solid ${theme.base.palette['border-line']};
        padding-bottom: calc(0.5 * ${theme.base.spacing});
      }
    `}
  `;
});
StyledFieldValueList.defaultProps = defaultThemeProp;
export const StyledStackedFieldValue = styled.div ``;
const DynamicHeightValue = ({ children }) => {
    const [collapsed, setCollapsed] = useState(true);
    const [exceedsMaxHeight, setExceedsMaxHeight] = useState(false);
    const textRef = useRef(null);
    const t = useI18n();
    const maxTextHeight = useMemo(() => {
        if (!windowIsAvailable)
            return Infinity;
        const computedLineHeight = Number.parseInt(window.getComputedStyle(document.documentElement).getPropertyValue('font-size'), 10) * 1.25;
        return 3 * computedLineHeight;
    }, []);
    useLayoutEffect(() => {
        if (!textRef.current)
            return;
        const observer = new ResizeObserver(entries => {
            const exceedsHeight = entries.some(({ target, contentRect }) => {
                if (target !== textRef.current)
                    return;
                return contentRect.height > maxTextHeight;
            });
            setExceedsMaxHeight(exceedsHeight);
        });
        observer.observe(textRef.current);
        return () => {
            observer.disconnect();
        };
    }, [textRef.current, maxTextHeight]);
    return (_jsxs(_Fragment, { children: [_jsx(ExpandCollapse, { collapsed: collapsed, min: exceedsMaxHeight ? `${maxTextHeight}px` : 'max-content', children: _jsx("div", { ref: textRef, children: _jsx("span", { children: children }) }) }), exceedsMaxHeight && (_jsx(Button, { variant: 'link', onClick: () => setCollapsed(current => !current), children: collapsed ? t('show_more') : t('show_less') }))] }));
};
export const FieldValueItem = ({ name, value, variant = 'inline' }) => {
    const Wrapper = variant === 'stacked' ? StyledStackedFieldValue : Fragment;
    const displayValue = typeof value === 'string' ? _jsx(DynamicHeightValue, { children: value }) : value;
    return (_jsxs(Wrapper, { children: [_jsx(StyledLabel, { as: StyledFieldName, children: name }), _jsx(StyledFieldValue, { children: value ? displayValue : _jsx("span", { "aria-hidden": 'true', children: "\u2013\u2013" }) })] }));
};
const FieldValueList = forwardRef((props, ref) => {
    const { fields, variant = 'inline', ...restProps } = props;
    const fieldValueListRef = useConsolidatedRef(ref);
    const isXSContentWidthOrAbove = useBreakpoint('xs', {
        breakpointRef: fieldValueListRef,
        themeProp: 'content-width'
    });
    return (_jsx(Grid, { ...restProps, ref: fieldValueListRef, container: {
            cols: ['inline', 'value-comparison'].includes(variant) && isXSContentWidthOrAbove
                ? '16ch minmax(0, 1fr)'
                : 'minmax(0, 1fr)',
            colGap: variant !== 'value-comparison' ? 2 : 0,
            rowGap: variant !== 'value-comparison' ? 1 : 0.5
        }, as: StyledFieldValueList, variant: variant, children: fields.map(({ id, name, value, variant: fieldVariant }) => {
            return (_jsx(FieldValueItem, { name: name, value: value, variant: (fieldVariant ?? variant) === 'stacked' || !isXSContentWidthOrAbove
                    ? 'stacked'
                    : 'inline' }, id ?? name));
        }) }));
});
export default FieldValueList;
//# sourceMappingURL=FieldValueList.js.map