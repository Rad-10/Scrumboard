{"version":3,"file":"SliderTicks.js","sourceRoot":"","sources":["../../../src/components/Slider/SliderTicks.tsx"],"names":[],"mappings":";AAAA,OAAO,EAAM,OAAO,EAAE,MAAM,OAAO,CAAC;AAEpC,OAAO,IAA4B,MAAM,SAAS,CAAC;AAEnD,OAAO,EAAE,gBAAgB,EAAE,cAAc,EAAE,oBAAoB,EAAE,MAAM,iBAAiB,CAAC;AAEzF,OAAO,EAAE,qBAAqB,EAAE,MAAM,SAAS,CAAC;AAWhD,MAAM,WAAW,GAAyB,CAAC,EACzC,KAAK,EACL,GAAG,EACH,GAAG,EACH,IAAI,EACJ,WAAW,EACX,OAAO,EACU,EAAE,EAAE;IACrB,MAAM,UAAU,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,IAAI,GAAG,CAAC,CAAC;IAE1C,MAAM,gBAAgB,GAAG,OAAO,CAC9B,GAAG,EAAE,CAAC,qBAAqB,CAAC,KAAK,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,WAAW,KAAK,YAAY,CAAC,EAChF,CAAC,KAAK,EAAE,GAAG,EAAE,GAAG,EAAE,WAAW,CAAC,CAC/B,CAAC;IAEF,IAAI,WAAmB,CAAC;IACxB,IAAI,mBAAuC,CAAC;IAC5C,IAAI,WAAW,KAAK,YAAY,EAAE;QAChC,WAAW,GAAG,UAAU,GAAG,CAAC,CAAC,CAAC,CAAC,UAAU,UAAU,GAAG,CAAC,mBAAmB,CAAC,CAAC,CAAC,EAAE,CAAC;QAChF,mBAAmB,GAAG;YACpB,IAAI,EAAE,oBAAoB,WAAW,mBAAmB;SACzD,CAAC;KACH;SAAM;QACL,WAAW,GAAG,UAAU,UAAU,QAAQ,CAAC;QAC3C,mBAAmB,GAAG,EAAE,IAAI,EAAE,WAAW,EAAE,YAAY,EAAE,SAAS,EAAE,CAAC;KACtE;IAED,OAAO,CACL,KAAC,IAAI,IAAC,SAAS,EAAE,mBAAmB,EAAE,EAAE,EAAE,oBAAoB,YAC3D,gBAAgB,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;YAC3B,OAAO,CACL,KAAC,cAAc,IACb,IAAI,EACF,WAAW,KAAK,YAAY;oBAC1B,CAAC,CAAC;wBACE,WAAW,EAAE,GAAG,IAAI,CAAC,KAAK,MAAM,IAAI,CAAC,GAAG,EAAE;qBAC3C;oBACH,CAAC,CAAC;wBACE,WAAW,EAAE,GAAG,CAAC,IAAI,CAAC,KAAK,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE;qBAC7C,EAGP,WAAW,EAAE,WAAW,EACxB,iBAAiB,EAAE,IAAI,CAAC,KAAK,KAAK,GAAG,EACrC,iBAAiB,EAAE,IAAI,CAAC,KAAK,KAAK,GAAG,YAErC,KAAC,gBAAgB,IACf,QAAQ,EAAE,CAAC,CAAC,EACZ,IAAI,EAAC,QAAQ,uBAEb,OAAO,EAAE,GAAG,EAAE,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,YAEjC,IAAI,CAAC,KAAK,GACM,IAZd,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,CAad,CAClB,CAAC;QACJ,CAAC,CAAC,GACG,CACR,CAAC;AACJ,CAAC,CAAC;AAEF,eAAe,WAAW,CAAC","sourcesContent":["import { FC, useMemo } from 'react';\n\nimport Grid, { GridContainerProps } from '../Grid';\n\nimport { StyledTickButton, StyledTickItem, StyledTicksContainer } from './Slider.styles';\nimport SliderProps from './Slider.types';\nimport { calculateTicksRegions } from './utils';\n\ninterface SliderTicksProps {\n  ticks: NonNullable<SliderProps['ticks']>;\n  min: number;\n  max: number;\n  step: number;\n  orientation: NonNullable<SliderProps['orientation']>;\n  onClick: (value: number) => void;\n}\n\nconst SliderTicks: FC<SliderTicksProps> = ({\n  ticks,\n  min,\n  max,\n  step,\n  orientation,\n  onClick\n}: SliderTicksProps) => {\n  const cellsCount = (max - min) / step + 1;\n\n  const ticksDefinitions = useMemo(\n    () => calculateTicksRegions(ticks, min, max, step, orientation === 'horizontal'),\n    [ticks, min, max, orientation]\n  );\n\n  let repeatCells: string;\n  let gridContainerConfig: GridContainerProps;\n  if (orientation === 'horizontal') {\n    repeatCells = cellsCount > 2 ? `repeat(${cellsCount - 2}, minmax(0, 1fr))` : '';\n    gridContainerConfig = {\n      cols: `minmax(0, 0.5fr) ${repeatCells} minmax(0, 0.5fr)`\n    };\n  } else {\n    repeatCells = `repeat(${cellsCount}, 1em)`;\n    gridContainerConfig = { rows: repeatCells, alignContent: 'between' };\n  }\n\n  return (\n    <Grid container={gridContainerConfig} as={StyledTicksContainer}>\n      {ticksDefinitions.map(tick => {\n        return (\n          <StyledTickItem\n            item={\n              orientation === 'horizontal'\n                ? {\n                    colStartEnd: `${tick.start} / ${tick.end}`\n                  }\n                : {\n                    rowStartEnd: `${-tick.start} / ${-tick.end}`\n                  }\n            }\n            key={tick.label ?? tick.value}\n            orientation={orientation}\n            lowerBoundaryItem={tick.value === min}\n            upperBoundaryItem={tick.value === max}\n          >\n            <StyledTickButton\n              tabIndex={-1}\n              role='button'\n              aria-hidden\n              onClick={() => onClick(tick.value)}\n            >\n              {tick.label}\n            </StyledTickButton>\n          </StyledTickItem>\n        );\n      })}\n    </Grid>\n  );\n};\n\nexport default SliderTicks;\n"]}