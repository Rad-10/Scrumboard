{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../../src/components/Slider/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { triple } from '../../utils';\n\nimport SliderProps, { TickDefinition } from './Slider.types';\n\n/**\n * The function accepts ticks map and produces an array of tick definitions. The definition\n * consist of tick value, its label and starting and ending index.\n * Function can stretch the ticks regions to allow more text to fit in the cell.\n * To calculate the stretched regions: {min} and {max} values produce the line which is then\n * divided to equal segments. These segments have indices that correspond to CSS grid cells.\n * Then the indices are optimized in the way that every segment is stretched by the half of length\n * between current tick's index and previous tick's index or next tick's index whichever is smaller.\n * |______________|__________|________________________|\n * 1------^  ^----2----^^----3----^      ^------------4\n * @param ticksMap ticks configuration to calculate ticks definition from\n * @param min minimum allowed value in the range\n * @param max maximum allowed value in the range\n * @param step step in the range\n * @param stretch flag indicating the regions should be stretched\n * @returns ticks definitions array\n */\nexport const calculateTicksRegions = (\n  ticksMap: NonNullable<SliderProps['ticks']>,\n  min: number,\n  max: number,\n  step: number,\n  stretch: boolean\n): TickDefinition[] => {\n  // calculate initial positions for every tick, the tick segment has the width = 1\n  const defs = Object.entries(ticksMap)\n    .filter(([tickValue]) => Number(tickValue) >= min && Number(tickValue) <= max)\n    .sort(([tickValue1], [tickValue2]) => Number(tickValue1) - Number(tickValue2))\n    .map(([tickValue, tickLabel]) => {\n      const cell = (Number(tickValue) - min) / step + 1; // shift by 'min' value, divide by a step and increment, as index starts from 1\n      const cellStart = cell;\n      const cellEnd = cellStart + 1;\n      return {\n        start: cellStart,\n        end: cellEnd,\n        value: Number(tickValue),\n        label: tickLabel\n      };\n    });\n\n  if (!stretch) return defs;\n\n  const maxCell = (max - min) / step + 2;\n\n  const result = [];\n  // extend the tick segments one by one\n  // eslint-disable-next-line no-restricted-syntax\n  for (const { prev, current, next } of triple(defs)) {\n    let start = current.start;\n    let end = current.end;\n    if (start === 1) {\n      // if the tick is marginal (starting) - expand to the 'right'\n      end = next ? Math.floor((next.start - end) / 2) + end : maxCell;\n    } else if (end === maxCell) {\n      // if the tick is marginal (ending) - expand to the 'left'\n      start = prev ? Math.floor((start - prev.end) / 2) + prev.end : 1;\n    } else {\n      // calculate length between current and prev / next tick and choose the smaller value\n      const length = Math.min(start - (prev?.end ?? 1), (next?.start ?? maxCell) - end);\n      // expand the segment to the left\n      start -= Math.floor(length / 2);\n      // expand to the right\n      end += Math.floor(length / 2);\n    }\n    result.push({\n      start,\n      end,\n      value: current.value,\n      label: current.label\n    });\n  }\n\n  return result;\n};\n\n/**\n * Function for given input returns nearest discrete value from a series {min, max}\n * @param input the value to look for nearest value\n * @param step step value determining discrete series\n * @param min minimal value in the series\n * @param max maximum value in the series\n * @returns nearest value as a number\n */\nexport const getNearestValue = (input: number, min: number, max: number, step: number): number => {\n  const output = Math.round(input / step) * step;\n\n  const decimals = step.toString().split('.')[1]?.length;\n  return Number(output.toFixed(decimals || 0));\n};\n\n/**\n * Function calculates minimum length of the field where any value from the set of possible values will fit in.\n * @param min minimum value\n * @param max maximum value\n * @param step step in range\n * @returns minimum number of characters the field needs\n */\nexport const calculateValueLength = (min: number, max: number, step: number): number => {\n  const [minIntegerPart, minDecimalPart = ''] = min.toString().split('.');\n  const [maxIntegerPart, maxDecimalPart = ''] = max.toString().split('.');\n  const stepDecimalPart = step.toString().split('.')[1] ?? '';\n  return (\n    Math.max(minIntegerPart.length, maxIntegerPart.length) +\n    Math.max(maxDecimalPart.length, minDecimalPart.length, stepDecimalPart.length) +\n    (maxDecimalPart || minDecimalPart || stepDecimalPart\n      ? 1 // if there's decimal part, reserve a space for the separator\n      : 0)\n  );\n};\n"]}