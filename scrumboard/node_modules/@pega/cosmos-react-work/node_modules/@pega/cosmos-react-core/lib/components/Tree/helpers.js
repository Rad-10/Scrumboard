const helpers = {
    getNode(nodes, id) {
        let found;
        nodes.some(node => {
            if (node.id === id) {
                found = node;
                return true;
            }
            if (node.nodes) {
                found = this.getNode(node.nodes, id);
                return !!found;
            }
            return false;
        });
        return found;
    },
    getParentNode(nodes, id) {
        let found;
        nodes.some(node => {
            const childNodes = node.nodes || [];
            childNodes.some(childNode => {
                if (childNode.id === id) {
                    found = node;
                    return true;
                }
                if (childNode.nodes) {
                    found = this.getParentNode(childNodes, id);
                    return !!found;
                }
                return false;
            });
            return !!found;
        });
        return found;
    },
    mapTree(nodes, fn) {
        return nodes.map((node, index, array) => {
            let newNode = node;
            if (node.nodes) {
                newNode = {
                    ...newNode,
                    nodes: this.mapTree(node.nodes, fn)
                };
            }
            return fn(newNode, index, array);
        });
    },
    mapNode(nodes, id, fn) {
        return nodes.map((node, index, array) => {
            let newNode = node;
            if (node.nodes) {
                newNode = {
                    ...newNode,
                    nodes: this.mapNode(node.nodes, id, fn)
                };
            }
            if (node.id === id) {
                newNode = fn(newNode, index, array);
            }
            return newNode;
        });
    },
    flatten(nodes, ancestors) {
        return nodes.reduce((flatNodes, node) => {
            if (node.nodes) {
                return [
                    ...flatNodes,
                    node,
                    ...this.flatten(node.nodes, ancestors ? [...ancestors, node] : [node])
                ];
            }
            return [...flatNodes, ancestors ? { ...node, ancestors } : node];
        }, []);
    },
    appendTo(nodes, id, newNodes) {
        if (id) {
            return this.mapNode(nodes, id, node => ({
                ...node,
                nodes: [...(node.nodes ?? []), ...newNodes]
            }));
        }
        return [...nodes, ...newNodes];
    },
    expandTo(nodes, id) {
        return nodes.map(node => {
            // leaf node
            if (node.id === id) {
                return {
                    ...node,
                    expanded: true
                };
            }
            // parent node
            if (node.nodes && !!this.getNode(node.nodes, id)) {
                return {
                    ...node,
                    nodes: this.expandTo(node.nodes, id),
                    expanded: true
                };
            }
            return { ...node, expanded: false };
        });
    },
    getFirstChildNode(nodes, id) {
        let firstChildNode;
        const node = this.getNode(nodes, id);
        if (node && node.expanded && node.nodes && node.nodes.length > 0) {
            const childNodes = node.nodes;
            firstChildNode = childNodes[0];
        }
        return firstChildNode;
    },
    getAdjacentNode(nodes, id) {
        let nextNode;
        const parent = this.getParentNode(nodes, id);
        if (parent && parent.nodes && parent.nodes.length > 0) {
            const childNodes = parent.nodes;
            const currentIndex = childNodes.map(nodeEl => nodeEl.id).indexOf(id);
            if (currentIndex === childNodes.length - 1) {
                nextNode = this.getAdjacentNode(nodes, parent.id);
            }
            else {
                nextNode = childNodes[currentIndex + 1];
            }
        }
        else {
            const index = nodes.map(nodeEl => nodeEl.id).indexOf(id);
            nextNode = nodes[index + 1];
        }
        return nextNode;
    },
    getNextNode(nodes, id) {
        let nextNode;
        const firstChildNode = this.getFirstChildNode(nodes, id);
        if (firstChildNode) {
            nextNode = firstChildNode;
        }
        else {
            nextNode = this.getAdjacentNode(nodes, id);
        }
        return nextNode;
    },
    getDeepestNode(nodes, id) {
        const node = this.getNode(nodes, id);
        let lastNode = node;
        if (node && node.expanded && node.nodes && node.nodes.length > 0) {
            const childNodes = node.nodes;
            const lastChildNode = childNodes[childNodes.length - 1];
            if (lastChildNode.expanded) {
                lastNode = this.getDeepestNode(nodes, lastChildNode.id);
            }
            else {
                lastNode = lastChildNode;
            }
        }
        return lastNode;
    },
    getPreviousNode(nodes, id) {
        const parent = this.getParentNode(nodes, id);
        let previousNode;
        if (parent && parent.nodes && parent.nodes.length > 0) {
            const childNodes = parent.nodes;
            const currentIndex = childNodes.map(nodeEl => nodeEl.id).indexOf(id);
            if (currentIndex === 0) {
                previousNode = parent;
            }
            else {
                previousNode = this.getDeepestNode(nodes, childNodes[currentIndex - 1].id);
            }
        }
        else {
            const index = nodes.map(node => node.id).indexOf(id);
            if (nodes[index - 1])
                previousNode = this.getDeepestNode(nodes, nodes[index - 1].id);
        }
        return previousNode;
    }
};
export default helpers;
//# sourceMappingURL=helpers.js.map