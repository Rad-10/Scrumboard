import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { useRef, useEffect, forwardRef } from 'react';
import styled, { css } from 'styled-components';
import { mix, readableColor } from 'polished';
import { defaultThemeProp } from '../../theme';
import { tryCatch } from '../../utils';
import { getHoverColors, omitProps } from '../../styles';
import { useElement, useConsolidatedRef } from '../../hooks';
import Tooltip from '../Tooltip';
import Progress, { StyledProgressRing } from '../Progress';
import { StyledBackdrop } from '../Backdrop';
import { StyledIcon } from '../Icon';
import { StyledPopover } from '../Popover';
export const StyledButton = styled.button.withConfig(omitProps('loading'))(({ variant, icon, loading, compact, theme: { base: { spacing, 'border-radius': baseBorderRadius, palette: { 'primary-background': backgroundColor, 'foreground-color': textColor }, 'hit-area': { 'mouse-min': hitAreaMouse, 'finger-min': hitAreaFinger, 'compact-min': hitAreaCompact }, animation: { speed, timing: { ease } }, 'disabled-opacity': disabledOpacity }, components: { button: { color, 'secondary-color': secondaryColor, padding, 'border-radius': borderRadius, 'border-width': borderWidth, 'focus-shadow': focusShadow, touch: { padding: touchPadding } }, link: { color: linkColor } } } }) => {
    const borderColor = variant === 'secondary' ? color : 'transparent';
    const contrastColor = tryCatch(() => readableColor(color));
    const hoverColors = getHoverColors(color);
    const hoverPrimaryColor = hoverColors.background;
    const hoverContrastColor = hoverColors.foreground;
    const secondaryHoverColor = tryCatch(() => mix(0.85, secondaryColor, color));
    let buttonColor = contrastColor;
    let buttonBackgroundColor = color;
    if (variant === 'secondary') {
        buttonColor = color;
        buttonBackgroundColor = secondaryColor;
    }
    else if (variant === 'simple') {
        if (icon) {
            buttonColor = 'currentColor';
            buttonBackgroundColor = 'transparent';
        }
        else {
            buttonColor = color;
            buttonBackgroundColor = backgroundColor;
        }
    }
    else if (variant === 'link') {
        buttonColor = linkColor;
        buttonBackgroundColor = 'transparent';
    }
    else if (variant === 'text') {
        buttonColor = textColor;
        buttonBackgroundColor = 'transparent';
    }
    return css `
      color: ${buttonColor};
      background-color: ${buttonBackgroundColor};
      display: ${variant === 'link' || variant === 'text' ? 'inline' : 'inline-flex'};
      align-items: center;
      outline: none;
      text-decoration: none;
      transition-property: background-color, color, box-shadow;
      transition-duration: calc(0.5 * ${speed});
      transition-timing-function: ${ease};
      cursor: pointer;

      ${variant !== 'link' && variant !== 'text'
        ? css `
            justify-content: center;
            line-height: 1;
            border: ${borderWidth} solid ${borderColor};
            position: relative;
          `
        : css `
            text-align: start;
            border: none;

            > ${StyledIcon} {
              vertical-align: bottom;
            }
          `}

      & + & {
        margin-inline-start: ${spacing};
      }

      /* Not able to combine with selector above. Stylis bug? */
      & + ${StyledPopover} + & {
        margin-inline-start: ${spacing};
      }

      @media (hover: hover) {
        &:hover {
          ${variant === 'primary' &&
        css `
            background-color: ${hoverPrimaryColor};
            color: ${hoverContrastColor};
            text-decoration: none;
          `}

          ${(variant === 'secondary' || (variant === 'simple' && !icon)) &&
        css `
            background-color: ${secondaryHoverColor};
            text-decoration: none;
          `}

          ${variant === 'simple' &&
        icon &&
        css `
            ::before {
              content: '';
              position: absolute;
              top: calc(${borderWidth} * -1);
              bottom: calc(${borderWidth} * -1);
              left: calc(${borderWidth} * -1);
              right: calc(${borderWidth} * -1);
              border-radius: inherit;
              background-color: currentColor;
              opacity: 0.15;
            }
          `}

          ${(variant === 'link' || variant === 'text') &&
        css `
            text-decoration: underline;
          `}
        }
      }

      ${variant !== 'link' &&
        variant !== 'text' &&
        css `
        min-height: ${hitAreaMouse};
        min-width: ${hitAreaMouse};
        border-radius: calc(${baseBorderRadius} * ${borderRadius});
        -webkit-user-select: none;
        user-select: none;
      `}

      ${compact &&
        css `
        min-height: ${hitAreaCompact};
        min-width: ${hitAreaCompact};
      `}

      ${!icon &&
        variant !== 'link' &&
        variant !== 'text' &&
        css `
        padding: ${padding};
      `}

      ${variant !== 'link' &&
        variant !== 'text' &&
        css `
        @media (pointer: coarse) {
          ${!compact &&
            css `
            min-height: ${hitAreaFinger};
            min-width: ${hitAreaFinger};
          `}
          border-radius: calc(${baseBorderRadius} * ${borderRadius});
          ${!icon &&
            css `
            padding: ${touchPadding};
          `}
        }
      `}

      &:disabled,
      &[disabled] {
        opacity: ${disabledOpacity};
        cursor: not-allowed;
        pointer-events: none;
      }

      &:enabled:focus,
      &:not([disabled]):focus {
        box-shadow: ${focusShadow};
      }

      ${icon &&
        variant !== 'link' &&
        variant !== 'text' &&
        css `
        border-radius: calc(${baseBorderRadius} * ${borderRadius});
        > svg {
          display: block;
        }
      `}

      ${loading &&
        css `
        ${StyledBackdrop} {
          background-color: ${buttonBackgroundColor};
          border-radius: inherit;
        }
        ${StyledProgressRing} {
          width: 1em;
          height: 1em;
          circle:nth-child(2) {
            animation-duration: calc(${speed} * 2);
          }
        }
      `}
    `;
});
StyledButton.defaultProps = defaultThemeProp;
const Button = forwardRef(({ variant = 'secondary', type = 'button', disabled = false, icon = false, compact = false, href, as, forwardedAs, label, 'aria-label': ariaLabel, loading = false, children, ...restProps }, ref) => {
    const [buttonEl, setButtonEl] = useElement();
    const mouseDownEvent = useRef();
    const buttonRef = useConsolidatedRef(ref, setButtonEl);
    const showProgress = loading && variant !== 'link' && variant !== 'text';
    useEffect(() => {
        return () => {
            mouseDownEvent.current = undefined;
        };
    }, []);
    return (_jsxs(_Fragment, { children: [_jsxs(StyledButton, { ...restProps, ref: buttonRef, as: as || (href ? 'a' : 'button'), forwardedAs: forwardedAs || (href ? 'a' : 'button'), variant: variant, icon: icon, compact: compact, type: href ? undefined : type, href: href, disabled: disabled && !href, loading: showProgress, "aria-label": ariaLabel || label, onMouseDown: (e) => {
                    restProps.onMouseDown?.(e);
                    e.persist();
                    mouseDownEvent.current = e;
                }, onMouseUp: (e) => {
                    const shouldFocus = mouseDownEvent.current && !mouseDownEvent.current.defaultPrevented;
                    mouseDownEvent.current = undefined;
                    if (shouldFocus && buttonRef.current !== document.activeElement) {
                        buttonRef.current?.focus();
                    }
                    return restProps.onMouseUp?.(e);
                }, children: [showProgress && _jsx(Progress, { variant: 'ring', placement: 'local' }), children] }), buttonEl && label && (_jsx(Tooltip, { target: buttonEl, showDelay: 'none', hideDelay: 'none', describeTarget: false, children: label }))] }));
});
export default Button;
//# sourceMappingURL=Button.js.map