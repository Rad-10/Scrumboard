import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { cloneElement, useEffect, useState, forwardRef } from 'react';
import styled, { css } from 'styled-components';
import { readableColor, rgba } from 'polished';
import { defaultThemeProp } from '../../theme';
import Flex from '../Flex';
import Actions from '../Actions';
import { useConsolidatedRef, useI18n, useUID } from '../../hooks';
import Label, { StyledLabel } from '../Label';
import { calculateFontSize, getHoverColors } from '../../styles';
import VisuallyHiddenText from '../VisuallyHiddenText';
import { getFocusables, tryCatch } from '../../utils';
import Button from '../Button';
import Icon, { registerIcon } from '../Icon';
import * as warnSolidIcon from '../Icon/icons/warn-solid.icon';
import * as flagWaveSolidIcon from '../Icon/icons/flag-wave-solid.icon';
import * as checkIcon from '../Icon/icons/check.icon';
import AdditionalInfo from '../AdditionalInfo';
registerIcon(warnSolidIcon, flagWaveSolidIcon, checkIcon);
const StyledStatusIcon = styled(Icon)(({ theme, status }) => {
    return css `
      height: 1em;
      width: 1em;
      color: ${theme.components['form-field'][status]['status-color']};
      vertical-align: baseline;
      margin-inline-end: 0.5ch;
    `;
});
StyledStatusIcon.defaultProps = defaultThemeProp;
export const StyledFormFieldInfo = styled.div(({ status, theme: { base: { 'font-size': fontSize, 'font-scale': fontScale, spacing }, components: { 'form-field': formField } } }) => {
    const { xxs: infoFontSize } = calculateFontSize(fontSize, fontScale);
    return css `
      max-width: max-content;
      margin-top: calc(0.25 * ${spacing});
      font-size: ${infoFontSize};
      word-break: break-word;
      ${status &&
        formField[status] &&
        css `
        color: ${formField[status]['status-color']};
      `}
    `;
});
StyledFormFieldInfo.defaultProps = defaultThemeProp;
const StyledLabelRow = styled.div ``;
export const StyledFormField = styled.div(props => {
    const { disabled, required, theme: { base: { palette: { urgent }, 'disabled-opacity': disabledOpacity, spacing } } } = props;
    return css `
    ${disabled &&
        css `
      opacity: ${disabledOpacity};
      -webkit-user-select: none;
      user-select: none;
    `}
    position: relative;
    border: 0;

    > ${StyledLabel}, > ${StyledLabelRow} {
      margin-bottom: calc(0.25 * ${spacing});
    }

    > ${StyledLabel}, > ${StyledLabelRow} > ${StyledLabel} {
      &::after {
        display: ${required ? 'inline' : 'none'};
        content: '\\00a0*';
        vertical-align: top;
        color: ${urgent};
      }

      ${disabled &&
        css `
        cursor: not-allowed;
      `}
    }
  `;
});
StyledFormField.defaultProps = defaultThemeProp;
const StyledSuggestionButton = styled(Button)(({ theme: { base: { 'font-size': fontSize, 'font-scale': fontScale, 'border-radius': baseRadius, spacing }, components: { 'form-control': { 'border-radius': radius, 'border-width': borderWidth }, 'form-field': formField } } }) => {
    const { xxs: buttonFontSize } = calculateFontSize(fontSize, fontScale);
    const backgroundColor = formField.pending['status-color'];
    const hoverColors = getHoverColors(backgroundColor);
    const color = tryCatch(() => readableColor(backgroundColor));
    const borderColor = color ? rgba(color, 0.4) : color;
    return css `
      background-color: ${backgroundColor};
      color: ${color};
      font-size: ${buttonFontSize};
      min-width: calc(3 * ${spacing});
      min-height: calc(3 * ${spacing});
      padding: 0 ${spacing};
      border-radius: 0;
      border: none;
      &:first-child {
        border-inline-end: ${borderWidth} solid ${borderColor};
        border-end-start-radius: calc(${baseRadius} * ${radius});
        margin-inline-start: calc(2 * ${spacing});
      }
      &:last-child {
        border-end-end-radius: calc(${baseRadius} * ${radius});
        margin-inline-start: 0;
      }
      &:hover {
        background-color: ${hoverColors.background};
      }

      @media (pointer: coarse) {
        min-height: 2rem;
      }
    `;
});
StyledSuggestionButton.defaultProps = defaultThemeProp;
const statusIconMap = { error: 'warn-solid', warning: 'flag-wave-solid', success: 'check' };
const FormField = forwardRef((props, ref) => {
    const uid = useUID();
    const { children: controlElement, id = uid, as = 'div', label, labelAs = 'label', labelFor = id, labelId, labelHidden = false, labelAfter = false, info, status, isRadioCheck, charLimitDisplay, required = false, disabled = false, readOnly = false, inline = false, actions, container, additionalInfo, onResolveSuggestion, ...restProps } = props;
    const t = useI18n();
    const labelAsLegend = labelAs === 'legend';
    const hasSuggestion = status === 'pending' && !!onResolveSuggestion;
    const consolidatedRef = useConsolidatedRef(ref);
    const showAdditionalInfo = !!additionalInfo && !disabled && !labelHidden;
    const labelAndInfo = (_jsxs(_Fragment, { children: [_jsxs(Label, { id: labelId, as: labelAs, htmlFor: labelAs === 'label' ? labelFor : undefined, labelHidden: labelHidden, onClick: (e) => {
                    if (readOnly)
                        e.preventDefault();
                }, inline: inline, children: [status && status !== 'pending' && !labelHidden && (_jsx(StyledStatusIcon, { status: status, name: statusIconMap[status] })), label] }), showAdditionalInfo && (_jsx(AdditionalInfo, { heading: additionalInfo.heading, children: additionalInfo.content }))] }));
    const labelRow = showAdditionalInfo && !isRadioCheck ? (_jsx(Flex, { as: StyledLabelRow, container: { justify: 'between', alignItems: 'end' }, item: { alignSelf: 'stretch' }, children: labelAndInfo })) : (labelAndInfo);
    /*
      We have to use an internal state and an effect to set the text value of info after the DOM element is rendered.
      This is to ensure screen readers will announce info on errors when role is set to alert.
      Needs testing to confirm. Currently the expected sequence would be:
      - FormField renders with no error and no info
      - user input triggers an error status
      - props passed set error status and provide info text
      - effect runs and sets live region state which renders and is announced
    */
    const [liveRegionInfo, setLiveRegionInfo] = useState(null);
    useEffect(() => {
        setLiveRegionInfo(info);
    }, [info]);
    // fieldset or single form control element
    let content = labelAsLegend
        ? controlElement
        : cloneElement(controlElement, {
            'aria-describedby': info && `${id}-info`
        });
    if (actions) {
        content = (_jsxs(Flex, { container: { alignItems: 'center', gap: 0.5 }, children: [content, _jsx(Actions, { items: actions, menuAt: 3 })] }));
    }
    let infoContent = info ? (
    /*
      Region for additional info, help or error message.
      Withholding aria-live="assertive" to avoid iOS issue. See below.
      https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Live_Regions#Preferring_specialized_live_region_roles
    */
    _jsx(StyledFormFieldInfo, { status: status, role: status === 'error' || status === 'warning' ? 'alert' : undefined, id: `${id}-info`, children: liveRegionInfo })) : undefined;
    if (charLimitDisplay) {
        infoContent = (_jsxs(Flex, { container: { justify: infoContent ? 'between' : 'end', gap: 1 }, children: [infoContent, _jsx(Flex, { item: { shrink: 0 }, children: charLimitDisplay })] }));
    }
    if (hasSuggestion) {
        const focusables = getFocusables(consolidatedRef);
        infoContent = (_jsxs(Flex, { container: { alignItems: 'start', justify: 'between' }, children: [_jsxs(StyledFormFieldInfo, { status: status, id: `${id}-info`, children: [t('suggestion_info'), _jsx(VisuallyHiddenText, { "aria-live": 'polite', children: t('suggestion_assist') })] }), _jsxs(Flex, { container: { wrap: 'nowrap' }, children: [_jsx(StyledSuggestionButton, { onClick: () => {
                                onResolveSuggestion(false);
                                focusables[0]?.focus();
                            }, "aria-label": t('reject_suggestion_button_a11y'), children: t('no') }), _jsx(StyledSuggestionButton, { onClick: () => {
                                onResolveSuggestion(true);
                                focusables[0]?.focus();
                            }, "aria-label": t('accept_suggestion_button_a11y'), children: t('yes') })] })] }));
    }
    const onKeyDown = (e) => {
        if (e.key === 'Enter') {
            const target = e.target;
            if (!target.closest('button')) {
                e.preventDefault();
                onResolveSuggestion?.(true);
            }
        }
    };
    return (_jsxs(Flex, { ...restProps, container: {
            direction: inline ? 'row' : 'column',
            alignItems: inline ? 'center' : undefined,
            ...container
        }, as: StyledFormField, id: `${id}-field`, forwardedAs: as, required: required, disabled: disabled, readOnly: readOnly, onKeyDown: hasSuggestion ? onKeyDown : undefined, "aria-describedby": labelAsLegend && info ? `${id}-info` : undefined, ref: consolidatedRef, children: [(labelAsLegend || !labelAfter) && labelRow, content, !labelAsLegend && labelAfter && labelRow, !readOnly && infoContent] }));
});
export default FormField;
//# sourceMappingURL=FormField.js.map