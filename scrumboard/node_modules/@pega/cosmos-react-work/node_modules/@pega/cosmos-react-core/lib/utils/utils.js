import { jsx as _jsx } from "react/jsx-runtime";
import { Fragment } from 'react';
export const windowIsAvailable = typeof window !== 'undefined';
export const navigatorIsAvailable = typeof navigator !== 'undefined';
export const documentIsAvailable = typeof document !== 'undefined';
/** @returns Debounced function that can be called only once in given timeout */
export function debounce(func, waitTime) {
    let timeout;
    return (...args) => {
        const waitFunc = () => {
            timeout = null;
            func.apply(this, args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(waitFunc, waitTime);
    };
}
/** Check for an existence of prop */
export function hasProp(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
}
// Add some context...
export function bindAll(obj, names) {
    names.forEach(fn => {
        obj[fn] = obj[fn].bind(obj);
    });
}
// Capitalize
export function cap(s) {
    return s.charAt(0).toUpperCase() + s.slice(1);
}
/** Generate unique id for elements */
export function createUID() {
    return `_${Math.random().toString(36).substr(2, 9)}`;
}
/** Returns array with numbers from given range */
export function range(start, end) {
    return Array(end - start + 1)
        .fill(0)
        .map((_, idx) => start + idx);
}
/** Return an array of strings and regex replaced components */
export function replaceMatchWithElement(str, re, render) {
    const arr = [];
    // Only loop for stateful regexes.
    if (re.global || re.sticky) {
        let currIdx = 0;
        let match;
        // eslint-disable-next-line no-cond-assign
        while ((match = re.exec(str))) {
            arr.push(str.slice(currIdx, match.index), render(match[0]));
            currIdx = match.index + match[0].length;
        }
        arr.push(str.slice(currIdx));
    }
    else {
        const match = re.exec(str);
        if (!match)
            arr.push(str);
        else {
            arr.push(str.slice(0, match.index), render(match[0]), str.slice(match.index + match[0].length));
        }
    }
    return arr.flatMap((item, idx) => {
        if (!item)
            return [];
        return _jsx(Fragment, { children: item }, idx);
    });
}
/** Get scrollbar width */
export function getScrollbarWidth() {
    const scrollDiv = document.createElement('div');
    const divSize = '50px';
    let size = 0;
    scrollDiv.style.position = 'absolute';
    scrollDiv.style.top = `-${divSize}`;
    scrollDiv.style.width = divSize;
    scrollDiv.style.height = divSize;
    scrollDiv.style.overflow = 'scroll';
    document.body.appendChild(scrollDiv);
    size = scrollDiv.offsetWidth - scrollDiv.clientWidth;
    document.body.removeChild(scrollDiv);
    return size;
}
/** Test element for overflow */
export function testElForOverflow(el) {
    return [el.scrollWidth > el.clientWidth, el.scrollHeight > el.clientHeight];
}
/** Used mostly to trigger css transition after DOM append */
export function reflow(node) {
    node = node ?? document.body;
    return node.offsetWidth;
}
export function loadScript(src, onLoad, onError) {
    const scriptElem = document.createElement('script');
    scriptElem.src = src;
    scriptElem.addEventListener('load', onLoad);
    scriptElem.addEventListener('error', onError);
    document.head.appendChild(scriptElem);
}
export function deepGet(obj, keys) {
    let rtn = obj;
    const found = keys.every(key => {
        if (typeof rtn === 'object' && rtn) {
            rtn = rtn[key];
            return true;
        }
        return false;
    });
    if (found)
        return rtn;
    return undefined;
}
/** Compares two objects by comparing each key value regardless of order. */
export function deepObjectComparison(valueA, valueB) {
    // If the values are strictly equal, return true
    if (valueA === valueB)
        return true;
    // If the values are not objects and are not equal, return false
    if (typeof valueA !== 'object' ||
        typeof valueB !== 'object' ||
        valueA === null ||
        valueB === null)
        return false;
    const keysA = Object.keys(valueA);
    const keysB = Object.keys(valueB);
    // If the objects have different numbers of keys, return false
    if (keysA.length !== keysB.length)
        return false;
    for (let i = 0; i < keysA.length; i += 1) {
        const key = keysA[i];
        // If there is not a 1:1 mapping of keys between the objects, return false
        if (!keysB.includes(key))
            return false;
        if (typeof valueA[key] === 'function' || typeof valueB[key] === 'function') {
            // If the value of a given key is a function, and the functions are not equivalent between the objects, return false
            if (valueA[key].toString() !== valueB[key].toString())
                return false;
            // If all checks have passed thus far, compare the next set of nested values
        }
        else if (!deepObjectComparison(valueA[key], valueB[key]))
            return false;
    }
    // If all checks have passed, the objects are deeply equal
    return true;
}
export function defineSmartGetter(obj, key, valueFn) {
    Object.defineProperty(obj, key, {
        get: () => {
            delete obj[key];
            obj[key] = valueFn();
            return obj[key];
        },
        enumerable: true,
        configurable: true
    });
    return obj;
}
export function tryCatch(tryFn, catchFn, finallyFn) {
    try {
        return tryFn();
    }
    catch (err) {
        if (catchFn)
            return catchFn(err);
    }
    finally {
        // eslint-disable-next-line no-unsafe-finally
        if (finallyFn)
            return finallyFn();
    }
}
/**
 * Returns normalized list of elements, ie. it de-reference the element from the RefObject if needed.
 * @param els a list of elements or refs to normalize.
 * @returns a new list of the same length with the de-referenced elements.
 */
export const normalizeElements = (els) => {
    return els.map((el) => {
        if (!el)
            return null;
        return el instanceof EventTarget ? el : el.current;
    });
};
/**
 * Returns all valid focusable elements within a given ref.
 * @param focusablesRef The ref containing the element to search for focusable elements within.
 * @returns a list of valid focusable elements within the given ref.
 */
export const getFocusables = (focusablesRef) => {
    if (!focusablesRef.current)
        return [];
    const selector = 'a, button, input, textarea, select, details, [tabindex]:not([tabindex="-1"])';
    return [...focusablesRef.current.querySelectorAll(selector)].filter(el => el instanceof HTMLElement &&
        !el.hasAttribute('disabled') &&
        el.getAttribute('tabindex') !== '-1');
};
/**
 * Generator that returns triple of subsequent values in the given array.
 * @param array source array
 * @returns triple of previous, current and next value on every call
 */
export function* triple(array) {
    for (let i = 0; i < array.length; i += 1) {
        yield { prev: array[i - 1], current: array[i], next: array[i + 1] };
    }
    return undefined;
}
/**
 * Escape special characters in order to pass a string to the RegExp constructor.
 * @param s a string.
 * @returns a string with special characters escaped.
 */
export const escapeRegExp = (s) => String(s).replace(/[\\^$*+?.()|[\]{}]/g, '\\$&');
/**
 * Generate a RegExp with a string parameter.
 * @param s The string to match.
 * @param type How to match.
 * @param flags Standard RegExp flags.
 * @returns A RegExp with the match pattern.
 */
export const createStringMatcher = (s, type = 'contains', flags = 'i') => {
    const escaped = escapeRegExp(s);
    let pattern = escaped;
    if (type === 'start') {
        pattern = `^${escaped}`;
    }
    else if (type === 'boundary') {
        pattern = `(?:^|\\s)${escaped}`;
    }
    return new RegExp(pattern, flags);
};
/**
 * Function generates string representation of the given list accordingly to localization rules of given locale.
 * @param list list of strings to format
 * @param t translation function used internally
 * @param locale locale tag to get the localization rules for
 * @param options formatting options
 * @returns
 */
export const formatListToLocaleString = (list, t, locale, { count = list.length, separator } = {}) => {
    const remainder = list.length ? count - list.length : 0;
    const toFormat = remainder > 0 ? [...list, t('more_count', [remainder], { count: remainder })] : list;
    if (separator || !('ListFormat' in Intl))
        return toFormat.join(separator ?? ', ');
    return new Intl.ListFormat(locale, { style: 'long' }).format(toFormat);
};
/**
 * Checks if two URLs have the same origin.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy#definition_of_an_origin Definition of an origin}
 */
export const sameOrigin = ({ protocol: protocolA, hostname: hostnameA, port: portA }, { protocol: protocolB, hostname: hostnameB, port: portB }) => {
    if (protocolA !== protocolB)
        return false;
    if (hostnameA !== hostnameB)
        return false;
    if (!portA) {
        if (protocolA === 'http:')
            portA = '80';
        else if (protocolA === 'https:')
            portA = '443';
    }
    if (!portB) {
        if (protocolB === 'http:')
            portB = '80';
        else if (protocolB === 'https:')
            portB = '443';
    }
    return portA === portB;
};
/**
 * Gets element that currently has focus with support for open shadow roots.
 * @param root Optional container to search for the active element. Defaults to `document`.
 * @returns The Element within the DOM that currently has focus.
 */
export const getActiveElement = (root = document) => {
    let activeEl = root.activeElement;
    if (!activeEl)
        return null;
    if (activeEl.tagName.toLowerCase() === 'iframe' &&
        activeEl.contentDocument)
        activeEl = getActiveElement(activeEl.contentDocument) ?? activeEl;
    if (activeEl.shadowRoot)
        activeEl = getActiveElement(activeEl.shadowRoot) ?? activeEl;
    return activeEl;
};
//# sourceMappingURL=utils.js.map