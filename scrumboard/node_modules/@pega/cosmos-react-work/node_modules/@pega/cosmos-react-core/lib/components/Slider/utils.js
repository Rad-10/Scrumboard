import { triple } from '../../utils';
/**
 * The function accepts ticks map and produces an array of tick definitions. The definition
 * consist of tick value, its label and starting and ending index.
 * Function can stretch the ticks regions to allow more text to fit in the cell.
 * To calculate the stretched regions: {min} and {max} values produce the line which is then
 * divided to equal segments. These segments have indices that correspond to CSS grid cells.
 * Then the indices are optimized in the way that every segment is stretched by the half of length
 * between current tick's index and previous tick's index or next tick's index whichever is smaller.
 * |______________|__________|________________________|
 * 1------^  ^----2----^^----3----^      ^------------4
 * @param ticksMap ticks configuration to calculate ticks definition from
 * @param min minimum allowed value in the range
 * @param max maximum allowed value in the range
 * @param step step in the range
 * @param stretch flag indicating the regions should be stretched
 * @returns ticks definitions array
 */
export const calculateTicksRegions = (ticksMap, min, max, step, stretch) => {
    // calculate initial positions for every tick, the tick segment has the width = 1
    const defs = Object.entries(ticksMap)
        .filter(([tickValue]) => Number(tickValue) >= min && Number(tickValue) <= max)
        .sort(([tickValue1], [tickValue2]) => Number(tickValue1) - Number(tickValue2))
        .map(([tickValue, tickLabel]) => {
        const cell = (Number(tickValue) - min) / step + 1; // shift by 'min' value, divide by a step and increment, as index starts from 1
        const cellStart = cell;
        const cellEnd = cellStart + 1;
        return {
            start: cellStart,
            end: cellEnd,
            value: Number(tickValue),
            label: tickLabel
        };
    });
    if (!stretch)
        return defs;
    const maxCell = (max - min) / step + 2;
    const result = [];
    // extend the tick segments one by one
    // eslint-disable-next-line no-restricted-syntax
    for (const { prev, current, next } of triple(defs)) {
        let start = current.start;
        let end = current.end;
        if (start === 1) {
            // if the tick is marginal (starting) - expand to the 'right'
            end = next ? Math.floor((next.start - end) / 2) + end : maxCell;
        }
        else if (end === maxCell) {
            // if the tick is marginal (ending) - expand to the 'left'
            start = prev ? Math.floor((start - prev.end) / 2) + prev.end : 1;
        }
        else {
            // calculate length between current and prev / next tick and choose the smaller value
            const length = Math.min(start - (prev?.end ?? 1), (next?.start ?? maxCell) - end);
            // expand the segment to the left
            start -= Math.floor(length / 2);
            // expand to the right
            end += Math.floor(length / 2);
        }
        result.push({
            start,
            end,
            value: current.value,
            label: current.label
        });
    }
    return result;
};
/**
 * Function for given input returns nearest discrete value from a series {min, max}
 * @param input the value to look for nearest value
 * @param step step value determining discrete series
 * @param min minimal value in the series
 * @param max maximum value in the series
 * @returns nearest value as a number
 */
export const getNearestValue = (input, min, max, step) => {
    const output = Math.round(input / step) * step;
    const decimals = step.toString().split('.')[1]?.length;
    return Number(output.toFixed(decimals || 0));
};
/**
 * Function calculates minimum length of the field where any value from the set of possible values will fit in.
 * @param min minimum value
 * @param max maximum value
 * @param step step in range
 * @returns minimum number of characters the field needs
 */
export const calculateValueLength = (min, max, step) => {
    const [minIntegerPart, minDecimalPart = ''] = min.toString().split('.');
    const [maxIntegerPart, maxDecimalPart = ''] = max.toString().split('.');
    const stepDecimalPart = step.toString().split('.')[1] ?? '';
    return (Math.max(minIntegerPart.length, maxIntegerPart.length) +
        Math.max(maxDecimalPart.length, minDecimalPart.length, stepDecimalPart.length) +
        (maxDecimalPart || minDecimalPart || stepDecimalPart
            ? 1 // if there's decimal part, reserve a space for the separator
            : 0));
};
//# sourceMappingURL=utils.js.map