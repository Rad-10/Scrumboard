import { hasProp, loadScript } from '../../utils';
import { CoordsCannotBeParsedError, GeocoderFailedError, GeolocationUnsupportedError, GoogleMapsAPINotFoundError, IsNotAnObjectError, LocationNotFoundError, ProviderNotSupportedError, QUERY_FIELDS, QUERY_TYPES } from './types';
const GOOGLE_MAPS_SCRIPT_ID = 'google-map';
const providers = {
    google: {
        name: 'Google',
        loadedPromise: null,
        loadedApiKey: '',
        loadAPI(opts) {
            const params = new URLSearchParams(Object.entries({
                key: opts.apiKey,
                region: opts.region,
                language: opts.language,
                libraries: 'places'
            }).filter(([, value]) => value !== undefined)).toString();
            const loadedScript = document.getElementById(GOOGLE_MAPS_SCRIPT_ID);
            if (loadedScript) {
                loadedScript.remove();
                // https://stackoverflow.com/questions/29930274/fixing-you-have-included-the-google-maps-api-multiple-times-on-this-page-this
                delete window.google;
            }
            return new Promise((resolve, reject) => {
                loadScript(`https://maps.googleapis.com/maps/api/js?${params}`, function onLoad() {
                    this.id = GOOGLE_MAPS_SCRIPT_ID;
                    return resolve();
                }, () => reject(new Error(GoogleMapsAPINotFoundError)));
            });
        }
    },
    undefined: {
        name: 'undefined',
        loadedPromise: null,
        loadedApiKey: '',
        loadAPI: data => Promise.reject(new Error(`${ProviderNotSupportedError}: ${data.name}`))
    }
};
export async function loadMapsAPI(name = '', opts) {
    if (typeof opts !== 'object' || !opts) {
        throw new Error(IsNotAnObjectError);
    }
    const provider = providers[name] ?? providers.undefined;
    if (!provider.loadedPromise || provider.loadedApiKey !== opts?.apiKey) {
        provider.loadedApiKey = opts?.apiKey;
        provider.loadedPromise = provider.loadAPI(opts);
    }
    return provider.loadedPromise;
}
export async function getNavigatorPosition() {
    if (!navigator.geolocation)
        throw new Error(GeolocationUnsupportedError);
    return new Promise((resolve, reject) => {
        navigator.geolocation.getCurrentPosition(currentLocation => {
            resolve({
                latitude: currentLocation.coords.latitude,
                longitude: currentLocation.coords.longitude
            });
        }, error => reject(new Error(error.message)));
    });
}
export function toGoogleLatLng(coords) {
    return new google.maps.LatLng(coords.latitude, coords.longitude);
}
/** Returns an array of place prediction objects ('place' can be an establishment, geographic location, or prominent point of interest)
 * and  session token (valid for multiple queries, followed by one place selection).
 */
export async function getPlacePredictions(location, bias = {}) {
    const autocompleteService = new google.maps.places.AutocompleteService();
    const optionalParams = {};
    if (bias?.location) {
        if (bias?.location.center === 'current') {
            await getNavigatorPosition()
                .then(coords => {
                optionalParams.location = toGoogleLatLng(coords);
                optionalParams.radius = bias.location.radius;
            })
                // no-op user didn't allow location
                .catch(() => { });
        }
        else {
            optionalParams.location = toGoogleLatLng(bias.location.center);
            optionalParams.radius = bias.location.radius;
        }
    }
    if (bias?.bounds) {
        const [sw, ne] = bias.bounds;
        optionalParams.bounds = new google.maps.LatLngBounds(toGoogleLatLng(sw), toGoogleLatLng(ne));
    }
    return new Promise((resolve, reject) => {
        const token = new google.maps.places.AutocompleteSessionToken();
        autocompleteService.getPlacePredictions({
            input: location,
            types: QUERY_TYPES,
            sessionToken: token,
            ...optionalParams
        }, (placePredictions, status) => {
            if (status === google.maps.places.PlacesServiceStatus.OK) {
                resolve({ placePredictions: placePredictions ?? [], token });
            }
            else {
                reject(new Error(LocationNotFoundError));
            }
        });
    });
}
export async function getPlace(location, mapElement = document.createElement('div')) {
    const placesService = new google.maps.places.PlacesService(mapElement);
    const { placePredictions, token } = await getPlacePredictions(location);
    return new Promise((resolve, reject) => {
        placesService.getDetails({ placeId: placePredictions[0]?.place_id, fields: QUERY_FIELDS, sessionToken: token }, (place, pStatus) => {
            if (pStatus === google.maps.places.PlacesServiceStatus.OK) {
                resolve({
                    latitude: place?.geometry?.location?.lat() || NaN,
                    longitude: place?.geometry?.location?.lng() || NaN
                });
            }
            else {
                reject(new Error(LocationNotFoundError));
            }
        });
    });
}
export async function getPlaceById(placeId, sessionToken = new google.maps.places.AutocompleteSessionToken(), mapElement = document.createElement('div')) {
    const placesService = new google.maps.places.PlacesService(mapElement);
    return new Promise((resolve, reject) => {
        placesService.getDetails({ placeId, fields: QUERY_FIELDS, sessionToken }, (place, pStatus) => {
            if (pStatus === google.maps.places.PlacesServiceStatus.OK) {
                resolve({
                    name: place?.name,
                    address: place?.formatted_address,
                    latitude: place?.geometry?.location?.lat() || NaN,
                    longitude: place?.geometry?.location?.lng() || NaN
                });
            }
            else {
                reject(new Error(LocationNotFoundError));
            }
        });
    });
}
/** Returns coordinations for given input: either coords, address or current position.  */
export async function getCoords(coords, mapElement) {
    if (coords === '' || coords === undefined)
        throw new Error();
    if (coords === 'current')
        return getNavigatorPosition();
    let location;
    if (typeof coords === 'string') {
        const [lat, lng] = coords.split(',', 2).map(Number);
        if (Number.isNaN(lat) || Number.isNaN(lng) || lat === undefined || lng === undefined)
            return getPlace(coords, mapElement);
        location = { latitude: lat, longitude: lng };
    }
    else {
        location = coords;
    }
    if (Number.isFinite(location.latitude) && Number.isFinite(location.longitude))
        return location;
    throw new Error(CoordsCannotBeParsedError);
}
export async function getAddress(coords) {
    const location = {
        lat: coords.latitude,
        lng: coords.longitude
    };
    const geocoder = new google.maps.Geocoder();
    return new Promise((resolve, reject) => {
        geocoder.geocode({ location }, (results, status) => {
            if (status === 'OK') {
                const [result] = results ?? [];
                if (result) {
                    resolve({
                        name: result.formatted_address,
                        address: result.formatted_address,
                        ...(result.geometry && {
                            latitude: result.geometry.location.lat(),
                            longitude: result.geometry.location.lng()
                        })
                    });
                }
                else {
                    resolve({
                        name: `${coords.latitude}, ${coords.longitude}`,
                        latitude: coords.latitude,
                        longitude: coords.longitude
                    });
                }
            }
            else {
                reject(new Error(`${GeocoderFailedError}: ${status}`));
            }
        });
    });
}
export const isLatLngObject = (obj) => {
    return (!!obj &&
        typeof obj === 'object' &&
        hasProp(obj, 'lat') &&
        typeof obj.lat === 'function' &&
        hasProp(obj, 'lng') &&
        typeof obj.lng === 'function');
};
//# sourceMappingURL=utils.js.map