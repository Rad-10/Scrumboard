import { jsx as _jsx } from "react/jsx-runtime";
import { forwardRef } from 'react';
import styled, { css } from 'styled-components';
import { defaultThemeProp } from '../../theme';
const prefix = (value) => {
    if (['between', 'around', 'evenly'].includes(value))
        return `space-${value}`;
    if (['start', 'end'].includes(value))
        return `flex-${value}`;
    return value;
};
const getContainerStyles = (container) => {
    if (!container)
        return '';
    if (container === true) {
        return css `
      display: flex;
    `;
    }
    if (container && typeof container === 'object') {
        const isRow = !container.direction || container.direction.includes('row');
        const isReverse = container.direction && container.direction.includes('reverse');
        return css `
      display: ${container.inline ? 'inline-flex' : 'flex'};

      ${container.pad !== undefined &&
            css `
        /* stylelint-disable function-name-case, function-whitespace-after */
        padding: ${({ theme: { base: { spacing } } }) => (Array.isArray(container.pad) ? container.pad : [container.pad])
                .map(p => `calc(${p} * ${spacing})`)
                .join(' ')};

        /* stylelint-enable function-name-case, function-whitespace-after */
      `}

      ${container.direction &&
            css `
        flex-direction: ${container.direction};
      `}

      ${container.justify &&
            css `
        justify-content: ${prefix(container.justify)};
      `}

      ${container.wrap &&
            css `
        flex-wrap: ${container.wrap};
      `}

      ${container.alignItems &&
            css `
        align-items: ${prefix(container.alignItems)};
      `}

      ${container.alignContent &&
            css `
        align-content: ${prefix(container.alignContent)};
      `}

      ${container.itemGap &&
            css `
          > * {
            margin-${isRow ? 'inline-start' : 'block-start'}: calc(${container.itemGap} * ${props => props.theme.base.spacing});
            ${isReverse ? ':last-child' : ':first-child'} {
              margin-${isRow ? 'inline-start' : 'block-start'}: 0;
            }
          }
        `}

      ${container.gap !== undefined &&
            css `
        gap: calc(${container.gap} * ${props => props.theme.base.spacing});
      `}

      ${container.colGap !== undefined &&
            css `
        column-gap: calc(${container.colGap} * ${props => props.theme.base.spacing});
      `}

      ${container.rowGap !== undefined &&
            css `
        row-gap: calc(${container.rowGap} * ${props => props.theme.base.spacing});
      `}
    `;
    }
};
const getItemStyles = (item) => {
    return css `
    ${item &&
        css `
      max-width: 100%;
      min-width: 0;

      ${item.grow !== undefined &&
            css `
        flex-grow: ${item.grow};
      `}

      ${item.shrink !== undefined &&
            css `
        flex-shrink: ${item.shrink};
      `}

      ${item.alignSelf &&
            css `
        align-self: ${prefix(item.alignSelf)};
      `}

      ${item.basis &&
            css `
        flex-basis: ${item.basis};
      `}
    `}
  `;
};
const breakpointOrder = ['xs', 'sm', 'md', 'lg', 'xl'];
export const StyledFlex = styled.div(({ container, item, theme: { base: { breakpoints: themeBreakpoints } }, xs, sm, md, lg, xl }) => {
    const breakpoints = {
        xs,
        sm,
        md,
        lg,
        xl
    };
    return css `
      ${getContainerStyles(container)}
      ${getItemStyles(item)}

    ${breakpointOrder.map(breakpoint => breakpoints[breakpoint] &&
        css `
            @media screen and (min-width: ${themeBreakpoints[breakpoint]}) {
              ${getContainerStyles(breakpoints[breakpoint]?.container)}
              ${getItemStyles(breakpoints[breakpoint]?.item)}
            }
          `)}
    `;
});
StyledFlex.defaultProps = defaultThemeProp;
const Flex = forwardRef((props, ref) => {
    return _jsx(StyledFlex, { ...props, ref: ref });
});
export default Flex;
//# sourceMappingURL=Flex.js.map