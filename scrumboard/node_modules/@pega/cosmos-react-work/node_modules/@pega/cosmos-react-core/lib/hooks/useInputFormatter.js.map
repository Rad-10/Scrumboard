{"version":3,"file":"useInputFormatter.js","sourceRoot":"","sources":["../../src/hooks/useInputFormatter.ts"],"names":[],"mappings":"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","sourcesContent":["import { RefObject, useRef, useEffect } from 'react';\n\nimport useEvent from './useEvent';\n\n/**\n * Formats the raw value using given formatter and handles the caret position.\n * @param ref reference to input element.\n * @param rawValue value to be formatted.\n * @param formatter formatter function accepting partial input and returning partially formatted value.\n * @param acceptableCharacters string containing all the characters that may appear in the value to format. RegExp shorthands are also accepted. Only numbers are accepted by default.\n * @returns formatted value that should be passed to the input component.\n */\nconst useInputFormatter = (\n  ref: RefObject<HTMLInputElement>,\n  rawValue: string,\n  formatter: (value: string) => string,\n  acceptableCharacters: string = '\\\\p{N}'\n) => {\n  // synthetic caret position in unformatted value\n  const rawValueCaretPositionRef = useRef<number>();\n\n  useEvent(\n    'keydown',\n    e => {\n      const inputEl = ref.current;\n      if (inputEl) {\n        const caretPositionStart = inputEl.selectionStart ?? 0;\n        const caretPositionEnd = inputEl.selectionEnd ?? 0;\n        const currentValue = inputEl.value;\n        if (caretPositionStart !== caretPositionEnd && ['Backspace', 'Delete'].includes(e.key)) {\n          // if selection contains only formatting characters, move the caret to the beginning of the selection\n          const selectedText = currentValue.slice(caretPositionStart, caretPositionEnd);\n          if (!new RegExp(`[${acceptableCharacters}]`, 'gu').test(selectedText)) {\n            inputEl.setSelectionRange(caretPositionStart, caretPositionStart);\n            e.preventDefault();\n          }\n          return;\n        }\n\n        if (\n          e.key === 'Backspace' &&\n          new RegExp(`[^${acceptableCharacters}]`, 'gu').test(\n            currentValue.charAt(caretPositionStart - 1)\n          )\n        ) {\n          const lastNonFormatChar = new RegExp(\n            `[${acceptableCharacters}](?=[^${acceptableCharacters}]*$)`,\n            'gu'\n          );\n          // match last non-formatting character if it can be found in the preceding slice\n          if (lastNonFormatChar.test(currentValue.slice(0, caretPositionStart))) {\n            // move the caret after matched character to get it removed\n            inputEl.setSelectionRange(lastNonFormatChar.lastIndex, lastNonFormatChar.lastIndex);\n          } else {\n            e.preventDefault();\n          }\n        }\n\n        if (\n          e.key === 'Delete' &&\n          new RegExp(`[^${acceptableCharacters}]`, 'gu').test(currentValue.charAt(caretPositionEnd))\n        ) {\n          const firstNonFormatChar = new RegExp(`[${acceptableCharacters}]`, 'gu');\n          firstNonFormatChar.lastIndex = caretPositionEnd;\n          // find first non-formatting character in the value starting from the caret position\n          if (firstNonFormatChar.test(currentValue)) {\n            // move the caret before matched character to get it removed\n            inputEl.setSelectionRange(\n              firstNonFormatChar.lastIndex - 1,\n              firstNonFormatChar.lastIndex - 1\n            );\n          } else {\n            e.preventDefault();\n          }\n        }\n      }\n    },\n    { target: ref, dependencies: [acceptableCharacters] }\n  );\n\n  useEvent(\n    'input',\n    () => {\n      const inputEl = ref.current;\n      if (inputEl) {\n        // calculate new synthetic caret position in the unformatted value\n        const currentCaretPosition = inputEl.selectionStart ?? 0;\n        rawValueCaretPositionRef.current = inputEl.value\n          .slice(0, currentCaretPosition)\n          .replace(new RegExp(`[^${acceptableCharacters}]`, 'gu'), '').length;\n      }\n    },\n    { target: ref, dependencies: [acceptableCharacters] }\n  );\n\n  useEffect(() => {\n    const inputEl = ref.current;\n    if (inputEl && rawValueCaretPositionRef.current !== undefined) {\n      // create regexp with every raw value character wrapped in possible formatting characters\n      const rawValueRegExpSource = `[^${acceptableCharacters}]*${rawValue\n        .slice(0, rawValueCaretPositionRef.current)\n        .split('')\n        .join(`[^${acceptableCharacters}]*`)}`;\n      const match = inputEl.value.match(new RegExp(rawValueRegExpSource, 'gu'));\n      if (match) {\n        // if it matches move the real caret to the corresponding index in the raw value\n        inputEl.setSelectionRange(match[0].length, match[0].length);\n      } else {\n        // just re-position the caret otherwise\n        inputEl.setSelectionRange(\n          rawValueCaretPositionRef.current,\n          rawValueCaretPositionRef.current\n        );\n      }\n      rawValueCaretPositionRef.current = undefined;\n    }\n  }, [rawValue, acceptableCharacters]);\n\n  return formatter(rawValue);\n};\n\nexport default useInputFormatter;\n"]}