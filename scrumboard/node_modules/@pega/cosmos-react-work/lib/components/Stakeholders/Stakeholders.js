import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import { forwardRef, useRef, useEffect, useMemo, useState, useCallback } from 'react';
import styled from 'styled-components';
import { createPortal } from 'react-dom';
import { SummaryList, useI18n, Button, ViewAll, Modal, Popover, Flex, Text, useModalManager, useOuterEvent, Progress, useAfterInitialEffect } from '@pega/cosmos-react-core';
import StakeholderForm from './StakeholderForm';
const StyledStakeholders = styled(SummaryList) ``;
const StyledEditFormWrap = styled.div `
  position: relative;
  min-height: 8rem;

  &[aria-busy='true'] > :nth-child(2) {
    visibility: hidden;
  }
`;
const StyledPopover = styled(Popover) `
  width: 40ch;
  min-height: 12rem;
`;
const Stakeholders = forwardRef(({ items: itemsProp, count, loading, onAddNew, form, onViewAll, viewAll, error, ...restProps }, ref) => {
    const { create: createModal } = useModalManager();
    const t = useI18n();
    const modalMethods = useRef();
    const [mode, setMode] = useState();
    const [editing, setEditing] = useState(false);
    const [viewAllSearchValue, setViewAllSearchValue] = useState('');
    const popoverRef = useRef(null);
    const progressMsgRef = useRef(t('loading'));
    // Why? Don't think this should trigger a re-render. We just need the value when we invoke callback props.
    const selectedRoleNameRef = useRef();
    // Setter for the ref. Avoids a re-render.
    const setSelectedRoleNameRef = useCallback((selectedRoleName) => {
        selectedRoleNameRef.current = selectedRoleName;
    }, []);
    const [popoverTarget, setPopoverTarget] = useState(null);
    const itemElsRef = useRef({
        itemEls: [],
        viewAllItemEls: []
    });
    // This function merges the pre-defined actions(add & edit) to the item object.
    const mergeItemActions = (items) => {
        return items.map(({ onEdit, onRemove, ...rest }, i) => {
            let itemActions = [];
            const elArray = itemElsRef.current[mode === 'viewAll' ? 'viewAllItemEls' : 'itemEls'];
            if (onEdit) {
                itemActions = [
                    {
                        id: 'edit',
                        text: t('edit'),
                        icon: 'pencil',
                        onClick: () => {
                            setEditing(true);
                            setPopoverTarget({
                                portal: elArray[i],
                                button: elArray[i].querySelector('button[aria-haspopup="menu"]')
                            });
                            onEdit?.();
                        }
                    }
                ];
            }
            if (onRemove) {
                itemActions = [
                    ...itemActions,
                    {
                        id: 'remove',
                        text: t('remove'),
                        icon: 'trash',
                        onClick: () => {
                            onRemove?.();
                        }
                    }
                ];
            }
            return {
                ...rest,
                ref: (el) => {
                    elArray[i] = el;
                },
                actions: itemActions
            };
        });
    };
    const closePopover = () => {
        if (!popoverTarget || (form.loading && progressMsgRef.current === t('submitting')))
            return;
        popoverTarget.button?.focus();
        setPopoverTarget(null);
        setEditing(false);
        progressMsgRef.current = t('loading');
    };
    let formContent = null;
    if ((mode === 'add' || editing) &&
        (!form.loading || progressMsgRef.current === t('submitting'))) {
        formContent = (_jsx(StakeholderForm, { roles: form.roles, currentRole: form.currentRole, renderer: form.renderer, rendererProps: form.rendererProps, setSelectedRoleNameRef: setSelectedRoleNameRef }));
    }
    // Actions used for add and edit both in the modal and the popover.
    let formActions = null;
    if ((mode === 'add' || editing) &&
        (!form.loading || progressMsgRef.current === t('submitting'))) {
        const closeForm = () => {
            if (mode === 'add') {
                modalMethods.current?.dismiss();
            }
            else {
                closePopover();
            }
        };
        formActions = (_jsxs(_Fragment, { children: [_jsx(Button, { disabled: form.loading, onClick: () => {
                        form.onDismiss({ closeForm });
                    }, children: t('cancel') }), _jsx(Button, { disabled: form.loading, type: 'submit', variant: 'primary', onClick: () => {
                        progressMsgRef.current = t('submitting');
                        form.onSubmit({
                            selectedRoleName: selectedRoleNameRef.current,
                            closeForm
                        });
                    }, children: t('submit') })] }));
    }
    // Content for the modal either for adding new or viewing all.
    let modalContent = null;
    if (mode === 'add')
        modalContent = formContent;
    if (!viewAll.loading && (mode === 'viewAll' || (editing && modalMethods.current))) {
        modalContent = (_jsx(ViewAll, { items: mergeItemActions(viewAll.items), actions: [
                {
                    id: 'addStakeHolder',
                    text: 'Add new',
                    onClick: () => {
                        setMode('add');
                        onAddNew?.();
                    }
                }
            ], searchInputProps: viewAll.onSearch
                ? {
                    value: viewAllSearchValue,
                    onSearchChange: (value) => {
                        setViewAllSearchValue(value);
                        viewAll?.onSearch?.(value);
                    }
                }
                : undefined }));
    }
    useEffect(() => {
        if (!mode) {
            modalMethods.current = undefined;
            return;
        }
        const modalProps = {
            progress: (mode === 'add' && form.loading) || viewAll.loading
                ? { message: progressMsgRef.current }
                : undefined,
            count: mode === 'viewAll' ? count : undefined,
            children: modalContent,
            actions: mode === 'add' ? formActions : undefined,
            onRequestDismiss: form.loading && progressMsgRef.current === t('submitting') ? () => false : undefined
        };
        if (modalMethods.current) {
            modalMethods.current.update(modalProps);
        }
        else if (mode === 'add' || mode === 'viewAll') {
            modalMethods.current = createModal(Modal, {
                ...modalProps,
                heading: mode === 'add' ? t('add_stakeholders') : t('view_stakeholders'),
                onAfterClose: () => {
                    if (mode === 'add') {
                        form.onAfterClose?.();
                    }
                    else {
                        setViewAllSearchValue('');
                        viewAll.onAfterClose?.();
                    }
                    progressMsgRef.current = t('loading');
                    setMode(undefined);
                }
            });
        }
    }, [mode, modalContent, form.loading, formActions, count, viewAll.loading]);
    // Using mousedown instead of click since drag selecting an input's value within the popover, then releasing outside the popover triggers outer click.
    useOuterEvent('mousedown', [popoverRef], closePopover);
    let editPopover = null;
    if (popoverTarget) {
        editPopover = (_jsx(StyledPopover, { ref: popoverRef, target: popoverTarget.button, placement: 'auto', role: 'dialog', children: _jsxs(Flex, { container: { direction: 'column', gap: 2, pad: 2 }, children: [_jsx(Text, { variant: 'h3', children: t('edit_stakeholder') }), _jsxs(StyledEditFormWrap, { "aria-busy": form.loading ? 'true' : 'false', children: [_jsx(Progress, { placement: 'local', visible: form.loading, message: progressMsgRef.current }), (!form.loading || progressMsgRef.current === t('submitting')) && (_jsx(StakeholderForm, { roles: form.roles, currentRole: form.currentRole, renderer: form.renderer, rendererProps: form.rendererProps, setSelectedRoleNameRef: setSelectedRoleNameRef }))] }), formActions && _jsx(Flex, { container: { justify: 'between' }, children: formActions })] }) }));
    }
    const onKeydown = (e) => {
        if (e.key === 'Escape') {
            closePopover();
        }
    };
    useEffect(() => {
        if (!popoverTarget)
            return;
        document.addEventListener('keydown', onKeydown);
        return () => {
            document.removeEventListener('keydown', onKeydown);
        };
    }, [popoverTarget]);
    useAfterInitialEffect(() => {
        if (!popoverTarget)
            form.onAfterClose?.();
    }, [popoverTarget]);
    return (_jsxs(_Fragment, { children: [_jsx(StyledStakeholders, { ...restProps, ref: ref, icon: 'person', name: t('view_stakeholders'), loading: loading, count: count, error: error, items: useMemo(() => mergeItemActions(itemsProp.slice(0, 3)), [mergeItemActions, itemsProp]), actions: onAddNew
                    ? [
                        {
                            text: t('add_stakeholders'),
                            id: 'add_new',
                            icon: 'plus',
                            onClick() {
                                setMode('add');
                                onAddNew?.();
                            }
                        }
                    ]
                    : undefined, onViewAll: onViewAll && count && count > 3
                    ? () => {
                        setMode('viewAll');
                        onViewAll?.();
                    }
                    : undefined }), popoverTarget && createPortal(editPopover, popoverTarget.portal)] }));
});
export default Stakeholders;
//# sourceMappingURL=Stakeholders.js.map