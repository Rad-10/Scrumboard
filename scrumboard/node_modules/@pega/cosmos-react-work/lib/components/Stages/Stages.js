import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useState, useRef, useEffect, forwardRef, Fragment } from 'react';
import { remToPx } from 'polished';
import { Icon, registerIcon, Flex, useElement, useOuterEvent, useI18n, Button, Modal, useBreakpoint, debounce, useModalManager, useEscape, useConsolidatedRef, CardFooter, Card, useUID, Progress } from '@pega/cosmos-react-core';
import * as checkIcon from '@pega/cosmos-react-core/lib/components/Icon/icons/check.icon';
import StageGlimpse from './StageGlimpse';
import { StyledInnerStage, StyledPopoverContent, StyledStage, StyledStagePopover, StyledStages } from './Stages.styles';
registerIcon(checkIcon);
const Stages = forwardRef(({ current, stages, caseTitle, onLoadStage, ...restProps }, ref) => {
    const t = useI18n();
    const stagesRef = useConsolidatedRef(ref);
    const [focusedStageIndex, setFocusedStageIndex] = useState(undefined);
    const focusedStageRef = useRef(null);
    const { create: createModal } = useModalManager();
    const modalMethods = useRef();
    const [popoverEl, setPopoverRef] = useElement();
    const [showPopover, setShowPopover] = useState(false);
    const isSmallOrAbove = useBreakpoint('sm');
    const [compressedView, setCompressedView] = useState(false);
    const [minExpandedWidth, setMinExpandedWidth] = useState(0);
    const popoverId = useUID();
    useEffect(() => {
        if (stagesRef.current) {
            if (compressedView) {
                const resizeObserver = new ResizeObserver(debounce((entries) => {
                    if (entries[0].contentRect.width > minExpandedWidth) {
                        setCompressedView(false);
                    }
                }, 100));
                resizeObserver.observe(stagesRef.current);
                return () => resizeObserver.disconnect();
            }
            const intersectionObserver = new IntersectionObserver(entries => {
                if (!entries[0].isIntersecting) {
                    setCompressedView(true);
                    if (entries[0].rootBounds)
                        setMinExpandedWidth(entries[0].rootBounds.width);
                }
            }, {
                root: stagesRef.current,
                rootMargin: remToPx(0.0625),
                threshold: 1
            });
            if (stagesRef.current.lastElementChild) {
                intersectionObserver.observe(stagesRef.current.lastElementChild);
                return () => intersectionObserver.disconnect();
            }
        }
    }, [minExpandedWidth, compressedView, stages.length]);
    useOuterEvent('mousedown', [popoverEl, focusedStageRef], () => {
        setShowPopover(false);
    });
    useEscape(() => {
        setShowPopover(false);
        focusedStageRef.current?.focus();
    }, stagesRef);
    const stagesToLoad = onLoadStage
        ? stages.filter(stage => !Array.isArray(stage.steps)).map(stage => stage.id)
        : [];
    const openModal = () => {
        setShowPopover(false);
        if (stagesToLoad.length > 0)
            onLoadStage?.(stagesToLoad);
        modalMethods.current = createModal(Modal, {
            heading: caseTitle
                ? t('stages_case_lifecycle', [caseTitle])
                : t('stages_default_case_lifecycle'),
            progress: stagesToLoad.length > 0,
            children: stages.map(stage => _jsx(StageGlimpse, { stage: stage }, stage.id)),
            onBeforeClose: () => {
                focusedStageRef.current?.focus();
                modalMethods.current = undefined;
            }
        });
    };
    useEffect(() => {
        modalMethods.current?.update({
            progress: stagesToLoad.length > 0,
            children: stages.map(stage => _jsx(StageGlimpse, { stage: stage }, stage.id))
        });
    }, [stagesToLoad.length]);
    return (_jsx(Flex, { ...restProps, container: true, as: StyledStages, ref: stagesRef, role: 'region', "aria-label": t('stages_label'), children: stages.map((stage, index) => {
            const isCurrent = stage.id === current;
            let stageStatusText = t(stage.completed ? 'completed' : 'not_started');
            if (isCurrent)
                stageStatusText = t('current');
            const hasToLoad = stagesToLoad.includes(stage.id);
            return (_jsxs(Fragment, { children: [_jsxs(Flex, { container: { justify: 'center', alignItems: 'center' }, as: StyledStage, item: {
                            grow: compressedView && !isCurrent ? 0 : 1,
                            shrink: compressedView && isCurrent ? 1 : 0
                        }, "aria-current": isCurrent ? 'step' : undefined, "aria-label": t('stages_stage_label', [stage.name, stageStatusText]), onClick: () => {
                            if (isSmallOrAbove) {
                                if (hasToLoad)
                                    onLoadStage?.([stage.id]);
                                setShowPopover(prevShowPopover => !prevShowPopover);
                            }
                            else {
                                openModal();
                            }
                        }, onFocus: (e) => {
                            setShowPopover(false);
                            setFocusedStageIndex(index);
                            focusedStageRef.current = e.currentTarget;
                        }, "aria-expanded": showPopover && isSmallOrAbove, "aria-controls": showPopover ? popoverId : undefined, children: [stage.completed && _jsx(Icon, { name: 'check' }), (!compressedView || isCurrent || !stage.completed) && (_jsx(StyledInnerStage, { ellipsis: isCurrent && compressedView, children: !isCurrent && compressedView ? index + 1 : stage.name }))] }), focusedStageIndex === index && showPopover && isSmallOrAbove && (_jsx(StyledStagePopover, { target: focusedStageRef.current, ref: setPopoverRef, arrow: true, placement: 'bottom-start', modifiers: [
                            {
                                name: 'flip',
                                options: {
                                    fallbackPlacements: ['bottom-end', 'right', 'left']
                                }
                            }
                        ], id: popoverId, "aria-busy": hasToLoad, children: _jsxs(Card, { children: [_jsx(StyledPopoverContent, { children: !hasToLoad ? (_jsx(StageGlimpse, { stage: stage, actions: [
                                            {
                                                id: 'close',
                                                text: t('close'),
                                                icon: 'times',
                                                onClick: () => {
                                                    setShowPopover(false);
                                                    focusedStageRef.current?.focus();
                                                }
                                            }
                                        ] })) : (_jsx(Progress, { placement: 'local', message: t('loading') })) }), _jsx(CardFooter, { children: _jsx(Button, { variant: 'secondary', onClick: openModal, children: t('stages_see_full_lifecycle') }) })] }) }))] }, stage.id));
        }) }));
});
export default Stages;
//# sourceMappingURL=Stages.js.map