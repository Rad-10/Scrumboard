import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import { forwardRef, useMemo, useState, useEffect, useRef } from 'react';
import styled, { css } from 'styled-components';
import { defaultThemeProp, Modal, Tag, Button, useI18n, Count, Flex, Text, CardHeader, Card, Actions, Icon, registerIcon, CardContent, Progress, EmptyState, ErrorState, Popover, Menu, useModalManager, useModalContext, useConsolidatedRef, CardFooter, Banner } from '@pega/cosmos-react-core';
import * as tagIcon from '@pega/cosmos-react-core/lib/components/Icon/icons/tag.icon';
import { StyledTag } from '@pega/cosmos-react-core/lib/components/Badges/Tag';
import { StyledCardContent } from '@pega/cosmos-react-core/lib/components/Card/CardContent';
import MultiSelectInput from '@pega/cosmos-react-core/lib/components/ComboBox/MultiSelectInput/MultiSelectInput';
import { StyledCardFooter } from '@pega/cosmos-react-core/lib/components/Card/CardFooter';
registerIcon(tagIcon);
export const StyledTags = styled.article(({ isLoading, theme, viewAll }) => {
    return css `
      ${StyledCardContent} {
        max-height: ${viewAll ? 'fit-content' : '10rem'};
        overflow-y: hidden;
      }

      ${StyledCardFooter} {
        margin-block-start: ${theme.base.spacing};
      }

      ${StyledTag} {
        cursor: pointer;
      }

      ${isLoading &&
        css `
        & > ${StyledCardContent} {
          height: 4rem;
        }
      `}
    `;
});
StyledTags.defaultProps = defaultThemeProp;
const StyledMenuPopover = styled.div `
  width: 40ch;
`;
const StyledBanner = styled(Banner)(({ theme }) => {
    return css `
    padding-block-end: calc(2 * ${theme.base.spacing});
  `;
});
StyledBanner.defaultProps = defaultThemeProp;
const EditTagModal = ({ tags, availableTags = [], onSearch, onEditTags }) => {
    const { dismiss } = useModalContext();
    const inputRef = useRef(null);
    const [filterValue, setFilterValue] = useState('');
    const [editError, setEditError] = useState('');
    const [selected, setSelected] = useState([]);
    const [items, setItems] = useState([]);
    const [pauseSelectedDescendantEvaluation, setPauseSelectedDescendantEvaluation] = useState(true);
    const t = useI18n();
    const showMenu = !!filterValue && !!items?.length;
    const selectedTagValues = useMemo(() => {
        return selected.map(({ text }) => {
            return { id: text, text };
        });
    }, [selected]);
    useEffect(() => {
        if (showMenu) {
            setPauseSelectedDescendantEvaluation(true);
        }
    }, [showMenu]);
    useEffect(() => {
        setSelected(tags.map(tag => {
            return { text: tag };
        }));
    }, [tags]);
    useEffect(() => {
        const menuItems = availableTags
            .filter(tag => !selected.some(x => x.text === tag))
            .map(tag => {
            return { id: tag, primary: tag };
        });
        if (filterValue &&
            !menuItems.some(x => x.id === filterValue) &&
            !selected.some(x => x.text === filterValue)) {
            menuItems.push({
                id: `custom:${filterValue}`,
                primary: t('use_input_value', [filterValue])
            });
        }
        setItems(menuItems);
    }, [availableTags, filterValue, selected]);
    const setInputValue = (value) => {
        setEditError('');
        setFilterValue(value);
        onSearch?.(value);
    };
    const addTag = (tag) => {
        if (tag && !selected.find(x => x.text === tag)) {
            if (items.find(x => x.id === tag)) {
                setSelected(curr => [...curr, { text: tag }]);
            }
            else {
                setSelected(curr => [...curr, { text: tag, newTag: true }]);
            }
            setInputValue('');
        }
    };
    const handlePaste = (e) => {
        const potentialTags = e.clipboardData.getData('Text').split(' ');
        potentialTags.forEach(potentialTag => {
            addTag(potentialTag);
        });
    };
    const handleKeyDown = (e) => {
        if (e.key === ' ') {
            addTag(filterValue);
        }
    };
    return (_jsxs(Modal, { heading: t('edit_tags'), actions: _jsxs(_Fragment, { children: [_jsx(Button, { onClick: dismiss, children: t('cancel') }), _jsx(Button, { variant: 'primary', onClick: () => {
                        onEditTags(selected)
                            .then(dismiss)
                            .catch((error) => {
                            if (error instanceof Error) {
                                setEditError(error.message || t('unknown_error'));
                            }
                            else {
                                setEditError(t('unknown_error'));
                            }
                        });
                    }, children: t('submit') })] }), children: [editError && (_jsx(StyledBanner, { id: 'edit-tags-error', variant: 'urgent', messages: [editError], onDismiss: () => {
                    setEditError('');
                } })), _jsx(MultiSelectInput, { ref: inputRef, selected: selectedTagValues, value: filterValue, onChange: (e) => {
                    setInputValue(e.target.value.trim());
                }, onRemove: (id, index) => {
                    if (selected[index].text === id) {
                        const updatedSelected = [...selected];
                        updatedSelected.splice(index, 1);
                        setSelected(updatedSelected);
                        setEditError('');
                    }
                }, onBlur: () => {
                    setPauseSelectedDescendantEvaluation(true);
                    setInputValue('');
                }, onPaste: handlePaste, onKeyDown: handleKeyDown, onSelectedBlur: () => {
                    setPauseSelectedDescendantEvaluation(true);
                }, onSelectedFocus: () => {
                    setPauseSelectedDescendantEvaluation(false);
                }, pauseDescendantEvaluation: pauseSelectedDescendantEvaluation, autoFocus: true }), _jsx(Popover, { as: StyledMenuPopover, show: showMenu, target: inputRef.current, placement: 'bottom-start', modifiers: [
                    {
                        name: 'flip',
                        enabled: true,
                        options: {
                            fallbackPlacements: ['top-start']
                        }
                    },
                    {
                        name: 'preventOverflow',
                        enabled: true
                    },
                    {
                        name: 'hide',
                        enabled: false
                    }
                ], onMouseDown: (e) => e.preventDefault(), children: _jsx(Menu, { role: 'listbox', mode: 'action', items: items, focusControlEl: inputRef.current || undefined, onItemClick: id => {
                        if (id.includes('custom:')) {
                            const tagValue = id.replace('custom:', '');
                            if (!selected.some(x => x.text === tagValue)) {
                                setSelected(curr => [...curr, { text: tagValue, newTag: true }]);
                            }
                        }
                        else {
                            setSelected(curr => [...curr, { text: id }]);
                        }
                        setInputValue('');
                    }, arrowNavigationUnsupported: true }) })] }));
};
const Tags = forwardRef(({ tags, availableTags, loading, error, onSearch, onTagClick, onEditTags, ...restProps }, ref) => {
    const { create: createModal } = useModalManager();
    const editModalMethods = useRef();
    const containerRef = useRef(null);
    const contentRef = useRef(null);
    const consolidatedRef = useConsolidatedRef(containerRef, ref);
    const [footer, setFooter] = useState(false);
    const [viewAll, setViewAll] = useState(false);
    const t = useI18n();
    useEffect(() => {
        if (containerRef.current && contentRef.current) {
            if (contentRef.current.getBoundingClientRect().bottom >
                containerRef.current.getBoundingClientRect().bottom) {
                setFooter(true);
            }
            else {
                setFooter(false);
            }
        }
    }, [containerRef.current, contentRef.current, tags]);
    useEffect(() => {
        if (!onEditTags) {
            editModalMethods.current?.dismiss();
        }
        else {
            editModalMethods.current?.update({
                tags,
                availableTags,
                onSearch,
                onEditTags
            });
        }
    }, [availableTags, tags, onSearch, onEditTags]);
    const openEditModal = () => {
        if (!onEditTags)
            return;
        editModalMethods.current = createModal(EditTagModal, {
            tags,
            availableTags,
            onSearch,
            onEditTags
        });
    };
    const content = useMemo(() => {
        if (loading) {
            return _jsx(Progress, { placement: 'local' });
        }
        if (error) {
            if (typeof error === 'boolean')
                return _jsx(ErrorState, {});
            if (typeof error === 'string')
                return _jsx(ErrorState, { message: error });
            return _jsx(ErrorState, { ...error });
        }
        return tags.length > 0 ? (_jsx(Flex, { ref: contentRef, container: { gap: 1, wrap: 'wrap' }, children: tags.map(tag => {
                return (_jsx(Tag, { onClick: () => onTagClick?.(tag), children: tag }, tag));
            }) })) : (_jsx(EmptyState, {}));
    }, [loading, error, tags]);
    return (_jsxs(Card, { ref: consolidatedRef, ...restProps, as: StyledTags, viewAll: viewAll, isLoading: loading, children: [_jsxs(CardHeader, { children: [_jsxs(Flex, { container: { alignItems: 'center', gap: 1 }, children: [_jsx(Icon, { name: 'tag' }), _jsx(Text, { variant: 'h2', children: t('tags') }), _jsx(Count, { children: tags.length })] }), _jsx(Actions, { items: onEditTags
                            ? [
                                {
                                    id: 'editTags',
                                    text: t('edit_tags'),
                                    icon: 'pencil',
                                    onClick: openEditModal,
                                    disabled: !!error
                                }
                            ]
                            : [] })] }), _jsx(CardContent, { children: content }), footer && (_jsx(CardFooter, { justify: 'center', children: _jsx(Button, { variant: 'link', onClick: () => setViewAll(curr => !curr), children: viewAll ? t('view_less') : t('view_all') }) }))] }));
});
export default Tags;
//# sourceMappingURL=Tags.js.map