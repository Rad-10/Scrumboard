import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { useEffect, useMemo, useRef, useLayoutEffect, useState } from 'react';
import { Button, Flex, Grid, Icon, registerIcon, TabPanel, useBreakpoint, useScrollStick, useElement, Card, Drawer, useI18n, useDirection, Tabs, useAfterInitialEffect, windowIsAvailable } from '@pega/cosmos-react-core';
import * as moveRightSolidIcon from '@pega/cosmos-react-core/lib/components/Icon/icons/move-right-solid.icon';
import * as moveLeftSolidIcon from '@pega/cosmos-react-core/lib/components/Icon/icons/move-left-solid.icon';
import CaseSummary from './CaseSummary';
import UtilitiesSummary from './UtilitiesSummary';
import { StyledCaseDrawer, StyledCaseDrawerContent, StyledCaseView, StyledWorkArea, StyledPersistentUtility, StyledSummary, StyledUtilities, StyledUtilToggle } from './CaseView.styles';
import CaseViewContext from './CaseView.context';
registerIcon(moveRightSolidIcon, moveLeftSolidIcon);
const CaseView = ({ 
// Case data mostly visually related to the case header
caseId, heading, subheading, caseLink, parentCases, icon, followed, onFollowedChange, onEdit, actions, promotedActions, 
// Summary content and state props
summary, summaryExpanded: summaryExpandedProp = true, onToggleSummary, 
// Case tabs
tabs: { currentTabId, items: tabItemsProp, onClick: onTabClick }, 
// Workarea related content props
banners, stages, tasks, tabContent: tabContentProp = [], 
// Utilities content and state props
utilities, utilitiesSummaryItems, utilitiesExpanded: utilitiesExpandedProp = true, onToggleUtilities, 
// Etc...
persistentUtility, intelligentGuidance, isPreview = false, ...restProps }) => {
    // General util hooks
    const t = useI18n();
    const direction = useDirection();
    // Element refs
    const caseViewRef = useRef(null);
    const summaryRef = useRef(null);
    // Tab content
    const [tabContentEl, setTabContentEl] = useElement(null);
    // Breakpoint booleans
    const mdOrAbove = useBreakpoint('md', { breakpointRef: caseViewRef });
    const lgOrAbove = useBreakpoint('lg', { breakpointRef: caseViewRef });
    const xlOrAbove = useBreakpoint('xl', { breakpointRef: caseViewRef });
    // DOM ids
    const summaryTabId = `summary-${caseId}`;
    const utilitiesTabId = `utilities-${caseId}`;
    const persistentUtilityTabId = `persistent-utility-${caseId}`;
    const summaryId = `summary-${caseId}`;
    const utilitiesId = `utilities-${caseId}`;
    const utilitiesDrawerId = `utilities-drawer-${caseId}`;
    // Summary state handling
    let summaryExpanded = !!summaryExpandedProp;
    if (persistentUtility) {
        summaryExpanded = xlOrAbove;
    }
    // Utilities state handling
    // Used in coordination with a layoutEffect below to determine the utilities state on initial render.
    // Attempted with a ref but it did not work. Using state and enforcing a render in addition to the change render for lgOrAbove seems to fix...
    const [obeyUtilitiesExpandedProp, setObeyUtilitiesExpandedProp] = useState(lgOrAbove);
    // Allow the utilitiesExpandedProp to drive the utilities' state after the initial render
    useLayoutEffect(() => {
        if (lgOrAbove)
            setObeyUtilitiesExpandedProp(true);
    }, [lgOrAbove]);
    // Tracks whether a resize forced the onToggleUtilities to close the utilities when it's a drawer
    const utilitiesToggledByResize = useRef(false);
    // If the initial render is within the MD size, where the utility drawer renders, it must begin collapsed
    const utilitiesExpanded = obeyUtilitiesExpandedProp ? utilitiesExpandedProp : false;
    // Handles utilities state based on breakpoint changes.
    useAfterInitialEffect(() => {
        // If we change into the MD breakpoint range and the utilities state is expanded call the toggle prop to collapse it with controlled state
        if (mdOrAbove && !lgOrAbove && utilitiesExpandedProp) {
            onToggleUtilities?.();
            utilitiesToggledByResize.current = true;
        }
        if (lgOrAbove) {
            if (utilitiesToggledByResize.current && !utilitiesExpandedProp) {
                onToggleUtilities?.();
            }
            utilitiesToggledByResize.current = false;
        }
        // Purposely not listing utilitiesExpanded as a dependency as it is not a trigger and will be captured when BPs change
    }, [mdOrAbove, lgOrAbove]);
    // Generate the tab items based on props and viewport conditions
    const tabItems = useMemo(() => {
        const summaryTab = { id: summaryTabId, name: 'Summary' };
        if (mdOrAbove) {
            return !summaryExpanded || (persistentUtility && !xlOrAbove)
                ? [summaryTab, ...tabItemsProp]
                : tabItemsProp;
        }
        const utilityTabs = [];
        if (utilities)
            utilityTabs.push({ id: utilitiesTabId, name: 'Utilities' });
        if (persistentUtility && !mdOrAbove) {
            utilityTabs.push({ id: persistentUtilityTabId, name: persistentUtility.title });
        }
        return [summaryTab, ...tabItemsProp, ...utilityTabs];
    }, [
        mdOrAbove,
        xlOrAbove,
        summaryTabId,
        utilitiesTabId,
        persistentUtilityTabId,
        utilities,
        persistentUtility,
        tabItemsProp,
        summaryExpanded
    ]);
    // Setup tab content
    const tabContent = useMemo(() => {
        const summaryTabContent = { id: summaryTabId, content: _jsx(Card, { children: summary }) };
        if (mdOrAbove) {
            return !summaryExpanded || (persistentUtility && !xlOrAbove)
                ? [summaryTabContent, ...tabContentProp]
                : tabContentProp;
        }
        const utilityTabs = [];
        if (utilities) {
            utilityTabs.push({
                id: utilitiesTabId,
                content: _jsx(Flex, { container: { direction: 'column', gap: 2 }, children: utilities })
            });
        }
        if (persistentUtility) {
            utilityTabs.push({ id: persistentUtilityTabId, content: persistentUtility?.content });
        }
        return [summaryTabContent, ...tabContentProp, ...utilityTabs];
    }, [
        summaryTabId,
        summary,
        mdOrAbove,
        summaryExpanded,
        persistentUtility,
        xlOrAbove,
        tabContentProp,
        utilities,
        utilitiesTabId,
        persistentUtilityTabId
    ]);
    // Grid layout props
    let caseViewGridContainer = {
        cols: 'minmax(0, 1fr)',
        colGap: 0,
        rows: 'minmax(0, max-content) auto',
        areas: `
      "summary"
      "work-area"
    `
    };
    const sharedGridProps = {
        colGap: 2,
        rows: caseViewGridContainer.rows
    };
    if (persistentUtility) {
        if (xlOrAbove) {
            caseViewGridContainer = {
                ...sharedGridProps,
                cols: 'minmax(0, max-content) minmax(0, 1fr) repeat(2, minmax(0, max-content))',
                areas: '"summary work-area persistentUtility utilities"'
            };
        }
        else if (mdOrAbove) {
            caseViewGridContainer = {
                ...sharedGridProps,
                cols: 'minmax(0, 1fr) repeat(2, minmax(0, max-content))',
                areas: `
          "summary summary summary"
          "work-area persistentUtility utilities"
        `
            };
        }
    }
    else if (summaryExpanded) {
        if (mdOrAbove) {
            caseViewGridContainer = {
                ...sharedGridProps,
                cols: 'minmax(0, max-content) minmax(0, 1fr) minmax(0, max-content)',
                areas: '"summary work-area utilities"'
            };
        }
    }
    else if (mdOrAbove) {
        caseViewGridContainer = {
            ...sharedGridProps,
            cols: 'minmax(0, 1fr) minmax(0, max-content)',
            areas: `
            "summary summary"
            "work-area utilities"
          `
        };
    }
    // Apply sticky columns
    const scrollStickOptions = useRef({
        elements: []
    });
    const stickOffset = useMemo(() => {
        if (windowIsAvailable && caseViewRef.current) {
            return parseFloat(window.getComputedStyle(caseViewRef.current).getPropertyValue('--appshell-offset'));
        }
        return 0;
    }, [caseViewRef.current]);
    useScrollStick(
    // isMediumOrAbove means side by side columns | | |
    mdOrAbove ? { ...scrollStickOptions.current, offset: stickOffset } : undefined);
    useEffect(() => {
        if (mdOrAbove &&
            summaryExpanded &&
            !persistentUtility &&
            (currentTabId === summaryTabId || currentTabId === utilitiesTabId)) {
            onTabClick(tabItemsProp[0]?.id);
        }
    }, [mdOrAbove, summaryExpanded]);
    useEffect(() => {
        if (persistentUtility && currentTabId === persistentUtilityTabId)
            onTabClick(summaryTabId);
    }, [persistentUtility]);
    // Handles scrolling to tab content for newly clicked tab
    useEffect(() => {
        if (!tabContentEl)
            return;
        const scrollPos = window.scrollY;
        const windowHeight = document.documentElement.clientHeight;
        const bottomPos = scrollPos + windowHeight * 0.8;
        const tabContentPos = tabContentEl.offsetTop;
        if (tabContentPos > bottomPos) {
            const top = tabContentPos - windowHeight * 0.2;
            window.scrollTo({ top, behavior: 'smooth' });
        }
    }, [currentTabId]);
    // We need a css variable for the height of the case summary when it is collapsed into a header like layout
    useLayoutEffect(() => {
        if (!caseViewRef.current || !summaryRef.current)
            return;
        caseViewRef.current.style.setProperty('--summary-height', `${!summaryExpanded ? summaryRef.current.offsetHeight : 0}px`);
    }, [summaryExpanded]);
    // CaseView context value
    // Choosing not to memo for now due to extent of deps and how often they change. Optimize as needed.
    const ctxValue = {
        caseId,
        heading,
        subheading,
        caseLink,
        parentCases,
        icon,
        followed,
        onFollowedChange,
        actions,
        promotedActions,
        onEdit,
        summary,
        tabs: {
            items: tabItems,
            onClick: onTabClick,
            currentTabId
        },
        persistentUtility,
        intelligentGuidance,
        summaryId,
        summaryExpanded,
        utilitiesExpanded,
        onToggleSummary,
        isPreview,
        aboveMD: mdOrAbove,
        aboveLG: lgOrAbove,
        aboveXL: xlOrAbove
    };
    // Here we go...
    return (_jsxs(_Fragment, { children: [_jsx(CaseViewContext.Provider, { value: ctxValue, children: _jsxs(Grid, { as: StyledCaseView, ref: caseViewRef, container: caseViewGridContainer, item: { area: 'case-view' }, ...restProps, children: [_jsx(Grid
                        // Used for aria-controls on the toggle button
                        , { 
                            // Used for aria-controls on the toggle button
                            id: summaryId, as: StyledSummary, item: { area: 'summary' }, desktop: mdOrAbove && (!persistentUtility || xlOrAbove) && !summaryExpanded, isLargeOrAbove: lgOrAbove, ref: summaryRef, children: _jsx(CaseSummary, {}) }), _jsxs(Flex, { container: {
                                direction: 'column',
                                alignContent: 'start',
                                rowGap: 2
                            }, as: StyledWorkArea, persistentUtility: Boolean(persistentUtility), children: [banners && _jsx("div", { children: banners }), stages && _jsx("div", { children: stages }), tasks && _jsx("div", { children: tasks }), (!mdOrAbove || (persistentUtility && !xlOrAbove) || !summaryExpanded) && (_jsx(Tabs, { tabs: tabItems, onTabClick: onTabClick, currentTabId: currentTabId })), _jsx("div", { ref: setTabContentEl, children: tabContent?.map(({ id, content }) => (_jsx(TabPanel, { currentTabId: currentTabId, tabId: id, children: content }, id))) })] }), persistentUtility && mdOrAbove && (_jsx(Grid, { as: StyledPersistentUtility, item: { area: 'persistentUtility' }, children: persistentUtility.content })), utilities && mdOrAbove && !lgOrAbove && utilitiesExpanded && (_jsx(Drawer, { as: StyledCaseDrawer, open: utilitiesExpanded, position: 'fixed', placement: direction.end, shadow: true, nullWhenClosed: true, hasPersistentUtility: !!persistentUtility, children: _jsxs(Flex, { as: StyledCaseDrawerContent, container: { direction: 'column', gap: 2 }, id: utilitiesDrawerId, children: [_jsx(Flex, { container: { justify: 'end' }, children: _jsx(Button, { "aria-expanded": utilitiesExpanded ? 'true' : 'false', "aria-controls": utilitiesDrawerId, variant: 'simple', icon: true, onClick: onToggleUtilities, as: StyledUtilToggle, label: t('collapse_utilities_panel'), children: _jsx(Icon, { name: `move-${direction.end}-solid` }) }) }), utilities] }) })), utilities && mdOrAbove && (_jsxs(Grid, { ref: (el) => {
                                if (el)
                                    (scrollStickOptions.current?.elements).push(el);
                            }, as: StyledUtilities, container: {
                                cols: 'minmax(0, 1fr)',
                                rowGap: 2,
                                pad: [2, 0, 2]
                            }, item: {
                                area: 'utilities'
                            }, children: [_jsx(Flex, { container: { justify: utilitiesExpanded ? 'end' : 'center' }, children: _jsx(Button, { "aria-expanded": utilitiesExpanded ? 'true' : 'false', "aria-controls": lgOrAbove ? utilitiesId : utilitiesDrawerId, variant: 'simple', icon: true, onClick: () => {
                                            if (!obeyUtilitiesExpandedProp && utilitiesExpandedProp) {
                                                setObeyUtilitiesExpandedProp(true);
                                            }
                                            else {
                                                onToggleUtilities?.();
                                            }
                                        }, as: StyledUtilToggle, label: t(utilitiesExpanded ? 'collapse_utilities_panel' : 'expand_utilities_panel'), children: _jsx(Icon, { name: `move-${utilitiesExpanded ? direction.end : direction.start}-solid` }) }) }), lgOrAbove && utilitiesExpanded && (_jsx(Flex, { container: { direction: 'column', gap: 2 }, id: utilitiesId, children: utilities })), (!utilitiesExpanded || (mdOrAbove && !lgOrAbove)) && (_jsx(UtilitiesSummary, { items: utilitiesSummaryItems, onClick: onToggleUtilities, "aria-expanded": utilitiesExpanded ? 'true' : 'false', "aria-controls": lgOrAbove ? utilitiesId : utilitiesDrawerId }))] }))] }) }), intelligentGuidance] }));
};
export default CaseView;
//# sourceMappingURL=CaseView.js.map