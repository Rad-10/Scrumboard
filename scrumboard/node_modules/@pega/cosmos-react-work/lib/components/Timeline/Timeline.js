import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { forwardRef, Fragment, useEffect, useState } from 'react';
import { Progress, useConsolidatedRef, useItemIntersection } from '@pega/cosmos-react-core';
import { isSameGroup, sortByDate } from './utils';
import { StyledDate, StyledTimelineTable, StyledLoadingCell } from './Timeline.styles';
import TimelineItem from './TimelineItem';
const Timeline = forwardRef(({ activity, currentTime, sortOrder = 'descending', groupBy = 'date', loading, loadMore, ...restProps }, ref) => {
    const [sortedData, setSortedData] = useState(() => sortByDate(activity, sortOrder));
    const tableRef = useConsolidatedRef(ref);
    useItemIntersection(tableRef, activity.length - 1, () => {
        if (!loading)
            loadMore?.();
    }, ':scope > tbody > tr');
    useEffect(() => {
        setSortedData(sortByDate(activity, sortOrder));
    }, [activity, sortOrder]);
    return (_jsx(StyledTimelineTable, { ref: tableRef, ...restProps, children: _jsxs("tbody", { children: [sortedData.map((item, index) => {
                    const isFirstItemInGroup = !isSameGroup(sortedData[index - 1]?.date, item.date, groupBy);
                    const isLastItemInGroup = !isSameGroup(sortedData[index + 1]?.date, item.date, groupBy);
                    return (_jsxs(Fragment, { children: [isFirstItemInGroup && groupBy !== 'none' && (_jsx("tr", { children: _jsx("td", { colSpan: 3, children: _jsx(StyledDate, { variant: groupBy, format: 'long', value: item.date }) }) })), _jsx(TimelineItem, { item: item, timeFormat: groupBy === 'date' ? 'time' : 'datetime', prevItemDate: isFirstItemInGroup ? undefined : sortedData[index - 1].date, nextItemDate: isLastItemInGroup ? undefined : sortedData[index + 1].date, currentTime: currentTime })] }, item.id));
                }), loading && (_jsx("tr", { children: _jsx(StyledLoadingCell, { colSpan: 3, children: _jsx(Progress, { placement: 'local' }) }) }))] }) }));
});
export default Timeline;
//# sourceMappingURL=Timeline.js.map