import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { forwardRef, useRef, useMemo } from 'react';
import styled, { css } from 'styled-components';
import { Flex, defaultThemeProp } from '@pega/cosmos-react-core';
import { containerMinWidth, cellGap } from './defaults';
import LayoutCell from './LayoutCell';
const StyledConfigurableLayout = styled.div(() => {
    return css `
    overflow: hidden;
  `;
});
const StyledCellGrid = styled.div(({ theme }) => {
    return css `
    /* Note: inset position used to negate "column" inline margin on items */
    position: relative;
    width: calc(100% + ${cellGap * 2} * ${theme.base.spacing});
    max-width: calc(100% + ${cellGap * 2} * ${theme.base.spacing});
    inset-inline: calc(-${cellGap} * ${theme.base.spacing});
    margin-block-end: calc(-2 * ${cellGap} * ${theme.base.spacing});
  `;
});
StyledCellGrid.defaultProps = defaultThemeProp;
const StyledContainerRuler = styled.div(({ theme }) => {
    return css `
    margin-inline: calc(${cellGap} * ${theme.base.spacing});
    width: calc(100% - ${cellGap * 2} * ${theme.base.spacing});
  `;
});
StyledContainerRuler.defaultProps = defaultThemeProp;
const ConfigurableLayout = forwardRef(({ items, arrangement }, ref) => {
    const containerRulerRef = useRef(null);
    const renderMode = useMemo(() => {
        const activeArrangement = arrangement?.hasWrapped !== undefined && !arrangement.hasWrapped;
        if (activeArrangement) {
            switch (arrangement.size) {
                case 'main':
                    return 'direct';
                case 'half':
                    return 'double';
                case 'narrow':
                    return 'full';
                default:
                    return 'direct';
            }
        }
        // Use direct by default
        return 'direct';
    }, [arrangement]);
    const content = useMemo(() => {
        if (items && !!items.length) {
            return items.map(itemConfig => {
                const config = {
                    ...itemConfig,
                    layoutConfig: { ...itemConfig.layoutConfig }
                };
                if (renderMode !== 'direct') {
                    switch (renderMode) {
                        case 'double': {
                            const doubleWidth = {
                                '1/4': '1/2',
                                '1/3': '2/3',
                                '1/2': 'full',
                                '2/3': 'full',
                                '3/4': 'full',
                                full: 'full'
                            };
                            config.layoutConfig.width = doubleWidth[config.layoutConfig.width];
                            break;
                        }
                        case 'full':
                            config.layoutConfig.width = 'full';
                            break;
                        default:
                            config.layoutConfig.width = 'full';
                            break;
                    }
                }
                return _jsx(LayoutCell, { config: config }, `${itemConfig.id}`);
            });
        }
        return null;
    }, [items, renderMode]);
    return (_jsx(StyledConfigurableLayout, { children: _jsxs(Flex, { as: StyledCellGrid, container: { wrap: 'wrap', justify: 'stretch', alignItems: 'stretch' }, item: { basis: containerMinWidth, grow: 1 }, ref: ref, children: [_jsx(StyledContainerRuler, { ref: containerRulerRef }), content] }) }));
});
export default ConfigurableLayout;
//# sourceMappingURL=ConfigurableLayout.js.map