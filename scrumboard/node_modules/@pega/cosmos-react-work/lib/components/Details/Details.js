import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import { forwardRef, Fragment, useState, useContext, useEffect, useMemo } from 'react';
import { remToPx } from 'polished';
import { Text, useBreakpoint, useConsolidatedRef, useTheme, ExpandCollapse, Button, Flex, Icon, useI18n } from '@pega/cosmos-react-core';
import DetailsContext from './DetailsContext';
import { StyledFieldValueGroupLabel, StyledDetails, StyledDetailList, StyledHighlightedDetailList, flexGapProp, chToRem } from './Details.styles';
const Details = forwardRef(({ highlightedData, children, name, columnCount = 1, nested = false, asFlex = false, valueComparison = false, collapsible = false }, ref) => {
    const { longestLabelLength, mobileView, depth, ...context } = useContext(DetailsContext);
    const { base: { 'content-width': { sm } } } = useTheme();
    const isSmallOrAbove = useBreakpoint('sm');
    const listRef = useConsolidatedRef(ref);
    const flexRow = useBreakpoint(columnCount > 2 ? 'md' : 'sm', {
        breakpointRef: listRef,
        themeProp: 'content-width'
    });
    const t = useI18n();
    const [flexContextMobileView, setFlexContextMobileView] = useState(false);
    const [open, setOpen] = useState(true);
    const labelLength = Math.max(14, Math.min(longestLabelLength ?? 16, 40));
    const headingDepth = depth ?? 1;
    const applyMobileView = asFlex
        ? mobileView || (flexRow && flexContextMobileView) || !isSmallOrAbove
        : mobileView || !isSmallOrAbove;
    /**
     * Mount resize observer to update flex context mobile view & run initial check.
     */
    useEffect(() => {
        const checkBreakpoint = (elementWidth) => {
            const minWidthRem = chToRem(parseInt(sm, 10));
            const minWidthPx = parseInt(remToPx(minWidthRem), 10);
            const oneRemInPx = parseInt(remToPx(1), 10);
            const colGapPxAllowance = oneRemInPx * (0.5 * flexGapProp) * (columnCount - 1);
            const mobileViewBreakpoint = minWidthPx * columnCount + colGapPxAllowance;
            setFlexContextMobileView(elementWidth < mobileViewBreakpoint);
        };
        const resizeObserver = new ResizeObserver(entries => {
            const containerPxWidth = entries[0].contentRect.width;
            checkBreakpoint(containerPxWidth);
        });
        if (listRef.current) {
            checkBreakpoint(listRef.current.offsetWidth);
            resizeObserver.observe(listRef.current);
        }
        return () => {
            resizeObserver.disconnect();
        };
    }, [listRef, columnCount]);
    const contextValue = useMemo(() => {
        return {
            mobileView: applyMobileView,
            depth: name ? headingDepth + 1 : headingDepth,
            longestLabelLength,
            ...context
        };
    }, [applyMobileView, name, headingDepth, longestLabelLength, context]);
    const nameText = useMemo(() => {
        return (_jsx(Text, { variant: `h${Math.min(headingDepth, 6)}`, children: name }));
    }, [name, headingDepth]);
    const details = useMemo(() => {
        return (_jsxs(_Fragment, { children: [highlightedData && (_jsxs(_Fragment, { children: [_jsx(StyledHighlightedDetailList, { as: nested ? 'div' : 'dl', children: highlightedData.map((child, i) => (
                            // eslint-disable-next-line react/no-array-index-key
                            _jsx(Fragment, { children: child }, i))) }), _jsx("hr", {})] })), _jsx(StyledDetailList, { ref: listRef, as: nested ? 'div' : 'dl', columnCount: columnCount, labelLength: labelLength, stacked: applyMobileView, hasName: !!name, nested: nested, flex: asFlex, wrapped: asFlex ? !flexRow : false, variant: valueComparison ? 'value-comparison' : undefined, children: children })] }));
    }, [
        highlightedData,
        nested,
        columnCount,
        labelLength,
        applyMobileView,
        name,
        asFlex,
        flexRow,
        valueComparison,
        children
    ]);
    return (_jsx(DetailsContext.Provider, { value: contextValue, children: _jsxs(StyledDetails, { children: [name && (_jsx(StyledFieldValueGroupLabel, { children: collapsible ? (_jsx(Button, { type: 'button', variant: 'text', onClick: () => {
                            setOpen(cur => !cur);
                        }, "aria-expanded": open ? 'true' : 'false', "aria-label": t(open ? 'collapse_noun' : 'expand_noun', [name]), children: _jsxs(Flex, { container: { alignItems: 'center', gap: 0.5 }, as: 'span', children: [_jsx(Icon, { name: 'caret-right' }), nameText] }) })) : (nameText) })), collapsible ? _jsx(ExpandCollapse, { collapsed: !open, children: details }) : details] }) }));
});
export default Details;
//# sourceMappingURL=Details.js.map