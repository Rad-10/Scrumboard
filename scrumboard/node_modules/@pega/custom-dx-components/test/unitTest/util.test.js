import fs, {Dirent, constants} from 'fs';
import path from 'path';
import { join } from 'path';
import {expect, jest, test} from '@jest/globals';
import chalk from 'chalk';
import { createRequire } from 'module';

import fetch from 'node-fetch';

// const util = require('node:util');
import { exec } from 'child_process';

import {
  deleteLocalComponent,
  deleteInfinityServerComponent,
  getComponents,
  getSubComponents,
  getDirectoryFiles,
  getComponentsObj,
  getPegaConfig,
  getPegaServerConfig,
  getComponentDefaults,
  getComponentDirectoryPath,
  convertIntoPascalCase,
  isPascalCase,
  constructCompleteUrl,
  sanitize,
  validateSemver,
  validateRulesetVersion,
  standardizeStr,
  showVersion,
  checkPathAccess
} from '../../src/util';


const mockAcces = {
  TOKEN_PATH: '.access_token'
}

// should be overridden
let libraryName = "not valid";
let organizationName = "not valid";
let version = "not valid";

beforeAll( async () => {
  const thePath = process.cwd().replace("node_modules/@pega/custom-dx-components","");
  const cwdMock = jest.spyOn(process, 'cwd');
  cwdMock.mockReturnValue(thePath);


  const oConf = await getPegaConfig();
  libraryName = oConf.component.library;
  version = oConf.component.version;



});

// describe('utils fetch', () => {
//   let promiseStub = null;

//   const fetchMessage = {
//     message : "Pega_DXIL_MyTestText Component is successfully deleted"
//   }

//   beforeEach(() => {
//     // Stub fetch response
//     promiseStub = sinon.stub(fetch, "Promise");
//     promiseStub.returns(
//       Promise.resolve({ status: 200, json: () => Promise.resolve(fetchMessage) })
//     );
//   });

//   afterAll(() => {
//     promiseStub.restore();
//   });

//   afterEach(() => {
//     sinon.restore();
//   });

//   it('deleteInfinityServerComponent', async () => {
//     // remove node_module path if exists
//     const thePath = process.cwd().replace("node_modules/@pega/custom-dx-components","");
//     const cwdMock = jest.spyOn(process, 'cwd');
//     cwdMock.mockReturnValue(thePath);

//     const tokenPath = process.cwd();
//     const logSpy = jest.spyOn(console, 'log');


//     // global.fetch = jest.fn(() =>
//     // Promise.resolve({
//     //   json: () => Promise.resolve({"message": " Pega_DXIL_MyTestText Component is successfully deleted","status":"200"}),
//     // }),
//     // );

//     // const fetchMock = jest.spyOn(global, 'fetch').mockImplementation(() =>
//     //   Promise.resolve({ json: () => Promise.resolve({"message": " Pega_DXIL_MyTestText Component is successfully deleted","status":"200"}) } ));


//       // const fetchMock = jest.spyOn(global, 'fetch').mockImplementation(() =>
//       //   new Promise((resolve) =>
//       //     resolve({status:"200", json: () => Promise.resolve(" Pega_DXIL_MyTestText Component is successfully deleted") }) ) );

// ////

// const mockResponse = {p_res: '{"test":"value"}', missingComponents: []}

// // stubbing fetch
// const stubbedFetch = sinon.stub(fetch, 'Promise').returns(Promise.resolve({ok:true, status: 200, json:() => Promise.resolve([{"test":"value"}])}))

// ////


//     await deleteInfinityServerComponent("Pega_DXIL_MyTestText~|~LoanV2~|~01-01-01", ".access_token");


//     expect(logSpy).toHaveBeenCalledWith('deleted');


//     cwdMock.mockRestore();
//     logSpy.mockRestore();
//     tokenPathSpy.mockeRestore();


//   });

// });

describe('utils test', () => {


  it('checkPathAccess', async () => {
    const logSpy = jest.spyOn(console, 'error')

    // remove node_module path if exists
    const thePath = process.cwd().replace("node_modules/@pega/custom-dx-components","");

    await checkPathAccess(thePath);

    expect(logSpy).not.toBeCalled();

    logSpy.mockRestore();


  });

  it('NOT checkPathAccess', async () => {
    const logSpy = jest.spyOn(console, 'error')
    const exitMock = jest.spyOn(process, 'exit').mockImplementation(() => {});

    // remove node_module path if exists
    const thePath = "/notExist";

    await checkPathAccess(thePath);

    expect(logSpy).toBeCalled();
    expect(exitMock).toHaveBeenCalledWith(1);

    logSpy.mockRestore();
    exitMock.mockRestore();

  });

  it('getComponents', async () => {
    const dir1 = new Dirent("directory1", constants.UV_DIRENT_DIR);
    const dir2 = new Dirent("directory2", constants.UV_DIRENT_DIR);

    // remove node_module path if exists
    const thePath = process.cwd().replace("node_modules/@pega/custom-dx-components","");
    const cwdMock = jest.spyOn(process, 'cwd');
    cwdMock.mockReturnValue(thePath);

    const fsMock = jest.spyOn(fs, 'readdirSync');
    fsMock.mockReturnValue([dir1, dir2]);


    const compList = await getComponents();
    expect(compList).not.toBeNull;
    expect(compList).toMatchObject(['directory1', 'directory2']);

    cwdMock.mockRestore();
    fsMock.mockRestore();
  });

  it('NOT getComponents', async () => {
    const dir1 = new Dirent("directory1", constants.UV_DIRENT_DIR);
    const dir2 = new Dirent("directory2", constants.UV_DIRENT_DIR);

    // remove node_module path if exists
    const thePath = process.cwd().replace("node_modules/@pega/custom-dx-components","");
    const cwdMock = jest.spyOn(process, 'cwd');
    cwdMock.mockReturnValue(thePath);

    const logSpy = jest.spyOn(console, 'error')
    const exitMock = jest.spyOn(process, 'exit').mockImplementation(() => { throw new Error('bad')});

    const fsMock = jest.spyOn(fs, 'readdirSync');
    fsMock.mockReturnValue([dir1, dir2]);

    const fsFileMock = jest.spyOn(fs, 'readFileSync');
    fsFileMock.mockReturnValue("{}");

    try {
      const compList = await getComponents();
    }
    catch (error) {
      expect(logSpy).toBeCalled();
      expect(exitMock).toHaveBeenCalledWith(1);
    }


    fsMock.mockRestore();
    fsFileMock.mockRestore();
    exitMock.mockRestore();
    logSpy.mockRestore();
    cwdMock.mockRestore();


  });



  it('getSubComponents', async () => {
    const dir1 = new Dirent("directory1", constants.UV_DIRENT_DIR);
    const dir2 = new Dirent("directory2", constants.UV_DIRENT_DIR);

    // remove node_module path if exists
    const thePath = process.cwd().replace("node_modules/@pega/custom-dx-components","");
    const cwdMock = jest.spyOn(process, 'cwd');
    cwdMock.mockReturnValue(thePath);

    const fsMock = jest.spyOn(fs, 'readdirSync');
    fsMock.mockReturnValue([dir1, dir2]);

    const compList = await getSubComponents("/main", "/sub");
    expect(compList).not.toBeNull;
    expect(compList).toMatchObject(['directory1', 'directory2']);


    fsMock.mockRestore();
    cwdMock.mockRestore();
  });

  it('getDirectoryFiles', async () => {
    const file1 = new Dirent("file1", constants.UV_DIRENT_FILE);
    const file2 = new Dirent("file2", constants.UV_DIRENT_FILE);

    // remove node_module path if exists
    const thePath = process.cwd().replace("node_modules/@pega/custom-dx-components","");
    const cwdMock = jest.spyOn(process, 'cwd');
    cwdMock.mockReturnValue(thePath);

    const fsMock = jest.spyOn(fs, 'readdirSync');
    fsMock.mockReturnValue([file1, file2]);

    const compList = await getDirectoryFiles("/main");
    expect(compList).not.toBeNull;
    expect(compList).toMatchObject(['file1', 'file2']);


    fsMock.mockRestore();
    cwdMock.mockRestore();
  });

  it('getComponentsObj', async () => {
    const dir1 = new Dirent("directory1", constants.UV_DIRENT_DIR);
    const dir2 = new Dirent("directory2", constants.UV_DIRENT_DIR);

    // remove node_module path if exists
    const thePath = process.cwd().replace("node_modules/@pega/custom-dx-components","");
    const cwdMock = jest.spyOn(process, 'cwd');
    cwdMock.mockReturnValue(thePath);

    const fsMock = jest.spyOn(fs, 'readdirSync');
    fsMock.mockReturnValue([dir1, dir2]);

    const compList = await getComponentsObj();
    expect(compList).not.toBeNull;
    expect(compList).toMatchObject([{"name": "directory1","value": "directory1"},{"name": "directory2","value": "directory2"}]);


    fsMock.mockRestore();
    cwdMock.mockRestore();
  });

  it('getPegaConfig', async () => {

    // remove node_module path if exists
    const thePath = process.cwd().replace("node_modules/@pega/custom-dx-components","");
    const cwdMock = jest.spyOn(process, 'cwd');
    cwdMock.mockReturnValue(thePath);

    const oConf = await getPegaConfig();

    const sPath = oConf["components-directory-path"];

    expect(oConf).not.toBeNull;
    expect(sPath).toMatch('src/components');
    expect(oConf.component.library).toMatch(libraryName);
    expect(oConf.component.version).toMatch(version);

    cwdMock.mockRestore();

  });

  it('getPegaServerConfig', async () => {
    // remove node_module path if exists
    const thePath = process.cwd().replace("node_modules/@pega/custom-dx-components","");
    const cwdMock = jest.spyOn(process, 'cwd');
    cwdMock.mockReturnValue(thePath);

    const oConf = await getPegaServerConfig();

    expect(oConf).not.toBeNull;

    expect(oConf.sourceOfComponents).toMatch('Server');
    expect(oConf.serverType).toMatch('infinity');
    expect(oConf.clientId).toMatch('10095186356008396159');
    expect(oConf.grantType).toMatch('authCode');
    expect(oConf.redirectUri).toMatch('https://localhost:4010');
    expect(oConf.authService).toMatch('pega');

    cwdMock.mockRestore();

  });

  it('getComponentDefaults', async () => {

    // remove node_module path if exists
    const thePath = process.cwd().replace("node_modules/@pega/custom-dx-components","");
    const cwdMock = jest.spyOn(process, 'cwd');
    cwdMock.mockReturnValue(thePath);

    const oConf = await getComponentDefaults();

    expect(oConf).not.toBeNull;
    expect(oConf.library).toMatch(libraryName);
    expect(oConf.version).toMatch(version);

    cwdMock.mockRestore();

  });

  it('getComponentDirectoryPath', async () => {

    // remove node_module path if exists
    const thePath = process.cwd().replace("node_modules/@pega/custom-dx-components","");
    const cwdMock = jest.spyOn(process, 'cwd');
    cwdMock.mockReturnValue(thePath);

    const sPath = await getComponentDirectoryPath("Pega_DXIL_MyTestText");

    expect(sPath).not.toBeNull;
    expect(sPath).toContain('/src/components/Pega_DXIL_MyTestText');

    cwdMock.mockRestore();

  });

  it('NOT getComponentDirectoryPath', async () => {

    // remove node_module path if exists
    const thePath = process.cwd().replace("node_modules/@pega/custom-dx-components","");
    const cwdMock = jest.spyOn(process, 'cwd');
    cwdMock.mockReturnValue(thePath);

    const logSpy = jest.spyOn(console, 'error')
    const exitMock = jest.spyOn(process, 'exit').mockImplementation(() => { throw new Error('bad')});

    const fsFileMock = jest.spyOn(fs, 'readFileSync');
    fsFileMock.mockReturnValue("{}");

    try {
      const sPath = await getComponentDirectoryPath("Pega_DXIL_MyTestText");
    }
    catch (error) {
      expect(logSpy).toBeCalled();
      expect(exitMock).toHaveBeenCalledWith(1);
    }

    fsFileMock.mockRestore();
    exitMock.mockRestore();
    logSpy.mockRestore();
    cwdMock.mockRestore();

  });

  test('convertIntoPascalCase', () => {
    const response = convertIntoPascalCase("Pega_DXIL_MyTestText");
    expect(response).toMatch("PegaDxilMyTestText");

  });

  test('isPascalCase', () => {
    const isPascal = isPascalCase("PegaDxilMyTestText");
    expect(isPascal).toBeTruthy();

  });

  test('NOT isPascalCase', () => {
    const isPascal = isPascalCase("Pega_DXIL_MyTestText");
    expect(isPascal).not.toBeTruthy();

  });

  test('NOT constructCompleteUrl', () => {
    const sUrl = constructCompleteUrl("/user", "myDir/myData");
    expect(sUrl).toMatch("/user/myDir/myData");

  });


  test('sanitize', () => {
    const sUrl = sanitize("%&*^abc123%*%^&*");
    expect(sUrl).toMatch("abc123");

  });


  test('validateSemver', () => {
    const bValid = validateSemver("0.0.1");
    expect(bValid).toBeTruthy();

  });

  test('NOT validateSemver', () => {
    const bValid = validateSemver("0.0.1abc");
    expect(bValid).not.toBeTruthy();

  });


  test('validateRulesetVersion', () => {
    const bValid = validateRulesetVersion("01-01-01");
    expect(bValid).toBeTruthy();

  });

  test('NOT validateRulesetVersion', () => {
    const bValid = validateRulesetVersion("01-01-01abc");
    expect(bValid).not.toBeTruthy();

  });

  test('NOT validateRulesetVersion 00', () => {
    const bValid = validateRulesetVersion("00-01-01");
    expect(bValid).not.toBeTruthy();

  });

  test('standardizeStr', () => {
    const sStr = standardizeStr("abcd", 10);
    expect(sStr).toMatch("abcd      ");

  });


  it('NOT deleteLocalComponent', async () => {
    // remove node_module path if exists
    const thePath = process.cwd().replace("node_modules/@pega/custom-dx-components","");
    const cwdMock = jest.spyOn(process, 'cwd');
    cwdMock.mockReturnValue(thePath);

    const logSpy = jest.spyOn(console, 'error')
    const exitMock = jest.spyOn(process, 'exit').mockImplementation(() => { throw new Error('bad')});

    const fsFileMock = jest.spyOn(fs, 'readFileSync');
    fsFileMock.mockReturnValue("{}");

    try {
      await deleteLocalComponent("Pega_DXIL_MyTestText");
    }
    catch (error) {
      expect(logSpy).toBeCalled();
      expect(exitMock).toHaveBeenCalledWith(1);
    }

    fsFileMock.mockRestore();
    exitMock.mockRestore();
    logSpy.mockRestore();
    cwdMock.mockRestore();

  });

  it('Not deleteLocalComponent no file', async () => {
    // remove node_module path if exists
    const thePath = process.cwd().replace("node_modules/@pega/custom-dx-components","");
    const cwdMock = jest.spyOn(process, 'cwd');
    cwdMock.mockReturnValue(thePath);

    try {
      await deleteLocalComponent("Pega_DXIL_MyTestText");
    }
    catch (error) {
      expect(error).not.toBeNull();
      expect(error.toString()).toMatch("Error: No such file Pega_DXIL_MyTestText");
    }



    cwdMock.mockRestore();

  });

  it('deleteLocalComponent', async () => {
    // remove node_module path if exists
    const thePath = process.cwd().replace("node_modules/@pega/custom-dx-components","");
    const cwdMock = jest.spyOn(process, 'cwd');
    cwdMock.mockReturnValue(thePath);

    const logSpy = jest.spyOn(console, 'log')
    const rmSyncMock = jest.spyOn(fs, 'rmSync').mockImplementation(() => { });

    await deleteLocalComponent("Pega_DXIL_MyTestText");
    expect(logSpy).toHaveBeenCalled();
    expect(logSpy).toHaveBeenCalledWith(`${chalk.red.bold("Pega_DXIL_MyTestText")} is deleted from Local`);

    cwdMock.mockRestore();
    logSpy.mockRestore();
    rmSyncMock.mockRestore();

  });





  // test('showVersion', () => {
  //   const logSpy = jest.spyOn(console, 'log')

  //   const require = createRequire(import.meta.url);
  //   const pData = require("@pega/custom-dx-components/package.json");

  //   showVersion();

  //   expect(logSpy).toHaveBeenCalledWith(chalk.green("DX Component Builder v" + pData.version));

  //   logSpy.mockRestore();
  // })


});
