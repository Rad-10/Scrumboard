import fs from 'fs';
import { join } from 'path';
import { promisify } from 'util';
import https from 'https';

import chalk from 'chalk';
import mustache from 'mustache';
import pascalCase from 'pascalcase';
import fetch from 'node-fetch';
import { createRequire } from 'module';


import {
  COMPONENTS_DIRECTORY_PATH,
  TASKS_CONFIG_JSON_FILENAME,
  TOKEN_PATH,
  OOTB_COMPONENT_SERVICE_REST_ENDPOINT,
  DELETE_COMPONENT_SERVICE_REST_ENDPOINT,
  OOTB_COMPONENTS
} from './constants.js';

const access = promisify(fs.access);

export const checkPathAccess = async (path, options = {}) => {
  const { errorMessage } = options;

  try {
    await access(path, fs.constants.R_OK);
  } catch (err) {
    const message =
      errorMessage || `${chalk.red.bold('ERROR')} Could not able to access path - ${path}`;
    console.error(message);
    process.exit(1);
  }
};

export const deleteLocalComponent = async componentKey => {
  const currentDirectory = process.cwd();
  const pegaConfigJsonPath = join(currentDirectory, TASKS_CONFIG_JSON_FILENAME);

  await checkPathAccess(pegaConfigJsonPath);

  let data = fs.readFileSync(pegaConfigJsonPath, { encoding: 'utf8' });
  data = JSON.parse(data);

  if (!data[COMPONENTS_DIRECTORY_PATH]) {
    console.error(
      `${chalk.red.bold('ERROR')} Could not able find components directory path in config.json`
    );
    process.exit(1);
  }

  const directory = join(currentDirectory, data[COMPONENTS_DIRECTORY_PATH], componentKey);

  fs.rm(directory, { recursive: true }, err => {
    if (err) {
      throw err;
    }

    console.log(`${chalk.red.bold(componentKey)} is deleted from Local`);
  });
};

export const deleteServerComponent = async componentKey => {
  const { server, user, password } = await getPegaServerConfig();
  const url = constructCompleteUrl(server, DELETE_COMPONENT_SERVICE_REST_ENDPOINT);
  const [componentName, rulesetName, rulesetVersion] = componentKey.split('~|~');
  const deleteUrl = `${url}/${componentName}/rulesetname/${rulesetName}/rulesetversion/${rulesetVersion}`;
  try {
    const OauthData = fs.readFileSync(TOKEN_PATH, 'utf8');

    let status = 500;

    if (OauthData) {
      const {
        access_token: accessToken,
        token_type: tokenType,
        refresh_token: refreshToken
      } = JSON.parse(OauthData);
      fetch(deleteUrl, {
        method: 'DELETE',
        agent: new https.Agent({ rejectUnauthorized: false }),
        headers: {
          Authorization: `${tokenType} ${accessToken}`
        }
      })
        .then(response => {
          status = response.status;
          return response.text();
        })
        .then(resp => {
          let respData;
          try {
            respData = JSON.parse(resp);

          }
          catch (e) {
            console.log(chalk.bold.redBright(`Failure : ${resp}`));
            process.exit(1);
          }

          if (respData.status == 200) {
            console.log(chalk.bold.green(`Success : ${respData.message}`));
          } else {
            throw new Error(`${respData.message}`);
          }


        })
        .catch(e => {
          if (status === 403) {
            // eslint-disable-next-line prefer-promise-reject-errors
            Promise.reject(
              `${chalk.bold.red(
                'Error forbidden: User does not have privileges to Delete.'
              )}`
            );
          }
          else {
            // eslint-disable-next-line prefer-promise-reject-errors
            Promise.reject(`${chalk.bold.red(e)}`)
          }

        });
    }
  } catch (error) {
    console.log(`\n${chalk.bold.red(error)}`);
  }
};


export const getComponents = async () => {
  const currentDirectory = process.cwd();
  const pegaConfigJsonPath = join(currentDirectory, TASKS_CONFIG_JSON_FILENAME);

  await checkPathAccess(pegaConfigJsonPath);

  let data = fs.readFileSync(pegaConfigJsonPath, { encoding: 'utf8' });
  data = JSON.parse(data);

  if (!data[COMPONENTS_DIRECTORY_PATH]) {
    console.error(
      `${chalk.red.bold('ERROR')} Could not able find components directory path in config.json`
    );
    process.exit(1);
  }

  const directory = join(currentDirectory, data[COMPONENTS_DIRECTORY_PATH]);
  return fs
    .readdirSync(directory, { withFileTypes: true })
    .filter(dirent => dirent.isDirectory())
    .map(dirent => dirent.name);
};




export const getSubComponents = async (directory, type) => {

  const subDirectory = join(directory, type);
  return fs
  .readdirSync(subDirectory, { withFileTypes: true })
  .filter(dirent => dirent.isDirectory())
  .map(dirent => dirent.name);
}


export const getDirectoryFiles = async (directory) => {
  return fs
  .readdirSync(directory, { withFileTypes: true })
  .filter(dirent => !dirent.isDirectory())
  .map(dirent => dirent.name);
}


export const getComponentsObj = async () => {

  let compList = new Array();

  //const componentList = await getDirectoryFiles(directory);
  const componentList = await getComponents();


  if (componentList.length > 0) {

    compList.push(...componentList.map(
      name => {
        const container = {};
        container.name = name;
        container.value = name;

        return container;
      }
    ));
  }

  return compList;
}

export const getPegaConfig = async () => {
  const currentDirectory = process.cwd();
  const pegaConfigJsonPath = join(currentDirectory, TASKS_CONFIG_JSON_FILENAME);

  await checkPathAccess(pegaConfigJsonPath);

  let data = fs.readFileSync(pegaConfigJsonPath, { encoding: 'utf8' });
  data = JSON.parse(data);

  return data;
};

export const getPegaServerConfig = async () => {
  const config = await getPegaConfig();
  return config['server-config'];
};

export const getComponentDefaults = async () => {
  const config = await getPegaConfig();
  return config.component;
};

export const getComponentDirectoryPath = async componentKey => {
  const currentDirectory = process.cwd();
  const pegaConfigJsonPath = join(currentDirectory, TASKS_CONFIG_JSON_FILENAME);

  await checkPathAccess(pegaConfigJsonPath);

  let data = fs.readFileSync(pegaConfigJsonPath, { encoding: 'utf8' });
  data = JSON.parse(data);

  if (!data[COMPONENTS_DIRECTORY_PATH]) {
    console.error(
      `${chalk.red.bold('ERROR')} Could not able find components directory path in config.json`
    );
    process.exit(1);
  }

  return join(currentDirectory, data[COMPONENTS_DIRECTORY_PATH], componentKey);
};

export const compileMustacheTemplate = (file, data) => {
  const content = fs.readFileSync(file, 'utf8');
  return mustache.render(content, data);
};

export const isPascalCase = string => {
  return string === pascalCase(string);
};

export const convertIntoPascalCase = string => {
  return pascalCase(string);
};

export const constructCompleteUrl = (baseServer, endPoint) => {
  return baseServer.endsWith('/') ? `${baseServer}${endPoint}` : `${baseServer}/${endPoint}`;
};

export const nodeFetch = (url, config) => {
  const { method, user, password, headers, ...restConfig } = config;

  if (url.startsWith('https')) restConfig.agent = new https.Agent({ rejectUnauthorized: false });

  return fetch(url, {
    method,
    ...restConfig,
    headers: {
      'Content-Type': 'application/json;charset=utf-8',
      Authorization: `Basic ${Buffer.from(`${user}:${password}`).toString('base64')}`,
      ...headers
    }
  });
};

export const sanitize = str => {
  /* Allow only numbers and case insensitive alphabets */
  str = str.replace(/[^a-zA-Z0-9 ]/g, '');
  /* spaces will be replaced by - */
  str = str.replace(/\s+/g, '-');
  return str;
};

export const validateSemver = str => {
  /* basic semver version validation - 0.0.1-dev */
  const regex = /^[0-9]\d*\.\d+\.\d+(?:-[a-zA-Z0-9]+)?$/g;
  return regex.test(str);
};

export const validateRulesetVersion = str => {
  /* Ruleset version range - 01-99 */
  if (str.indexOf('00') !== -1) {
    return false;
  }
  /* basic ruleset version validation - 01-01-01 */
  const regex = /^\d\d-\d\d-\d\d$/g;
  return regex.test(str);
};

export const showVersion = () => {
  // get package version, so can display at start
  const require = createRequire(import.meta.url);
  const pData = require("@pega/custom-dx-components/package.json");

  console.log(chalk.green("DX Component Builder v" + pData.version));

  // do a check of node version, it should be 18 or greater
  const arNodeVersion  = process.versions.node.split(".");

  const nodeMajorVersion = parseInt(arNodeVersion[0]);
  const nodeMinorVersion = parseInt(arNodeVersion[1]);

  if (nodeMajorVersion < 18) {
    console.log(chalk.redBright("DX Component Builder - SDK requires node v18 or greater, current version: " + process.version));
    process.exit(1);
  }
};

export const getOOTBComponents = async () => {
  return new Promise((resolve, reject) => {
    fs.readFile(OOTB_COMPONENTS, 'utf-8', async (err, data) => {
      if (err) {
        try {
          const { server } = await getPegaServerConfig();
          const url = constructCompleteUrl(server, OOTB_COMPONENT_SERVICE_REST_ENDPOINT);
          const OauthData = fs.readFileSync(TOKEN_PATH, 'utf8');
          if (OauthData) {
            const {
              access_token: accessToken,
              token_type: tokenType,
              refresh_token: refreshToken
            } = JSON.parse(OauthData);
            fetch(url, {
              method: 'GET',
              agent: new https.Agent({ rejectUnauthorized: false }),
              headers: {
                Authorization: `${tokenType} ${accessToken}`
              }
            })
              .then(response => response.text())
              .then(data => {
                if (data.charAt() === '[') {
                  data = data.slice(1, -1);
                  data = data.replace(/\s/g, '');
                  fs.writeFile(OOTB_COMPONENTS, data, err => {
                    if (err) {
                      console.error(err);
                    }
                    resolve(data.split(','));
                  });
                } else {
                  data = JSON.parse(data);
                  if (data && data.errors) {
                    const errMessages = data.errors;
                    errMessages.forEach(msgArr => {
                      throw new Error(`Failed with error - ${JSON.stringify(msgArr.message)}`);
                    });
                  }
                }
              })
              .catch(e => Promise.reject(`${chalk.bold.red(e)}`));
          }
        } catch (error) {
          throw new Error('Error occurred in validation', error);
        }
      } else {
        resolve(data.split(','));
      }
    });
  });
};
