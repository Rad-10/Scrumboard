import fs from 'fs';
import { join } from 'path';
import { promisify } from 'util';
import https from 'https';
import crypto from 'node:crypto';
import { createRequire } from 'module';

import chalk from 'chalk';
import mustache from 'mustache';
import pascalCase from 'pascalcase';
import fetch from 'node-fetch';
import checkGit from 'check-git';

import * as currentPath from './currentPath.cjs';
import {
  COMPONENTS_DIRECTORY_PATH,
  TASKS_CONFIG_JSON_FILENAME,
  TOKEN_PATH,
  OOTB_COMPONENT_SERVICE_REST_ENDPOINT,
  DELETE_COMPONENT_SERVICE_REST_ENDPOINT,
  LP_DELETE_COMPONENT_SERVICE_REST_ENDPOINT,
  OOTB_COMPONENTS
} from './constants.js';

const access = promisify(fs.access);

export const checkPathAccess = async (path, options = {}) => {
  const { errorMessage } = options;

  try {
    await access(path, fs.constants.R_OK);
  } catch (err) {
    const message = errorMessage || `${chalk.red.bold('ERROR')} Could not able to access path - ${path}`;
    console.error(message);
    process.exit(1);
  }
};

export const deleteLocalComponent = async (componentKey) => {
  const currentDirectory = process.cwd();
  const pegaConfigJsonPath = join(currentDirectory, TASKS_CONFIG_JSON_FILENAME);

  await checkPathAccess(pegaConfigJsonPath);

  let data = fs.readFileSync(pegaConfigJsonPath, { encoding: 'utf8' });
  data = JSON.parse(data);

  if (!data[COMPONENTS_DIRECTORY_PATH]) {
    console.error(`${chalk.red.bold('ERROR')} Could not able find components directory path in config.json`);
    process.exit(1);
  }

  const directory = join(currentDirectory, data[COMPONENTS_DIRECTORY_PATH], componentKey);

  try {
    fs.rmSync(directory, { recursive: true });
    console.log(`${chalk.red.bold(componentKey)} is deleted from Local`);
  } catch (err) {
    console.log('no file');
    throw new Error(`No such file ${componentKey}`);
  }
};

export const getHttpsAgent = (serverConfig) => {
  const agentOptions = { rejectUnauthorized: false };
  if (serverConfig.legacyTLS) {
    agentOptions.secureOptions = crypto.constants.SSL_OP_LEGACY_SERVER_CONNECT;
  }
  return new https.Agent(agentOptions);
};

export const deleteServerComponent = async (componentKey) => {
  const serverConfig = await getPegaServerConfig();
  const { server, user, password } = serverConfig;
  const url = constructCompleteUrl(server, DELETE_COMPONENT_SERVICE_REST_ENDPOINT);
  const [componentName, rulesetName, rulesetVersion] = componentKey.split('~|~');
  const deleteUrl = `${url}/${componentName}/rulesetname/${rulesetName}/rulesetversion/${rulesetVersion}`;
  try {
    const OauthData = fs.readFileSync(TOKEN_PATH, 'utf8');

    if (OauthData) {
      const { access_token: accessToken, token_type: tokenType, refresh_token: refreshToken } = JSON.parse(OauthData);
      fetch(deleteUrl, {
        method: 'DELETE',
        agent: getHttpsAgent(serverConfig),
        headers: {
          Authorization: `${tokenType} ${accessToken}`
        }
      })
        .then((response) => response.text())
        .then((resp) => {
          let respData;
          try {
            respData = JSON.parse(resp);
          } catch (e) {
            console.log(chalk.bold.redBright(`Failure : ${resp}`));
            process.exit(1);
          }

          if (respData.status == 200) {
            console.log(chalk.bold.green(`Success : ${respData.message}`));
          } else {
            throw new Error(`${respData.message}`);
          }
        })
        .catch((e) => Promise.reject(`${chalk.bold.red(e)}`));
    }
  } catch (error) {
    console.log(`\n${chalk.bold.red(error)}`);
  }
};

export const getComponents = async () => {
  const currentDirectory = process.cwd();
  const pegaConfigJsonPath = join(currentDirectory, TASKS_CONFIG_JSON_FILENAME);

  await checkPathAccess(pegaConfigJsonPath);

  let data = fs.readFileSync(pegaConfigJsonPath, { encoding: 'utf8' });

  data = JSON.parse(data);

  if (!data[COMPONENTS_DIRECTORY_PATH]) {
    console.error(`${chalk.red.bold('ERROR')} Could not find components directory path in config.json`);
    process.exit(1);
  }

  const directory = join(currentDirectory, data[COMPONENTS_DIRECTORY_PATH]);
  return fs
    .readdirSync(directory, { withFileTypes: true })
    .filter((dirent) => dirent.isDirectory())
    .map((dirent) => dirent.name);
};

export const getSubComponents = async (directory, type) => {
  const subDirectory = join(directory, type);
  return fs
    .readdirSync(subDirectory, { withFileTypes: true })
    .filter((dirent) => dirent.isDirectory())
    .map((dirent) => dirent.name);
};

export const getDirectoryFiles = async (directory) => {
  return fs
    .readdirSync(directory, { withFileTypes: true })
    .filter((dirent) => !dirent.isDirectory())
    .map((dirent) => dirent.name);
};

export const getComponentsObj = async () => {
  const compList = [];

  // const componentList = await getDirectoryFiles(directory);
  const componentList = await getComponents();

  if (componentList.length > 0) {
    compList.push(
      ...componentList.map((name) => {
        const container = {};
        container.name = name;
        container.value = name;

        return container;
      })
    );
  }

  return compList;
};

export const getPegaConfig = async () => {
  const currentDirectory = process.cwd();
  const pegaConfigJsonPath = join(currentDirectory, TASKS_CONFIG_JSON_FILENAME);

  await checkPathAccess(pegaConfigJsonPath);

  let data = fs.readFileSync(pegaConfigJsonPath, { encoding: 'utf8' });
  data = JSON.parse(data);

  return data;
};

export const getPegaServerConfig = async () => {
  const config = await getPegaConfig();
  return config['server-config'];
};

export const getComponentDefaults = async () => {
  const config = await getPegaConfig();
  return config.component;
};

export const getComponentDirectoryPath = async (componentKey) => {
  const currentDirectory = process.cwd();
  const pegaConfigJsonPath = join(currentDirectory, TASKS_CONFIG_JSON_FILENAME);

  await checkPathAccess(pegaConfigJsonPath);

  let data = fs.readFileSync(pegaConfigJsonPath, { encoding: 'utf8' });
  data = JSON.parse(data);

  if (!data[COMPONENTS_DIRECTORY_PATH]) {
    console.error(`${chalk.red.bold('ERROR')} Could not able find components directory path in config.json`);
    process.exit(1);
  }

  return join(currentDirectory, data[COMPONENTS_DIRECTORY_PATH], componentKey);
};

export const compileMustacheTemplate = (file, data) => {
  const content = fs.readFileSync(file, 'utf8');
  return mustache.render(content, data);
};

export const isPascalCase = (string) => {
  return string === pascalCase(string);
};

export const convertIntoPascalCase = (string) => {
  return pascalCase(string);
};

export const constructCompleteUrl = (baseServer, endPoint) => {
  return baseServer.endsWith('/') ? `${baseServer}${endPoint}` : `${baseServer}/${endPoint}`;
};

export const sanitize = (str) => {
  /* Allow only numbers and case insensitive alphabets */
  str = str.replace(/[^a-zA-Z0-9 ]/g, '');
  /* spaces will be replaced by - */
  str = str.replace(/\s+/g, '-');
  return str;
};

export const validateSemver = (str) => {
  /* basic semver version validation - 0.0.1-dev */
  const regex = /^[0-9]\d*\.\d+\.\d+(?:-[a-zA-Z0-9]+)?$/g;
  return regex.test(str);
};

export const validateRulesetVersion = (str) => {
  /* Ruleset version range - 01-99 */
  if (str.indexOf('00') !== -1) {
    return false;
  }
  /* basic ruleset version validation - 01-01-01 */
  const regex = /^\d\d-\d\d-\d\d$/g;
  return regex.test(str);
};

export const standardizeStr = (str, length) => {
  return str.padEnd(length);
};

export const showVersion = () => {
  // get package version, so can display at start
  // const require = createRequire(import.meta.url);
  const require = createRequire(currentPath.default);

  const pData = require('@pega/custom-dx-components/package.json');

  console.log(chalk.green(`DX Component Builder v${pData.version}`));

  // do a check of node version, it should be 18 or greater
  const arNodeVersion = process.versions.node.split('.');

  const nodeMajorVersion = parseInt(arNodeVersion[0]);
  const nodeMinorVersion = parseInt(arNodeVersion[1]);

  if (nodeMajorVersion < 18) {
    console.log(chalk.redBright(`DX Component Builder - SDK requires node v18 or greater, current version: ${process.version}`));
    process.exit(1);
  }

  const hasGit = checkGit(process.cwd());

  if (!hasGit) {
    console.log(chalk.redBright('DX Component Builder - SDK git to be installed.'));
    process.exit(1);
  }
};

export const getOOTBComponents = async () => {
  return new Promise((resolve) => {
    fs.readFile(OOTB_COMPONENTS, 'utf-8', async (error, ootbComponentsData) => {
      if (error) {
        try {
          const serverConfig = await getPegaServerConfig();
          const { server } = serverConfig;
          const url = constructCompleteUrl(server, OOTB_COMPONENT_SERVICE_REST_ENDPOINT);
          const OauthData = fs.readFileSync(TOKEN_PATH, 'utf8');
          if (OauthData) {
            const { access_token: accessToken, token_type: tokenType } = JSON.parse(OauthData);
            fetch(url, {
              method: 'GET',
              agent: getHttpsAgent(serverConfig),
              headers: {
                Authorization: `${tokenType} ${accessToken}`
              }
            })
              .then((response) => response.text())
              .then((data) => {
                if (data.charAt() === '[') {
                  data = data.slice(1, -1);
                  data = data.replace(/\s/g, '');
                  fs.writeFile(OOTB_COMPONENTS, data, (err) => {
                    if (err) {
                      console.error(err);
                    }
                    resolve(data.split(','));
                  });
                } else {
                  data = JSON.parse(data);
                  if (data && data.errors) {
                    const errMessages = data.errors;
                    errMessages.forEach((msgArr) => {
                      throw new Error(`Failed with error - ${JSON.stringify(msgArr.message)}`);
                    });
                  }
                }
              })
              // eslint-disable-next-line prefer-promise-reject-errors
              .catch((e) => Promise.reject(`${chalk.bold.red(e)}`));
          }
        } catch (e) {
          throw new Error('Error occurred in validation', e);
        }
      } else {
        resolve(ootbComponentsData.split(','));
      }
    });
  });
};

export const deleteInfinityServerComponent = async (componentKey) => {
  const serverConfig = await getPegaServerConfig();
  const { server } = serverConfig;
  const url = constructCompleteUrl(server, DELETE_COMPONENT_SERVICE_REST_ENDPOINT);
  const [componentName, rulesetName, rulesetVersion] = componentKey.split('~|~');
  const deleteUrl = `${url}/${componentName}/rulesetname/${rulesetName}/rulesetversion/${rulesetVersion}`;
  try {
    const OauthData = fs.readFileSync(TOKEN_PATH, 'utf8');

    let status = 500;

    if (OauthData) {
      const { access_token: accessToken, token_type: tokenType } = JSON.parse(OauthData);
      fetch(deleteUrl, {
        method: 'DELETE',
        agent: getHttpsAgent(serverConfig),
        headers: {
          Authorization: `${tokenType} ${accessToken}`
        }
      })
        .then((response) => {
          status = response.status;
          return response.text();
        })
        .then((resp) => {
          let respData;
          try {
            respData = JSON.parse(resp);
          } catch (e) {
            console.log(chalk.bold.redBright(`Failure : ${resp}`));
            process.exit(1);
          }

          if (status === 200) {
            console.log(chalk.bold.green(`Success : ${respData.message}`));
          } else {
            throw new Error(`${respData.message}`);
          }
        })
        .catch((e) => {
          if (status === 403) {
            // eslint-disable-next-line prefer-promise-reject-errors
            Promise.reject(`${chalk.bold.red('Error forbidden: User does not have privileges to Delete.')}`);
          } else {
            // eslint-disable-next-line prefer-promise-reject-errors
            Promise.reject(`${chalk.bold.red(e)}`);
          }
        });
    }
  } catch (error) {
    console.log(`\n${chalk.bold.red(error)}`);
  }
};

export const deleteLaunchpadServerComponent = async (componentKey) => {
  const { server, isolationId } = await getPegaServerConfig();
  const deleteUrl = constructCompleteUrl(server, LP_DELETE_COMPONENT_SERVICE_REST_ENDPOINT.replace('{isolationId}', isolationId));
  const [componentName] = componentKey.split('~|~');

  try {
    const OauthData = fs.readFileSync(TOKEN_PATH, 'utf8');

    let status = 500;

    if (OauthData) {
      const { access_token: accessToken, token_type: tokenType } = JSON.parse(OauthData);

      const headers = {
        Authorization: `${tokenType} ${accessToken}`,
        cookie: `Pega-AAT=${accessToken}`,
        'Content-Type': 'application/json'
      };

      const apiBody = {
        type: 'CustomComponent',
        componentName
      };

      fetch(deleteUrl, {
        method: 'DELETE',
        agent: new https.Agent({ rejectUnauthorized: false }),
        headers,
        body: JSON.stringify(apiBody)
      })
        .then((response) => {
          status = response.status;
          return response.text();
        })
        .then((response) => {
          if (status === 401) {
            throw new Error('Error occurred in authentication. Please regenerate using authenticate');
            // console.log(accessTokenUri, refreshToken);
            /* TODO - Handle refresh_token */
          } else if (status === 200 || status === 201) {
            console.log(chalk.bold.green(`Success : ${response}`));
          } else {
            throw new Error(`${response.message}`);
          }
        })
        .catch((e) => {
          if (status === 403) {
            // eslint-disable-next-line prefer-promise-reject-errors
            Promise.reject(`${chalk.bold.red('Error forbidden: User does not have privileges to Delete.')}`);
          } else {
            // eslint-disable-next-line prefer-promise-reject-errors
            Promise.reject(`${chalk.bold.red(e)}`);
          }
        });
    }
  } catch (error) {
    console.log(`\n${chalk.bold.red(error)}`);
  }
};
