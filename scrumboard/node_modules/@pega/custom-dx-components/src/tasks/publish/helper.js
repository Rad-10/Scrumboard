import fs from 'fs';
import path from 'path';

import fetch from 'node-fetch';
import AdmZip from 'adm-zip';
import chalk from 'chalk';

import {
  constructCompleteUrl,
  getComponentDirectoryPath,
  getComponents,
  getPegaServerConfig,
  validateRulesetVersion,
  getHttpsAgent
} from '../../util.js';
import { PUBLISH_COMPONENT_SERVICE_REST_ENDPOINT, LP_PUBLISH_COMPONENT_SERVICE_REST_ENDPOINT, TOKEN_PATH } from '../../constants.js';

export const getPublishComponentQuestions = async () => {
  const components = await getComponents();

  if (components.length === 0) {
    console.log(chalk.redBright('No components to publish'));
    process.exit();
  }

  const defaultPegaConfig = await getPegaServerConfig();

  return [
    {
      name: 'componentKey',
      type: 'rawlist',
      message: 'Select component to publish',
      choices: components
    },
    {
      name: 'rulesetName',
      message: 'Enter ruleset name',
      default: defaultPegaConfig.rulesetName,
      validate: (value) => {
        if (value.trim()) {
          return true;
        }
        return 'Ruleset name cannot be empty';
      },
      when: () => {
        return defaultPegaConfig.serverType === 'infinity';
      }
    },
    {
      name: 'rulesetVersion',
      message: 'Enter ruleset version',
      default: defaultPegaConfig.rulesetVersion,
      validate: (value) => {
        if (validateRulesetVersion(value)) {
          return true;
        }
        return 'Please provide compatible version e.g 01-01-01';
      },
      when: () => {
        return defaultPegaConfig.serverType === 'infinity';
      }
    },
    {
      name: 'sourceMap',
      message: 'Generate source map ?',
      default: defaultPegaConfig.sourceMap,
      // eslint-disable-next-line sonarjs/no-redundant-boolean
      when: () => false && !process.env.SOURCE_MAP
    },
    {
      name: 'devBuild',
      type: 'confirm',
      message: 'Generate development build ?',
      default: defaultPegaConfig.devBuild
    }
  ];
};

export const zipComponent = async (componentKey) => {
  const srcDirectory = await getComponentDirectoryPath(componentKey);
  const buildDirectory = await path.join(path.resolve(), 'dist/components', componentKey);
  const configJson = `${srcDirectory}/config.json`;

  const zip = new AdmZip();

  zip.addLocalFolder(srcDirectory, 'src/');
  zip.addLocalFile(configJson);
  zip.addLocalFolder(buildDirectory);
  const zipContent = zip.toBuffer().toString('base64');

  const configContent = Buffer.from(fs.readFileSync(`${srcDirectory}/config.json`)).toString();

  fs.rmdir('dist', { recursive: true }, (err) => {
    if (err) {
      throw err;
    }
  });

  return { zipContent, configContent };
};

export const publishComponentToServer = async (data, doFetch) => {
  const { configContent, zipContent, rulesetName, rulesetVersion } = data;

  const defaultPegaServerConfig = await getPegaServerConfig();
  const { serverType, isolationId } = defaultPegaServerConfig;
  const isLaunchpad = serverType === 'launchpad';
  const launchpadRestEndpoint = LP_PUBLISH_COMPONENT_SERVICE_REST_ENDPOINT.replace('{isolationId}', isolationId);
  let apiBody;

  if (isLaunchpad) {
    apiBody = {
      type: 'CustomComponent',
      zipContent,
      componentName: JSON.parse(configContent).componentKey,
      pxUpdateDateTime: '',
      environmentID: defaultPegaServerConfig.isolationId
    };
  } else {
    apiBody = {
      configContent,
      zipContent,
      componentKey: JSON.parse(configContent).componentKey,
      publishFor: 'constellation',
      rulesetName,
      rulesetVersion,
      category: ''
    };
  }

  const defaultPegaConfig = await getPegaServerConfig();
  const url = constructCompleteUrl(defaultPegaConfig.server, isLaunchpad ? launchpadRestEndpoint : PUBLISH_COMPONENT_SERVICE_REST_ENDPOINT);

  if (doFetch) {
    try {
      const OauthData = fs.readFileSync(TOKEN_PATH, 'utf8');
      if (OauthData) {
        const {
          access_token: accessToken,
          token_type: tokenType
          // refresh_token: refreshToken
        } = JSON.parse(OauthData);
        let status = 500;
        const headers = {
          Authorization: `${tokenType} ${accessToken}`
        };

        if (isLaunchpad) {
          headers.cookie = `Pega-AAT=${accessToken}`;
          headers['Content-Type'] = 'application/json';
        }

        fetch(url, {
          method: 'POST',
          agent: getHttpsAgent(defaultPegaConfig),
          headers,
          body: JSON.stringify(apiBody)
        })
          .then((response) => {
            status = response.status;
            return response.text();
          })
          .then((resp) => {
            const respData = isLaunchpad ? resp : JSON.parse(resp);
            if (status === 401) {
              throw new Error('Error occurred in authentication. Please regenerate using authenticate');
              // console.log(accessTokenUri, refreshToken);
              /* TODO - Handle refresh_token */
            } else if (status === 200 || status === 201) {
              console.log(chalk.bold.green(`Success : ${isLaunchpad ? respData : respData.message}`));
            } else {
              throw new Error(`${respData.message}`);
            }
          })
          .catch((e) => {
            if (e.code === 'ECONNREFUSED') {
              // eslint-disable-next-line prefer-promise-reject-errors
              Promise.reject(`${chalk.bold.red('Error occurred in authentication. Please regenerate using authenticate')}`);
            } else if (status === 403) {
              // eslint-disable-next-line prefer-promise-reject-errors
              Promise.reject(`${chalk.bold.red('Error forbidden: User does not have privileges to Publish.')}`);
            } else {
              // eslint-disable-next-line prefer-promise-reject-errors
              Promise.reject(`${chalk.bold.red(e)}`);
            }
          });
      } else {
        throw new Error(`Error occurred in authentication. Please regenerate using authenticate`);
      }
    } catch (err) {
      throw new Error(`Error occurred in authentication. Please regenerate using authenticate`);
    }
  }
};
