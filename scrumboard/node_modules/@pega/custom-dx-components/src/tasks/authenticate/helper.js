/* eslint-disable import/prefer-default-export */
import { AUTHENTICATE_SCHEMA, AUTHENTICATE_DEFAULTS } from '../../constants.js';

export const getAuthQuestions = async (dxcbConfig) => {
  const defaultPegaConfig = dxcbConfig;
  const aAlwaysAsk = dxcbConfig.questions_askAlways ? dxcbConfig.questions_askAlways.split(',') : [];
  const aNeverAsk = dxcbConfig.questions_askNever ? dxcbConfig.questions_askNever.split(',') : [];
  const aAskOnce = dxcbConfig.questions_askOnce ? dxcbConfig.questions_askOnce.split(',') : [];
  const aAskedOnce = dxcbConfig.questions_askedOnce ? dxcbConfig.questions_askedOnce.split(',') : [];

  // Ask if various must, never, once criteria are met
  const askThisTime = (prop) => {
    return aAlwaysAsk.includes(prop) ||
      (!aNeverAsk.includes(prop) && (aAskOnce.includes(prop) && !aAskedOnce.includes(prop)));
  };

  const initAnswer = (prop, defValue) => {
    if (askThisTime(prop)) {
      return undefined;
    }
    return defaultPegaConfig[prop] ? defaultPegaConfig[prop] : defValue;
  };

  const initAnswers = (answers) => {
    // Setup default answers (if they are present and non-empty)
    answers.serverType = initAnswer('serverType', AUTHENTICATE_DEFAULTS.serverType);
    answers.server = initAnswer('server', AUTHENTICATE_DEFAULTS.server);
    answers.isolationId = initAnswer('isolationId');
    answers.clientId = initAnswer('clientId', AUTHENTICATE_DEFAULTS.clientId);
    answers.grantType = initAnswer('grantType', AUTHENTICATE_DEFAULTS.grantType);
    answers.authService = initAnswer('authService', AUTHENTICATE_DEFAULTS.authService);
    answers.redirectUri = initAnswer('redirectUri', AUTHENTICATE_DEFAULTS.redirectUri);
    answers.clientSecret = initAnswer('clientSecret');
    answers.user = initAnswer('user');
    answers.password = initAnswer('password');
    answers.aAsked = [];
  };

  const fnStandardWhen = (prop, answers) => {
    const ask = askThisTime(prop) || !answers[prop];
    if (ask) {
      answers.aAsked.push(prop);
    }
    return ask;
  };

  return [
    {
      name: 'serverType',
      type: 'rawlist',
      message: 'Enter Pega server type',
      default: answers => {
        return defaultPegaConfig.serverType;
      },
      choices: AUTHENTICATE_SCHEMA.serverType,
      validate: value => {
        if (value.trim()) {
          return true;
        }
        return 'Pega server type cannot be empty';
      },
      when: answers => {
        initAnswers(answers);
        return fnStandardWhen('serverType', answers);
      }
    },
    {
      name: 'server',
      type: 'input',
      message: 'Enter pega server url',
      default: defaultPegaConfig.server,
      validate: value => {
        if (value.trim()) {
          return true;
        }
        return 'Pega server cannot be empty';
      },
      when: answers => {
        return fnStandardWhen('server', answers);
      }
    },
    {
      name: 'isolationId',
      tpye: 'input',
      message: 'Enter isolation id',
      default: defaultPegaConfig.isolationId,
      validate: value => {
        if (value.trim()) {
          return true;
        }
        return 'Launchpad isolationId cannot be empty';
      },
      when: answers => {
        return answers.serverType === "launchpad" && fnStandardWhen('isolationId', answers);
      }
    },
    {
      name: 'grantType',
      type: 'rawlist',
      message: 'Enter OAuth 2.0 grant type',
      default: defaultPegaConfig.grantType,
      choices: answers => {
        return AUTHENTICATE_SCHEMA.grantType.filter(gt => !(answers.serverType === "launchpad" && gt.value === "passwordCreds"));
      },
      validate: value => {
        if (value.trim()) {
          return true;
        }
        return 'Grant type cannot be empty';
      },
      when: answers => {
        return fnStandardWhen('grantType', answers);
      }
    },
    {
      name: 'authService',
      type: 'input',
      message: 'Enter authentication service alias',
      default: defaultPegaConfig.authService,
      validate: value => {
        if (value.trim()) {
          return true;
        }
        return 'Authentication service alias cannot be empty';
      },
      when: answers => {
        return answers.serverType === "infinity" && answers.grantType === "authCode" && fnStandardWhen('authService', answers);
      }
    },
    {
      name: 'redirectUri',
      type: 'input',
      message: 'Enter valid redirect Uri within OAuth 2.0 client reg reccord',
      default: defaultPegaConfig.redirectUri,
      validate: value => {
        if (value.trim()) {
          return true;
        }
        return 'Redirect URI cannot be empty';
      },
      when: answers => {
        return answers.serverType === "infinity" && answers.grantType === "authCode" && fnStandardWhen('redirectUri', answers);
      }
    },
    {
      name: 'user',
      type: 'input',
      message: 'Enter user id',
      default: defaultPegaConfig.user,
      validate: (value, answers) => {
        if (value.trim() || answers.grantType === "authCode") {
          return true;
        }
        return 'Username cannot be empty';
      },
      when: answers => {
        return (answers.serverType === "infinity" && answers.grantType === "passwordCreds") && fnStandardWhen('user', answers);
      }
    },
    {
      name: 'password',
      type: 'password',
      message: 'Enter password',
      default: defaultPegaConfig.password,
      validate: (value, answers) => {
        if (value.trim() || answers.grantType === "authCode") {
          return true;
        }
        return 'Password cannot be empty';
      },
      when: answers => {
        return (answers.user && (answers.serverType === "infinity" && answers.grantType === "passwordCreds") && fnStandardWhen('password', answers));
      }
    },
    {
      name: 'clientId',
      type: 'input',
      message: 'Enter clientId',
      default: defaultPegaConfig.clientId,
      validate: value => {
        if (value.trim()) {
          return true;
        }
        return 'clientId cannot be empty';
      },
      when: answers => {
        return fnStandardWhen('clientId', answers);
      }
    },
    {
      name: 'clientSecret',
      type: 'password',
      message: 'Enter clientSecret',
      default: defaultPegaConfig.clientSecret,
      validate: value => {
        if (value.trim()) {
          return true;
        }
        return 'clientSecret cannot be empty';
      },
      when: answers => {
        return (((answers.serverType === "infinity" && answers.grantType !== "authCode") ||
          answers.serverType === "launchpad") && fnStandardWhen('clientSecret', answers));
      }
    }
  ];
};
