import fs from 'fs';
import path from 'path';

import fetch from 'node-fetch';
import AdmZip from 'adm-zip';
import chalk from 'chalk';

import { constructCompleteUrl, getComponentDirectoryPath, getComponents, getPegaServerConfig, getHttpsAgent } from '../../util.js';
import { PUBLISH_COMPONENT_SERVICE_REST_ENDPOINT, TOKEN_PATH } from '../../constants.js';

export const getPublishComponentQuestions = async () => {
  const components = await getComponents();

  if (components.length === 0) {
    console.log(chalk.redBright('No components to build'));
    process.exit();
  }

  const defaultPegaConfig = await getPegaServerConfig();

  return [
    {
      name: 'componentKey',
      type: 'rawlist',
      message: 'Select component to build',
      choices: components
    },
    {
      name: 'sourceMap',
      message: 'Generate source map ?',
      default: defaultPegaConfig.sourceMap,
      // eslint-disable-next-line sonarjs/no-redundant-boolean
      when: () => false && !process.env.SOURCE_MAP
    },
    {
      name: 'devBuild',
      type: 'confirm',
      message: 'Generate development build ?',
      default: defaultPegaConfig.devBuild
    }
  ];
};

export const zipComponent = async (componentKey) => {
  const srcDirectory = await getComponentDirectoryPath(componentKey);
  const buildDirectory = await path.join(path.resolve(), 'dist/components', componentKey);
  const configJson = `${srcDirectory}/config.json`;

  const zip = new AdmZip();

  zip.addLocalFolder(srcDirectory, 'src/');
  zip.addLocalFile(configJson);
  zip.addLocalFolder(buildDirectory);
  const zipContent = zip.toBuffer().toString('base64');

  const configContent = Buffer.from(fs.readFileSync(`${srcDirectory}/config.json`)).toString();
  fs.rmdir('dist', { recursive: true }, (err) => {
    if (err) {
      throw err;
    }
  });
  return { zipContent, configContent };
};

export const publishComponentToServer = async (data) => {
  const { configContent, zipContent, rulesetName, rulesetVersion } = data;

  const apiBody = {
    configContent,
    zipContent,
    componentKey: JSON.parse(configContent).componentKey,
    publishFor: 'constellation',
    rulesetName,
    rulesetVersion,
    category: ''
  };
  const defaultPegaConfig = await getPegaServerConfig();
  const url = constructCompleteUrl(defaultPegaConfig.server, PUBLISH_COMPONENT_SERVICE_REST_ENDPOINT);
  try {
    const OauthData = fs.readFileSync(TOKEN_PATH, 'utf8');
    if (OauthData) {
      const { access_token: accessToken, token_type: tokenType } = JSON.parse(OauthData);
      let status = 500;
      fetch(url, {
        method: 'POST',
        agent: getHttpsAgent(defaultPegaConfig),
        headers: {
          Authorization: `${tokenType} ${accessToken}`
        },
        body: JSON.stringify(apiBody)
      })
        .then((response) => {
          status = response.status;
          return response.text();
        })
        .then((resp) => {
          const respData = JSON.parse(resp);
          if (status === 401) {
            throw new Error('Error occurred in authentication. Please regenerate using authenticate');
            // console.log(accessTokenUri, refreshToken);
            /* TODO - Handle refresh_token */
          } else if (status === 200) {
            console.log(chalk.bold.green(`Success : ${respData.message}`));
          } else {
            throw new Error(`${respData.message}`);
          }
        })
        // eslint-disable-next-line prefer-promise-reject-errors
        .catch((e) => Promise.reject(`${chalk.bold.red(e)}`));
    } else {
      throw new Error(`Error occurred in authentication. Please regenerate using authenticate`);
    }
  } catch (err) {
    throw new Error(`Error occurred in authentication. Please regenerate using authenticate`);
  }
};
