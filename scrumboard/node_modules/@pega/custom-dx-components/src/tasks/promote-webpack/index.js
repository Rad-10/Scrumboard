
import fs from 'fs';
import path from 'path';
import { join } from 'path';
import { URL, fileURLToPath } from 'url';
import chalk from 'chalk';
import inquirer from 'inquirer';

import {
  convertIntoPascalCase,
  checkPathAccess,
  showVersion
} from '../../util.js';

import {
  WEBPACK_CONFIG_JS_FILENAME,
  WEBPACK_PATHS_JS_FILENAME,
  PACKAGE_JSON_FILENAME,
  BUILDER_INDEX_FILE_PATH,
  BUILDER_DIR_FILE_PATH
} from '../../constants.js';



let redirectFile = "";

export const copyWebPack = async () => {

   // first check to see if already have the file
  const newWebPackConfigDir = path.resolve(WEBPACK_CONFIG_JS_FILENAME);
  const newWebPackPathsDir = path.resolve(WEBPACK_PATHS_JS_FILENAME);
  let override = true;
  if (fs.existsSync(newWebPackConfigDir)) {

    console.log("Promoted file " + chalk.bold.yellow(`${newWebPackConfigDir}`) + " already exists.");
    const questions = [
      {
        name: 'override',
        type: 'confirm',
        message: `Overwrite`,
        default: false
      }
    ];

    await inquirer.prompt(questions).then(async answers => {
      override = answers.override;
      });

  }


  if (override) {

    const currentDirectory = process.cwd();
    const packageJsonPath = join(currentDirectory, PACKAGE_JSON_FILENAME);

    await checkPathAccess(packageJsonPath);

    let data = fs.readFileSync(packageJsonPath, { encoding: 'utf8' });
    data = JSON.parse(data);

    // if top level package.json is of type=module, then promote standard webpack.config.js that is being
    // used in builder (along with paths.js file), otherwise promote the local copy in promote-webpack directory, which is a version
    // modified to support "require" instead of "import" (and paths code is inside the webpack.config.js file)
    if (data["type"] && data["type"] === "module") {
      const builderIndexDir = fileURLToPath(new URL(BUILDER_DIR_FILE_PATH, import.meta.url));

      const promoteWebPackConfigDir = path.resolve(path.join(builderIndexDir, WEBPACK_CONFIG_JS_FILENAME));
      const promoteWebPackPathsDir = path.resolve(path.join(builderIndexDir, WEBPACK_PATHS_JS_FILENAME));

      fs.copyFileSync(promoteWebPackConfigDir, newWebPackConfigDir);
      fs.copyFileSync(promoteWebPackPathsDir, newWebPackPathsDir);
    }
    else {
      const newWebPackDir = path.resolve(WEBPACK_CONFIG_JS_FILENAME);
      const promoteWebPackDir = fileURLToPath(new URL(WEBPACK_CONFIG_JS_FILENAME, import.meta.url));

      fs.copyFileSync(promoteWebPackDir, newWebPackDir);
    }






  }

  redirectFile = newWebPackConfigDir;



}

export const updateBuilder = async () => {

  const builderIndexDir = fileURLToPath(new URL(BUILDER_INDEX_FILE_PATH, import.meta.url));

  let indexFileJS = fs.readFileSync(builderIndexDir, { encoding: 'utf8' });

  if (indexFileJS.length > 0) {
    // comment out original webpack reference

    // if not commented out, comment out
    if (indexFileJS.indexOf("// import configFactory from './webpack.config.js';") < 0) {
      indexFileJS = indexFileJS.replaceAll("import configFactory from './webpack.config.js';", "// import configFactory from './webpack.config.js';");
    }

    // uncomment out promoted webpack reference
    indexFileJS = indexFileJS.replaceAll("// import configFactory from '../../../../../../../webpack.config.js';", "import configFactory from '../../../../../../../webpack.config.js';");

    fs.writeFileSync(builderIndexDir, indexFileJS, { encoding: 'utf8' });

    console.log(chalk.bold.green(`Bundler now using ${redirectFile}.`));
    console.log(chalk.bold.green(`Utilize this file for webpack modifications.`));
  }


}

export default async options => {
  showVersion();

  await copyWebPack();
  await updateBuilder();

};
