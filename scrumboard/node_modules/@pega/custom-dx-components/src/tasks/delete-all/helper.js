import chalk from 'chalk';
import inquirer from 'inquirer';
import ora from 'ora';

import {
  deleteLocalComponent,
  deleteServerComponent,
  getComponents,
  getPegaServerConfig,
  validateRulesetVersion
} from '../../util.js';
import { getComponentsFromServer } from '../list/helper.js';

export const SOURCE_OF_COMPONENT_TYPES = {
  SERVER: 'Server',
  LOCAL: 'Local'
};

export const getDeleteComponentsQuestions = async (options, sourceOfComponentsOption) => {
  const defaultPegaServerConfig = await getPegaServerConfig();


  return [
    {
      name: 'sourceOfComponents',
      type: 'rawlist',
      message: 'Delete components from Server or Local ?',
      choices: Object.values(SOURCE_OF_COMPONENT_TYPES),
      default: defaultPegaServerConfig.sourceOfComponents,
      when() {
        return !options.params[3];
      }
    }
  ];
};



export const deleteLocalComponents = async sourceOfComponents => {
  const localComponents = await getComponents();

  for (var index in localComponents) {
    console.log(chalk.bold.green(localComponents[index]));
  }

  if (localComponents.length > 0) {
    const answers = await inquirer.prompt([

      {
        name: 'confirmDeletion',
        type: 'confirm',
        message: 'Delete all local ?',
        default: false
      }
    ]);
    if (answers.confirmDeletion) {
      for (var index in localComponents) {
        var componentToDelete = localComponents[index];
        //console.log(chalk.bold.green("Deleting: " + componentToDelete));
        await deleteLocalComponent(componentToDelete);
      }
    }
  } else {
    console.log(chalk.bold.redBright(`No custom components in ${sourceOfComponents}`));
  }
};

export const deleteServerComponents = async (sourceOfComponents, answers) => {
  const spinner = ora('Fetching components from server').start();
  const data = await getComponentsFromServer(answers);
  const defaultPegaConfig = await getPegaServerConfig();

  const serverComponents = JSON.parse(data);
  spinner.stop();
  if (serverComponents && serverComponents.pxResults?.length > 0) {
    const choicesArr = serverComponents.pxResults.map(({ label, pyRuleSet, pyRuleSetVersion }) => {
      const name = `${standardizeStr(label, 45)} ${standardizeStr(pyRuleSet, 30)} ${standardizeStr(
        pyRuleSetVersion,
        20
      )}`;

      const value = `${label}~|~${pyRuleSet}~|~${pyRuleSetVersion}`;
      const short = `Selected component : ${chalk.redBright(
        `${label} ${pyRuleSet} : ${pyRuleSetVersion}`
      )}`;

      return { name, value, short };
    });

    const selectedComp = await inquirer.prompt([
      {
        name: 'rulesetName',
        message: 'Enter ruleset name',
        default: defaultPegaConfig.rulesetName,
        validate: value => {
          if (value.trim()) {
            return true;
          }
          return 'Ruleset name cannot be empty';
        }
      },
      {
        name: 'rulesetVersion',
        message: 'Enter ruleset version',
        default: defaultPegaConfig.rulesetVersion,
        validate: value => {
          if (validateRulesetVersion(value)) {
            return true;
          }
          return 'Please provide compatible version e.g 01-01-01';
        }
      }
      ]);

      for (var index in choicesArr) {
        var componentToDelete = choicesArr[index].value;
        var arData = componentToDelete.split("~|~");
        if (arData[1] == selectedComp.rulesetName && arData[2] == selectedComp.rulesetVersion) {
          console.log(chalk.bold.green(arData[0]));
        }
      }


    const answers = await inquirer.prompt([
      {
        name: 'confirmDeletion',
        type: 'confirm',
        message: 'Do you want to delete these components ?',
        default: false
      }
    ]);
    if (answers.confirmDeletion) {
      for (var index in choicesArr) {
        var componentToDelete = choicesArr[index].value;
        var arData = componentToDelete.split("~|~");
        if (arData[1] == selectedComp.rulesetName && arData[2] == selectedComp.rulesetVersion) {
          await deleteServerComponent(componentToDelete);
        }
      }
    }


  } else {
    console.log(chalk.bold.redBright(`No custom components in ${sourceOfComponents}`));
  }
};

export const standardizeStr = (str, leng) => {
  for (let i = str.length; i <= leng; i++) {
    str += ' ';
  }
  return str;
};
